# at: src/main/java/org/zstack/accessKey/AccessKeyApiInterceptor.java:44
# args: accountUuid,userUuid
no\ pemission\ to\ do\ the\ operation\ for\ [accountUuid\:%s,\ userUuid\:%s] = no pemission to do the operation for [accountUuid:{0}, userUuid:{1}]

# at: src/main/java/org/zstack/accessKey/AccessKeyApiInterceptor.java:51
# args: 
If\ a\ specified\ Accesskey\ is\ expected,\ the\ AccesskeyId\ and\ the\ AccesskeySecret\ must\ be\ provided\ at\ the\ same\ time. = If a specified Accesskey is expected, the AccesskeyId and the AccesskeySecret must be provided at the same time.

# at: src/main/java/org/zstack/accessKey/AccessKeyApiInterceptor.java:65
# args: msg.getAccountUuid(),msg.getUserUuid()
[accountId\:\ %s,\ userID\:\ %s]\ is\ not\ valid\ account\ or\ iam2\ porject/user = [accountId: {0}, userID: {1}] is not valid account or iam2 porject/user

# at: src/main/java/org/zstack/accessKey/AccessKeyApiInterceptor.java:77
# args: msg.getAccountUuid(),msg.getUserUuid()
accessKey\ number\ for\ [accountId\:\ %s,\ userID\:\ %s]exceeds\ the\ max = accessKey number for [accountId: {0}, userID: {1}]exceeds the max

# at: src/main/java/org/zstack/acl/AccessControlListApiInterceptor.java:92
# args: ipVer
not\ support\ the\ ip\ version\ %d = not support the ip version {0}

# at: src/main/java/org/zstack/acl/AccessControlListApiInterceptor.java:98
# args: ips,acl.getUuid()
%s\ duplicate/overlap\ ip\ entry\ with\ access-control-list\ group\:%s = {0} duplicate/overlap ip entry with access-control-list group:{1}

# at: src/main/java/org/zstack/acl/AccessControlListApiInterceptor.java:105
# args: ips
ip\ format\ only\ supports\ ip/iprange/cidr,\ but\ find\ %s = ip format only supports ip/iprange/cidr, but find {0}

# at: src/main/java/org/zstack/acl/AccessControlListApiInterceptor.java:109
# args: startIp,endIp,NetworkUtils.longToIpv4String(r.lowerEndpoint()),NetworkUtils.longToIpv4String(r.upperEndpoint()),acl.getUuid()
ip\ range[%s,\ %s]\ is\ overlap\ with\ [%s,\ %s]\ in\ access-control-list\ group\:%s = ip range[{0}, {1}] is overlap with [{2}, {3}] in access-control-list group:{4}

# at: src/main/java/org/zstack/acl/AccessControlListApiInterceptor.java:127
# args: acl.getUuid(),AccessControlListConstants.MAX_ENTRY_COUNT_PER_GROUP
the\ access-control-list\ groups[%s]\ can't\ be\ added\ more\ than\ %d\ ip\ entries = the access-control-list groups[{0}] can't be added more than {1} ip entries

# at: src/main/java/org/zstack/aliyun/account/AliyunAccountBase.java:348
# args: builder.deleteCharAt(builder.length() - 1),timeout
cannot\ connect\ to\ [%s]\ in\ %d\ milliseconds,\ so\ aliyun\ openapi\ is\ unreachable. = cannot connect to [{0}] in {1} milliseconds, so aliyun openapi is unreachable.

# at: src/main/java/org/zstack/aliyun/backup/BackupToAliyunBase.java:465
# args: 
no\ bucket\ found\ for\ backup = no bucket found for backup

# at: src/main/java/org/zstack/aliyun/core/AliyunEbsClient.java:28
# args: 
accessKey\ and\ keySecret\ must\ be\ set = accessKey and keySecret must be set

# at: src/main/java/org/zstack/aliyun/core/AliyunEbsClient.java:73
# args: 
ocean\ api\ endpoint\ must\ not\ be\ null = ocean api endpoint must not be null

# at: src/main/java/org/zstack/aliyun/core/AliyunNasClient.java:33
# args: 
accessKey\ and\ keySecret\ must\ be\ set! = accessKey and keySecret must be set!

# at: src/main/java/org/zstack/aliyun/core/AliyunNasClient.java:40
# args: 
regionId\ must\ be\ set! = regionId must be set!

# at: src/main/java/org/zstack/aliyun/core/AliyunSdkImpl.java:238
# args: 
cannot\ find\ key\ /\ secret\ from\ msg = cannot find key / secret from msg

# at: src/main/java/org/zstack/aliyun/core/AliyunSdkImpl.java:2131
# args: AliyunConstant.DEFAULT_ENTRY_WAIT_STATUS_TIMEOUT
entry\ is\ still\ existed\ after\ %s\ ms = entry is still existed after {0} ms

# at: src/main/java/org/zstack/aliyun/core/AliyunSdkImpl.java:2637
# args: request.getInstanceIds()
cannot\ find\ EcsInstance[%s],\ please\ check\ if\ it\ exists\ in\ Aliyun\ console = cannot find EcsInstance[{0}], please check if it exists in Aliyun console

# at: src/main/java/org/zstack/aliyun/core/AliyunSdkImpl.java:2697
# args: 
image\ already\ existed\ remote,\ please\ use\ sync\ first. = image already existed remote, please use sync first.

# at: src/main/java/org/zstack/aliyun/core/AliyunSdkImpl.java:2883
# args: 
no\ identity\ zones\ can\ be\ used\ now = no identity zones can be used now

# at: src/main/java/org/zstack/aliyun/core/AliyunSdkImpl.java:3019
# args: request.getRegionId()
regionId[%s]\ is\ invalid\ by\ aliyun! = regionId[{0}] is invalid by aliyun!

# at: src/main/java/org/zstack/aliyun/core/AliyunStorageSdkIml.java:63
# args: 
Not\ a\ valid\ message! = Not a valid message!

# at: src/main/java/org/zstack/aliyun/core/AliyunStorageSdkIml.java:159
# args: action,result.ErrorCode,result.ErrorMessage
%s\ failed,\ ErrorCode\:\ %s,\ ErrorMessage\:\ %s = {0} failed, ErrorCode: {1}, ErrorMessage: {2}

# at: src/main/java/org/zstack/aliyun/core/AliyunStorageSdkIml.java:282
# args: 15000
Device\ Not\ Ready\ in\ %d\ milli\ seconds = Device Not Ready in {0} milli seconds

# at: src/main/java/org/zstack/aliyun/core/AliyunStorageSdkIml.java:476
# args: result.Content.TaskStatus
snapshot\ task\ status\ is\ finished\ %s = snapshot task status is finished {0}

# at: src/main/java/org/zstack/aliyun/core/AliyunStorageSdkIml.java:472
# args: msg.getTimeout(),result.Content.Progress,result.Content.TaskStatus
snapshot\ task\ cannot\ finished\ in\ %d\ milliseconds,\ now\ progress\ is\ %d,\ status\ is\ %s = snapshot task cannot finished in {0} milliseconds, now progress is {1}, status is {2}

# at: src/main/java/org/zstack/aliyun/core/AliyunStorageSdkIml.java:877
# args: 
not\ supported\ HybridClient = not supported HybridClient

# at: src/main/java/org/zstack/aliyun/core/AliyunUtils.java:263
# args: e.getMessage()
add\ endpoint\ to\ sdk\ failed,\ due\ to\:\ %s = add endpoint to sdk failed, due to: {0}

# at: src/main/java/org/zstack/aliyun/core/OssSdkImpl.java:407
# args: 
cannot\ input\ 0-length\ file\ as\ vm\ images! = cannot input 0-length file as vm images!

# at: src/main/java/org/zstack/aliyun/core/OssSdkImpl.java:496
# args: e.getMessage()
Permission\ denied\ for\:\ %s = Permission denied for: {0}

# at: src/main/java/org/zstack/aliyun/core/OssSdkImpl.java:585
# args: e.getRequestId()
Bucket\ name\ is\ already\ existed\ (maybe\ created\ by\ other\ user),\ Please\ select\ a\ different\ name\ and\ try\ again.(aliyun\ request-id\:\ %s) = Bucket name is already existed (maybe created by other user), Please select a different name and try again.(aliyun request-id: {0})

# at: src/main/java/org/zstack/aliyun/core/datacenter/AliyunPrivateDataCenterBase.java:277
# args: HybridType.AliyunEBS.toString()
arg\ 'endpoint'\ must\ be\ set\ in\ %s\ type = arg 'endpoint' must be set in {0} type

# at: src/main/java/org/zstack/aliyun/core/datacenter/AliyunPrivateDataCenterBase.java:332
# args: type.toString()
not\ supported\ datacenter\ [%s]\ type\ here! = not supported datacenter [{0}] type here!

# at: src/main/java/org/zstack/aliyun/core/identityzone/AliyunPrivateIdentityZoneBase.java:252
# args: 
must\ indicate\ zoneId\ in\ private\ aliyun. = must indicate zoneId in private aliyun.

# at: src/main/java/org/zstack/aliyun/ebs/storage/OceanApi.java:87
# args: e.getMessage()
make\ ocean\ api\ signature\ string\ failed\:\ %s = make ocean api signature string failed: {0}

# at: src/main/java/org/zstack/aliyun/ebs/storage/backup/AliyunEbsBackupStorageApiInterceptor.java:30
# args: 
url(ocean\ endpoint)\ must\ be\ set\ for\ aliyun\ ebs\ backupstorage = url(ocean endpoint) must be set for aliyun ebs backupstorage

# at: src/main/java/org/zstack/aliyun/ebs/storage/backup/AliyunEbsBackupStorageBase.java:376
# args: 
aliyun\ ebs\ backup\ storage\ do\ not\ support\ to\ cancel\ download\ image = aliyun ebs backup storage do not support to cancel download image

# at: src/main/java/org/zstack/aliyun/ebs/storage/backup/AliyunEbsBackupStorageBase.java:620
# args: objectFile,ovo.getBucketName()
no\ such\ object\ %s\ found\ in\ bucket\ %s = no such object {0} found in bucket {1}

# at: src/main/java/org/zstack/aliyun/ebs/storage/backup/AliyunEbsBackupStorageCascadeExtenstion.java:46
# args: oss.getUuid(),evo.getUuid()
cannot\ delete\ oss\ bucket\ [%s],\ Aliyun\ Ebs\ BackupStorage\ [%s]\ still\ existed,\ please\ delete\ it\ first. = cannot delete oss bucket [{0}], Aliyun Ebs BackupStorage [{1}] still existed, please delete it first.

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsKvmFactory.java:147
# args: vol.getUuid()
cannot\ find\ device\ path\ from\ volume\:\ %s = cannot find device path from volume: {0}

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsKvmFactory.java:490
# args: 
aliyun\ ebs\ not\ support\ resize\ on\ running\ vm\ now. = aliyun ebs not support resize on running vm now.

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsKvmFactory.java:612
# args: isoUuid
iso\ [%s]\ has\ been\ attached,\ we\ can\ not\ attach\ it\ until\ detach\ it = iso [{0}] has been attached, we can not attach it until detach it

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageApiInterceptor.java:39
# args: msg.getUrl()
url\ must\ starts\ with\ http\://\ or\ https\://,\ but\ got\ %s = url must starts with http:// or https://, but got {0}

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageApiInterceptor.java:35
# args: 
url(ocean\ endpoint)\ must\ be\ set\ for\ aliyun\ ebs\ primarystorage = url(ocean endpoint) must be set for aliyun ebs primarystorage

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageApiInterceptor.java:43
# args: 
panguPartitionUuid\ or\ identityZoneUuid\ must\ be\ set. = panguPartitionUuid or identityZoneUuid must be set.

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageApiInterceptor.java:49
# args: msg.getPanguPartitionUuid(),msg.getIdentityZoneUuid()
panguPartitionUuid\ [%s]\ not\ be\ matched\ with\ identityZoneUuid\ [%s] = panguPartitionUuid [{0}] not be matched with identityZoneUuid [{1}]

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageBase.java:3189
# args: imageVO.getUuid()
image\ [uuid\:%s]\ has\ been\ deleted = image [uuid:{0}] has been deleted

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageBase.java:3762
# args: msg.getResourceUuid()
resource[uuid\:\ %s]\ cannot\ found = resource[uuid: {0}] cannot found

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageBase.java:674
# args: self.getUuid(),self.getName()
the\ aliyun\ ebs\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ any\ available\ host\ in\ attached\ clusters\ for\ instantiating\ the\ volume = the aliyun ebs primary storage[uuid:{0}, name:{1}] cannot find any available host in attached clusters for instantiating the volume

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageBase.java:2829
# args: reply1.getProgress()
create\ snapshot\ timeout,\ progress\ is\ %d = create snapshot timeout, progress is {0}

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageBase.java:1925
# args: msg.getVolume().getRootImageUuid()
cannot\ find\ snapshot\ from\ image\:\ %s,\ maybe\ the\ image\ has\ been\ deleted = cannot find snapshot from image: {0}, maybe the image has been deleted

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageBase.java:2687
# args: 
ebs\ primarystorage\ cannot\ support\ decrease\ size\ now = ebs primarystorage cannot support decrease size now

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageBase.java:3089
# args: bsvo.getType()
aliyun\ ebs\ primarystorage\ only\ support\ aliyun\ ebs\ bs,\ actually\ get\ type\:\ %s = aliyun ebs primarystorage only support aliyun ebs bs, actually get type: {0}

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageCascadeExtension.java:46
# args: iz.getUuid(),evo.getUuid()
cannot\ delete\ identity\ zone\ [%s],\ Aliyun\ Ebs\ PrimaryStorage\ [%s]\ still\ existed,\ please\ delete\ it\ first. = cannot delete identity zone [{0}], Aliyun Ebs PrimaryStorage [{1}] still existed, please delete it first.

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStoragePathMaker.java:113
# args: installPath
invalid\ install\ path\:\ %s = invalid install path: {0}

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStoragePathMaker.java:24
# args: volumeId,url
append\ volumeId\:\ %s,\ but\ another\ volumeId\ existed\ in\ url\:\ %s = append volumeId: {0}, but another volumeId existed in url: {1}

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStoragePathMaker.java:79
# args: url
invalid\ install\ url\:\ %s = invalid install url: {0}

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStoragePathMaker.java:35
# args: hostUuid,url
hostUuid\ [%s]\ already\ existed\ in\ url\:\ %s = hostUuid [{0}] already existed in url: {1}

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStoragePathMaker.java:83
# args: hostUuid
cannot\ find\ devicePath\ on\ host\:\ %s = cannot find devicePath on host: {0}

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStoragePathMaker.java:128
# args: installPath
invalid\ snapshot\ install\ path\:\ %s = invalid snapshot install path: {0}

# at: src/main/java/org/zstack/aliyun/ecs/CheckEcsImageExistPublicFlow.java:79
# args: eivo.getUuid(),eivo.getName(),eivo.getCreateDate()
ecs\ image\ existed\ remote\ and\ local,\ ecs\ image\ uuid\:\ %s,\ name\:\ %s,\ created\ time\:\ %s = ecs image existed remote and local, ecs image uuid: {0}, name: {1}, created time: {2}

# at: src/main/java/org/zstack/aliyun/ecs/CheckEcsImageExistPublicFlow.java:107
# args: msg.getName(),new SimpleDateFormat("yyyy/MM/dd HH:mm:ss").format(HybridUtilsForAliyun.fmtTime(rpl.getCreateDate()))
ecs\ image\ existed\ remote,\ name\:\ %s,\ created\ time\:\ %s = ecs image existed remote, name: {0}, created time: {1}

# at: src/main/java/org/zstack/aliyun/ecs/CreateEcsInstancePublicFlow.java:181
# args: 
No\ Available\ instance\ types\ now. = No Available instance types now.

# at: src/main/java/org/zstack/aliyun/ecs/CreateEcsInstancePublicFlow.java:304
# args: ecs.getUuid(),ecs.getEcsInstanceId()
no\ system\ disk\ found\ for\ ecs\:\ [%s],\ ecs\ id\ is\:\ [%s] = no system disk found for ecs: [{0}], ecs id is: [{1}]

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:65
# args: evo.getEcsStatus().toString()
Only\ delete\ ecs\ which\ status\ is\ running\ or\ stopped,\ now\ is\ %s = Only delete ecs which status is running or stopped, now is {0}

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:70
# args: evo.getChargeType().toString()
Only\ postpaid\ ecs\ support\ delete\ remote,\ the\ indicate\ ecs\ charge\ type\ is\:\ %s = Only postpaid ecs support delete remote, the indicate ecs charge type is: {0}

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:84
# args: 
Only\ admin\ can\ set\ parameter\ [onlyZstack]\ \=\ false = Only admin can set parameter [onlyZstack] = false

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:93
# args: evo.getAvailableIpAddressCount()
vSwitch\ availableIpAddress\ is\ not\ enough,\ now\ is\ (%d) = vSwitch availableIpAddress is not enough, now is ({0})

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:97
# args: privateIp,cidr
%s\ is\ not\ in\ cidr\ range\:\ %s = {0} is not in cidr range: {1}

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:103
# args: vSwitchUuid,ecs.getUuid()
private\ ip\ is\ existed\ in\ vswitch\:\ %s,\ allocated\ to\ ecs\:\ %s = private ip is existed in vswitch: {0}, allocated to ecs: {1}

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:137
# args: 
bandwidth\ must\ be\ set\ while\ allocate\ publicIp = bandwidth must be set while allocate publicIp

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:140
# args: msg.getPrivateIpAddress()
%s\ is\ not\ ipv4\ address = {0} is not ipv4 address

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:143
# args: msg.getEcsRootVolumeType(),EcsInstanceConstant.validVolumeCategory.toString()
%s\ is\ not\ valid\ volume\ type,\ valid\ types\ are\ [%s] = {0} is not valid volume type, valid types are [{1}]

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:147
# args: 
instanceOffering\ or\ instanceType\ must\ be\ set! = instanceOffering or instanceType must be set!

# at: src/main/java/org/zstack/aliyun/ecs/EcsInstanceManagerImpl.java:384
# args: rly1.getVncUrl()
decode\ url\ failed\:\ %s = decode url failed: {0}

# at: src/main/java/org/zstack/aliyun/ecs/ExportImageFromBSFlow.java:52
# args: 
image\ has\ been\ deleted! = image has been deleted!

# at: src/main/java/org/zstack/aliyun/identityzone/SelectValidIdentityZoneFlow.java:50
# args: 
no\ identity\ chosen,\ may\ be\ stock\ problems = no identity chosen, may be stock problems

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:71
# args: 
the\ operation\ only\ custom\ image = the operation only custom image

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:80
# args: 
Only\ system\ disks\ can\ create\ mirrors = Only system disks can create mirrors

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:131
# args: 
can\ not\ delete\ ecs\ system\ image\ remote = can not delete ecs system image remote

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:142
# args: 
Only\ support\ ImageStoreBackupStorage = Only support ImageStoreBackupStorage

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:145
# args: 
image\ name\ cannot\ starts\ with\ http\://\ or\ https\:// = image name cannot starts with http:// or https://

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:158
# args: imageUuid
no\ backup\ storage\ found\ for\ imageUuid\:\ %s = no backup storage found for imageUuid: {0}

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:162
# args: imageUuid
exceeded\ backup\ storage\ found\ for\ the\ imageUuid\:\ %s,\ please\ indicate\ it\ manually = exceeded backup storage found for the imageUuid: {0}, please indicate it manually

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:173
# args: platform,EcsImageConstant.ECS_IMAGE_PLATFORM.getValid()
valid\ platform\:[%s]\ for\ aliyun\ image\ import,\ valid\ value\ are\:\ [%s] = valid platform:[{0}] for aliyun image import, valid value are: [{1}]

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:178
# args: ivo.getUuid()
image\ [%s]\ is\ not\ enable\ now = image [{0}] is not enable now

# at: src/main/java/org/zstack/aliyun/image/EcsImageManagerImpl.java:306
# args: msg.getDataCenterUuid()
no\ ossbucket\ attached\ to\ the\ datacenter\:\ %s = no ossbucket attached to the datacenter: {0}

# at: src/main/java/org/zstack/aliyun/image/EcsImageManagerImpl.java:361
# args: msg.getImageUuid(),msg.getDataCenterUuid()
the\ indicated\ image\ [%s]\ is\ importing\ to\ datacenter\ [%s]\ now... = the indicated image [{0}] is importing to datacenter [{1}] now...

# at: src/main/java/org/zstack/aliyun/nas/core/AliyunNasApiInterceptor.java:44
# args: psUuids.toString()
PrimaryStorage\ [%s]\ still\ running,\ can\ not\ delete\ access\ group = PrimaryStorage [{0}] still running, can not delete access group

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasBase.java:194
# args: msg.getSourceCidrIp(),msg.getAccessGroupUuid()
access\ group\ rule\ [%s]\ already\ existed\ in\ access\ group\ [%s] = access group rule [{0}] already existed in access group [{1}]

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasBase.java:849
# args: msg.getName(),msg.getDataCenterUuid()
access\ group\ [%s]\ already\ existed\ in\ datacenter\ [%s] = access group [{0}] already existed in datacenter [{1}]

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasFileSystemBase.java:150
# args: self.getFileSystemId(),regionId
no\ filesystem\ [%s]\ found\ in\ region\:\ %s = no filesystem [{0}] found in region: {1}

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasFileSystemBase.java:203
# args: msg.getDataCenterUuid()
nas\ filesystem\ existed\ in\ datacenter\:\ %s = nas filesystem existed in datacenter: {0}

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasFileSystemBase.java:304
# args: refs.toString()
some\ primary\ storage\ [%s]\ used\ this\ nas,\ can\ not\ delete\ it\ until\ delete\ the\ primary\ storage. = some primary storage [{0}] used this nas, can not delete it until delete the primary storage.

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasMountTargetBase.java:314
# args: cmsg.getWait()
mount\ domain\ not\ valid\ after\ %d\ milliseconds,\ delete\ it... = mount domain not valid after {0} milliseconds, delete it...

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasMountTargetBase.java:422
# args: 
there\ are\ no\ nas\ access\ group\ existed,\ please\ create\ at\ least\ one = there are no nas access group existed, please create at least one

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasMountTargetBase.java:404
# args: self.getMountDomain(),self.getNasFileSystemUuid()
no\ such\ mount\ target\ [%s]\ in\ nas\:\ %s = no such mount target [{0}] in nas: {1}

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasMountTargetBase.java:472
# args: msg.getMountDomain(),msg.getNasFSUuid()
nas\ mount\ target\ [%s]\ existed\ in\ filesystem\:\ %s = nas mount target [{0}] existed in filesystem: {1}

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasMountTargetBase.java:512
# args: self.getAccessGroupUuid()
the\ access\ group\ attached\ is\ already\:\ %s = the access group attached is already: {0}

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:534
# args: vSwitchUuid
EcsVSwitchVO[%s]\ is\ not\ existed,\ may\ be\ it\ has\ been\ deleted! = EcsVSwitchVO[{0}] is not existed, may be it has been deleted!

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:527
# args: accessGroupUuid
AliyunNasAccessGroupVO[%s]\ is\ not\ existed,\ may\ be\ it\ has\ been\ deleted! = AliyunNasAccessGroupVO[{0}] is not existed, may be it has been deleted!

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:826
# args: self.getUuid()
cannot\ find\ an\ available\ host\ to\ operation\ in\ primary\ storage\:\ %s = cannot find an available host to operation in primary storage: {0}

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:905
# args: self.getUuid(),hostUuid,rsp.error
failed\ to\ ping\ aliyun\ nas\ primary\ storage[uuid\:%s]\ from\ host[uuid\:%s],because\ %s.\ disconnect\ this\ host-ps\ connection = failed to ping aliyun nas primary storage[uuid:{0}] from host[uuid:{1}],because {2}. disconnect this host-ps connection

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:1393
# args: 
nas\ primary\ storage\ not\ mounted,\ please\ init\ it\ first! = nas primary storage not mounted, please init it first!

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:1577
# args: bsType
cannot\ find\ any\ BackupStorageKvmFactory\ for\ the\ type[%s] = cannot find any BackupStorageKvmFactory for the type[{0}]

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:2003
# args: vol.getUuid()
cannot\ find\ host\ to\ operate\ volume\:\ [%s] = cannot find host to operate volume: [{0}]

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:2240
# args: self.getUuid()
cannot\ find\ and\ host\ to\ sync\ volume\ size\ in\ primary\:\ %s = cannot find and host to sync volume size in primary: {0}

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:2267
# args: 
image\ [%s]\ has\ been\ deleted,\ cannot\ reinit\ root\ volume\ from\ it = image [{0}] has been deleted, cannot reinit root volume from it

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:2422
# args: 
no\ available\ host\ could\ check\ mountPath! = no available host could check mountPath!

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:2649
# args: String.join(",", msg.getBackupStorageUuids()),errorCodes.getCauses().get(0).getDetails()
unable\ to\ allocate\ backup\ storage\ specified\ by\ uuids\:\ %s,\ becasue\:\ %s = unable to allocate backup storage specified by uuids: {0}, becasue: {1}

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:2817
# args: bsvo.getType()
aliyun\ nas\ primarystorage\ only\ support\ imagestore\ bs,\ actually\ get\ type\:\ %s = aliyun nas primarystorage only support imagestore bs, actually get type: {0}

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmFactory.java:158
# args: context.getInventory().getUuid(),context.getInventory().getName(),mine,e.getKey(),version,QCOW3_QEMU_IMG_VERSION,QCOW3_QEMU_IMG_VERSION
unable\ to\ attach\ a\ primary\ storage\ to\ cluster.\ Kvm\ host[uuid\:%s,\ name\:%s]\ in\ cluster\ has\ qemu-img\ with\ version[%s];\ but\ the\ primary\ storage\ has\ attached\ to\ a\ cluster\ that\ has\ kvm\ host[uuid\:%s],\ which\ has\ qemu-img\ with\ version[%s].\ qemu-img\ version\ greater\ than\ %s\ is\ incompatible\ with\ versions\ less\ than\ %s,\ this\ will\ causes\ volume\ snapshot\ operation\ to\ fail.\ Please\ avoid\ attaching\ a\ primary\ storage\ to\ clusters\ that\ have\ different\ Linux\ distributions,\ in\ order\ to\ prevent\ qemu-img\ version\ mismatch = unable to attach a primary storage to cluster. Kvm host[uuid:{0}, name:{1}] in cluster has qemu-img with version[{2}]; but the primary storage has attached to a cluster that has kvm host[uuid:{3}], which has qemu-img with version[{4}]. qemu-img version greater than {5} is incompatible with versions less than {6}, this will causes volume snapshot operation to fail. Please avoid attaching a primary storage to clusters that have different Linux distributions, in order to prevent qemu-img version mismatch

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmFactory.java:342
# args: 
no\ available\ host\ could\ download\ imagecache! = no available host could download imagecache!

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunNasPrimaryStorageBase.java:69
# args: self.getUuid(),self.getName()
the\ aliyun\ nas\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ any\ available\ host\ in\ attached\ clusters\ for\ instantiating\ the\ volume = the aliyun nas primary storage[uuid:{0}, name:{1}] cannot find any available host in attached clusters for instantiating the volume

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunNasPrimaryStorageBase.java:192
# args: self.getUuid(),self.getName()
the\ aliyun\ nas\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ any\ available\ host\ in\ attached\ clusters\ for\ delete\ bits\ on\ primarystorage = the aliyun nas primary storage[uuid:{0}, name:{1}] cannot find any available host in attached clusters for delete bits on primarystorage

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunNasPrimaryStorageBase.java:555
# args: self.getUuid(),self.getName()
the\ Aliyun\ Nas\ primary\ storage[uuid\:%s,\ name\:%s]\ has\ not\ attached\ to\ any\ clusters,\ or\ no\ hosts\ in\ the\ attached\ clusters\ are\ connected = the Aliyun Nas primary storage[uuid:{0}, name:{1}] has not attached to any clusters, or no hosts in the attached clusters are connected

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunNasPrimaryStorageBase.java:856
# args: hostUuid
failed\ to\ check\ mount\ path\ on\ host\:\ %s = failed to check mount path on host: {0}

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunNasPrimaryStorageBase.java:943
# args: 
cannot\ find\ a\ host\ to\ cleanup\ image\ cache. = cannot find a host to cleanup image cache.

# at: src/main/java/org/zstack/aliyun/network/AliyunNetworkServiceBase.java:533
# args: eipVo.getAllocateResourceUuid()
ecs\ instance[%s]\ isn't\ existed,\ please\ check\ it. = ecs instance[{0}] isn't existed, please check it.

# at: src/main/java/org/zstack/aliyun/network/AliyunNetworkServiceBase.java:537
# args: ecsVo.getUuid(),ecsVo.getEcsStatus()
Only\ ecs\ instances\ that\ are\ in\ the\ running\ and\ stopped\ status\ can\ detach\ the\ eip\ ,\ but\ the\ ecs\ [%s]\ status\ is\ [%s]\ now\  = Only ecs instances that are in the running and stopped status can detach the eip , but the ecs [{0}] status is [{1}] now 

# at: src/main/java/org/zstack/aliyun/network/AliyunNetworkServiceBase.java:2860
# args: msg.getUuid()
virtual\ border\:\ %s\ has\ been\ deleted = virtual border: {0} has been deleted

# at: src/main/java/org/zstack/aliyun/network/AliyunNetworkServiceBase.java:3389
# args: tupleCidr,msg.getNextHopUuid()
destination\ cidr\ [%s]\ is\ existed\ and\ point\ to\ another\ instance-id\ [%s],\ please\ check\ or\ delete\ it\ first = destination cidr [{0}] is existed and point to another instance-id [{1}], please check or delete it first

# at: src/main/java/org/zstack/aliyun/network/AliyunNetworkServiceBase.java:3902
# args: evo.getUuid(),evo.getEcsStatus()
Only\ esc\ instances\ that\ are\ in\ the\ running\ and\ stopped\ status\ can\ attach\ the\ eip\ ,\ but\ the\ ecs\ [%s]\ status\ is\ [%s]\ now\  = Only esc instances that are in the running and stopped status can attach the eip , but the ecs [{0}] status is [{1}] now 

# at: src/main/java/org/zstack/aliyun/network/connection/AliyunConnectionManagerImpl.java:585
# args: msg.getVbrUuid()
Vbr\:\ [%s]\ is\ in\ create\ connection\ progress,\ please\ wait... = Vbr: [{0}] is in create connection progress, please wait...

# at: src/main/java/org/zstack/aliyun/network/connection/CreateVbrRouteEntryFlow.java:80
# args: tuple.get(0, String.class),msg.getVbrUuid(),vpcCidr
custom\ cidr\ [%s]\ is\ already\ existed\ in\ vbr\ [%s],\ it\ is\ overlapped\ with\ target\ cidr\ [%s],\ please\ check\ and\ delete\ it\ first. = custom cidr [{0}] is already existed in vbr [{1}], it is overlapped with target cidr [{2}], please check and delete it first.

# at: src/main/java/org/zstack/aliyun/network/connection/CreateVpcRouteEntryFlow.java:71
# args: tuple.get(0, String.class),vRouterUuid,cidr
custom\ cidr\ [%s]\ is\ already\ existed\ in\ vrouter\ [%s],\ it\ is\ overlapped\ with\ target\ cidr\ [%s],\ please\ check\ and\ delete\ it\ first. = custom cidr [{0}] is already existed in vrouter [{1}], it is overlapped with target cidr [{2}], please check and delete it first.

# at: src/main/java/org/zstack/aliyun/network/connection/GetCidrsFlow.java:50
# args: msg.getL3networkUuid()
No\ Such\ Cidr\ found\ for\ l3network\:\ %s = No Such Cidr found for l3network: {0}

# at: src/main/java/org/zstack/aliyun/network/connection/GetCidrsFlow.java:40
# args: msg.getL3networkUuid()
No\ Such\ VRouter\ nic\ found\ for\ l3network\:\ %s = No Such VRouter nic found for l3network: {0}

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:43
# args: msg.getUuid()
no\ such\ vpc\ found\ for\:\ %s = no such vpc found for: {0}

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:48
# args: msg.getUuid()
no\ such\ vm\ found\ for\:\ %s = no such vm found for: {0}

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:53
# args: msg.getUuid()
no\ such\ vbr\ found\ for\:\ %s = no such vbr found for: {0}

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:58
# args: msg.getUuid()
no\ such\ l3network\ found\ for\:\ %s = no such l3network found for: {0}

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:62
# args: msg.getResourceType()
not\ a\ supported\ resource\ type\:\ %s = not a supported resource type: {0}

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:68
# args: 
Only\ admin\ can\ create\ connections = Only admin can create connections

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:72
# args: msg.getCpeIp()
CpeIp\ must\ be\ ipv4\ address,\ but\ now\ is\ %s = CpeIp must be ipv4 address, but now is {0}

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:76
# args: 
cpeIp\ must\ be\ ipv4\ address = cpeIp must be ipv4 address

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:82
# args: msg.getL3networkUuid(),msg.getVpcUuid()
l3network\ %s\ and\ vpc\ %s\ already\ connected,\ please\ check\ it = l3network {0} and vpc {1} already connected, please check it

# at: src/main/java/org/zstack/aliyun/network/vpn/AliyunVpcVpnBase.java:955
# args: 
vpn\ gateway\ and\ user\ gateway\ are\ not\ in\ the\ same\ dataCenterUuid! = vpn gateway and user gateway are not in the same dataCenterUuid!

# at: src/main/java/org/zstack/aliyun/oss/EcsOssApiInterceptor.java:33
# args: msg.getBucketName(),msg.getDataCenterUuid()
ossBucket\ [%s]\ is\ already\ added\ in\ dataCenter\ [%s] = ossBucket [{0}] is already added in dataCenter [{1}]

# at: src/main/java/org/zstack/aliyun/oss/EcsOssApiInterceptor.java:41
# args: ovo.getUuid()
OssBucket[%s]\ is\ not\ attached. = OssBucket[{0}] is not attached.

# at: src/main/java/org/zstack/aliyun/oss/EcsOssManagerImpl.java:114
# args: 
domain,\ key,\ secret\ must\ be\ set\ all = domain, key, secret must be set all

# at: src/main/java/org/zstack/aliyun/oss/OssBucketCascadeExtension.java:106
# args: 
oss\ bucket\ is\ not\ empty! = oss bucket is not empty!

# at: src/main/java/org/zstack/aliyun/pangu/AliyunPanguApiInterceptor.java:39
# args: appName,partitionName,vo.getIdentityZoneUuid()
appName\:\ %s,\ partitionName\:\ %s\ is\ existed\ in\ identityZone\:\ %s = appName: {0}, partitionName: {1} is existed in identityZone: {2}

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:62
# args: 
Root\ volume\ cannot\ be\ deleted = Root volume cannot be deleted

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:83
# args: 
Cannot\ set\ the\ disk's\ deleteWithInstance\ property\ to\ false\ when\ the\ category\ property\ of\ the\ disk\ is\ cloud\ and\ portable\ property\ is\ false = Cannot set the disk's deleteWithInstance property to false when the category property of the disk is cloud and portable property is false

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:78
# args: 
Cannot\ set\ the\ disk's\ deleteWithInstance\ property\ to\ false\ when\ the\ category\ property\ of\ the\ disk\ is\ ephemeral = Cannot set the disk's deleteWithInstance property to false when the category property of the disk is ephemeral

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:95
# args: msg.getUuid()
The\ disk\ [%s]\ is\ not\ attach\ on\ any\ instance\  = The disk [{0}] is not attach on any instance 

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:121
# args: msg.getEcsUuid()
The\ state\ of\ the\ ecs\ [%s]\ instance\ must\ be\ running\ or\ stopped = The state of the ecs [{0}] instance must be running or stopped

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:105
# args: 
Only\ data\ disk\ can\ be\ mounted\ on\ ecs = Only data disk can be mounted on ecs

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:109
# args: 
The\ disk\ not\ be\ attach\ on\ any\ ecs = The disk not be attach on any ecs

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:143
# args: 
Non-independent\ disk\ can\ only\ be\ destroyed\ with\ instances = Non-independent disk can only be destroyed with instances

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:126
# args: 
Disk\ and\ ecs\ instances\ must\ be\ in\ the\ same\ zone = Disk and ecs instances must be in the same zone

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:130
# args: msg.getDiskUuid(),msg.getEcsUuid()
The\ disk\ [%s]\ is\ already\ mounted\ on\ the\ instance\ [%s] = The disk [{0}] is already mounted on the instance [{1}]

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:135
# args: 
Only\ data\ disk\ can\ attach\ to\ ecs = Only data disk can attach to ecs

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:139
# args: 
Cannot\ attach\ disk\ when\ in\ use = Cannot attach disk when in use

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:154
# args: 
The\ size\ and\ snapshot\ id\ in\ the\ request\ parameter\ must\ select\ one\ of\ the\ items\ to\ specify\ the\ size\ of\ the\ disk\ or\ create\ a\ disk\ using\ the\ snapshot. = The size and snapshot id in the request parameter must select one of the items to specify the size of the disk or create a disk using the snapshot.

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:167
# args: 
Not\ allowed\ create\ disk\ on\ root\ volume\ snapshot = Not allowed create disk on root volume snapshot

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:176
# args: 
the\ disk\ name\ or\ description\ cannot\ set\ start\ with\ 'http\://'\ or\ 'https\://'\  = the disk name or description cannot set start with 'http://' or 'https://' 

# at: src/main/java/org/zstack/aliyun/storage/snapshot/AliyunSnapshotApiInterceptor.java:41
# args: 
The\ operation\ allows\ only\ when\ ecs\ state\ of\ the\ ecs\ instance\ status\ be\ running\ or\ stopped = The operation allows only when ecs state of the ecs instance status be running or stopped

# at: src/main/java/org/zstack/apimediator/ApiValidator.java:60
# args: hostname,newBS
More\ than\ one\ BackupStorage\ on\ the\ same\ host\ identified\ by\ hostname.\ There\ has\ been\ a\ SftpBackupStorage\ [hostname\:%s]\ existing.\ The\ BackupStorage\ type\ to\ be\ added\ is\ %s.\  = More than one BackupStorage on the same host identified by hostname. There has been a SftpBackupStorage [hostname:{0}] existing. The BackupStorage type to be added is {1}. 

# at: src/main/java/org/zstack/apimediator/ApiValidator.java:68
# args: hostname,newBS
More\ than\ one\ BackupStorage\ on\ the\ same\ host\ identified\ by\ hostname.\ There\ has\ been\ an\ ImageStoreBackupStorage\ [hostname\:%s]\ existing.\ The\ BackupStorage\ type\ to\ be\ added\ is\ %s.\  = More than one BackupStorage on the same host identified by hostname. There has been an ImageStoreBackupStorage [hostname:{0}] existing. The BackupStorage type to be added is {1}. 

# at: src/main/java/org/zstack/appliancevm/ApplianceVmBase.java:129
# args: self.getUuid(),getSelf().getStatus(),msg.getPath()
appliance\ vm[uuid\:%s]\ is\ in\ status\ of\ %s\ that\ cannot\ make\ http\ call\ to\ %s = appliance vm[uuid:{0}] is in status of {1} that cannot make http call to {2}

# at: src/main/java/org/zstack/appliancevm/ApplianceVmBase.java:413
# args: getSelf().getUuid()
appliance\ vm\ %s\ stopped = appliance vm {0} stopped

# at: src/main/java/org/zstack/appliancevm/ApplianceVmBase.java:482
# args: getSelf().getUuid()
appliance\ vm\ %s\ destroyed = appliance vm {0} destroyed

# at: src/main/java/org/zstack/appliancevm/ApplianceVmBase.java:543
# args: getSelf().getUuid()
appliance\ vm\ %s\ reboot = appliance vm {0} reboot

# at: src/main/java/org/zstack/appliancevm/ApplianceVmBase.java:553
# args: getSelf().getUuid()
appliance\ vm\ %s\ reboot\ failed = appliance vm {0} reboot failed

# at: src/main/java/org/zstack/appliancevm/ApplianceVmBase.java:606
# args: getSelf().getUuid()
appliance\ vm\ %s\ start\ failed = appliance vm {0} start failed

# at: src/main/java/org/zstack/autoscaling/AutoScalingInterceptor.java:116
# args: msg.getUuid(),uuid
listener[uuid\:%s]\ are\ being\ used\ by\ the\ autoScalingVmTemplate[%s]\ and\ cannot\ be\ deleted = listener[uuid:{0}] are being used by the autoScalingVmTemplate[{1}] and cannot be deleted

# at: src/main/java/org/zstack/autoscaling/AutoScalingInterceptor.java:148
# args: msg.getAlarmUuid(),ruleVO.getScalingGroupUuid()
alarm[uuid\:%s]\ are\ being\ used\ by\ the\ autoScalingGroup[%s]\ which\ cannot\ be\ deleted = alarm[uuid:{0}] are being used by the autoScalingGroup[{1}] which cannot be deleted

# at: src/main/java/org/zstack/autoscaling/AutoScalingInterceptor.java:158
# args: msg.getUuid()
rule[%s]\ state\ is\ Disabled = rule[{0}] state is Disabled

# at: src/main/java/org/zstack/autoscaling/AutoScalingManagerImpl.java:314
# args: l3Uuids,uuid
invalid\ l3\ network\ uuids[%s]\ for\ listener\ that\ belongs\ lb[%s],\ all\ the\ networks\ must\ be\ attached\ the\ LB\ service\ and\ be\ attached\ with\ the\ same\ vRouter\ with\ LB = invalid l3 network uuids[{0}] for listener that belongs lb[{1}], all the networks must be attached the LB service and be attached with the same vRouter with LB

# at: src/main/java/org/zstack/autoscaling/AutoScalingManagerImpl.java:626
# args: msg.getTemplateUuid(),JSONObjectUtil.toJsonString(errors)
detach\ autoScalingTemplate[%s]\ from\ AutoScalingGroup\ failed,\ errors\ are\ %s = detach autoScalingTemplate[{0}] from AutoScalingGroup failed, errors are {1}

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:933
# args: 
rootDiskOfferingUuid\ cannot\ be\ null\ when\ image\ mediaType\ is\ ISO = rootDiskOfferingUuid cannot be null when image mediaType is ISO

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:913
# args: instanceOfferingVO.getUuid()
instance\ offering[uuid\:%s]\ is\ Disabled,\ can't\ create\ vm\ from\ it = instance offering[uuid:{0}] is Disabled, can't create vm from it

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:916
# args: instanceOfferingVO.getUuid(),instanceOfferingVO.getType()
instance\ offering[uuid\:%s,\ type\:%s]\ is\ not\ UserVm\ type,\ can't\ create\ vm\ from\ it = instance offering[uuid:{0}, type:{1}] is not UserVm type, can't create vm from it

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:924
# args: imageVO.getUuid()
image[uuid\:%s]\ is\ Disabled,\ can't\ create\ vm\ from\ it = image[uuid:{0}] is Disabled, can't create vm from it

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:927
# args: imageVO.getUuid()
image[uuid\:%s]\ is\ not\ ready\ yet,\ can't\ create\ vm\ from\ it = image[uuid:{0}] is not ready yet, can't create vm from it

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:930
# args: imageVO.getUuid(),imageVO.getMediaType()
image[uuid\:%s]\ is\ of\ mediaType\:\ %s,\ only\ RootVolumeTemplate\ and\ ISO\ can\ be\ used\ to\ create\ vm = image[uuid:{0}] is of mediaType: {1}, only RootVolumeTemplate and ISO can be used to create vm

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:937
# args: imageVO.getUuid()
image[uuid\:%s]\ is\ system\ image,\ can't\ be\ used\ to\ create\ user\ vm = image[uuid:{0}] is system image, can't be used to create user vm

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:949
# args: diskOfferingVO.getUuid()
disk\ offerings[uuids\:%s]\ are\ Disabled,\ can\ not\ create\ vm\ from\ it = disk offerings[uuids:{0}] are Disabled, can not create vm from it

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:963
# args: l3Uuid
l3Network[uuid\:%s]\ is\ Disabled,\ can\ not\ create\ vm\ on\ it = l3Network[uuid:{0}] is Disabled, can not create vm on it

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:966
# args: l3Uuid
l3Network[uuid\:%s]\ is\ system\ network,\ can\ not\ create\ user\ vm\ on\ it = l3Network[uuid:{0}] is system network, can not create user vm on it

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:970
# args: 
there\ are\ more\ than\ one\ L3\ network\ specified\ in\ l3NetworkUuids,\ but\ defaultL3NetworkUuid\ is\ null = there are more than one L3 network specified in l3NetworkUuids, but defaultL3NetworkUuid is null

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:409
# args: 
Only\ one\ scaling\ activity\ can\ be\ executed\ in\ the\ same\ scaling\ group\ at\ the\ same\ time. = Only one scaling activity can be executed in the same scaling group at the same time.

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:1330
# args: 
The\ number\ of\ instances\ exceeds\ the\ limit = The number of instances exceeds the limit

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:637
# args: msg.getAutoScalingGroupUuid(),JSONObjectUtil.toJsonString(errors)
autoScalingGroup[%s]\ create\ vms\ failed\ completely,\ errors\ are\ %s = autoScalingGroup[{0}] create vms failed completely, errors are {1}

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:685
# args: loadBalancerListenerUuidListStr
add\ vm\ nic\ to\ loadBalancer\ failed,\ No\ loadBalancer[uuids\=%s]\ can\ be\ found. = add vm nic to loadBalancer failed, No loadBalancer[uuids={0}] can be found.

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:724
# args: msg.getAutoScalingGroupUuid(),JSONObjectUtil.toJsonString(addVmNicToLoadBalancerErrorCodes)
autoScalingGroup[%s]\ add\ newly\ created\ vm\ to\ loadBalancer\ failed\ completely,\ errors\ are\ %s = autoScalingGroup[{0}] add newly created vm to loadBalancer failed completely, errors are {1}

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:759
# args: securityGroupUuid
add\ vm\ nic\ to\ securityGroup\ failed,\ No\ securityGroup[uuid\=%s]\ can\ be\ found. = add vm nic to securityGroup failed, No securityGroup[uuid={0}] can be found.

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:795
# args: msg.getAutoScalingGroupUuid(),JSONObjectUtil.toJsonString(addVmNicToSecurityGroupErrorCodes)
autoScalingGroup[%s]\ add\ newly\ created\ vm\ to\ securityGroup\ failed\ completely,\ errors\ are\ %s = autoScalingGroup[{0}] add newly created vm to securityGroup failed completely, errors are {1}

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:905
# args: templateGroupRefVO.getTemplateUuid()
A\ resource\ can\ not\ be\ found,\ details\:\ resource[uuid\:%s,\ type\:AutoScalingVmTemplateVO]\ not\ found = A resource can not be found, details: resource[uuid:{0}, type:AutoScalingVmTemplateVO] not found

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:910
# args: vmTemplateVO.getVmInstanceOfferingUuid()
A\ resource\ can\ not\ be\ found,\ details\:\ resource[uuid\:%s,\ type\:InstanceOfferingVO]\ not\ found = A resource can not be found, details: resource[uuid:{0}, type:InstanceOfferingVO] not found

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:921
# args: vmTemplateVO.getImageUuid()
A\ resource\ can\ not\ be\ found,\ details\:\ resource[uuid\:%s,\ type\:ImageVO]\ not\ found = A resource can not be found, details: resource[uuid:{0}, type:ImageVO] not found

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:945
# args: diskOfferingVO.getUuid()
A\ resource\ can\ not\ be\ found,\ details\:\ resource[uuid\:%s,\ type\:DiskOfferingVO]\ not\ found = A resource can not be found, details: resource[uuid:{0}, type:DiskOfferingVO] not found

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:958
# args: l3Uuid
A\ resource\ can\ not\ be\ found,\ details\:\ resource[uuid\:%s,\ type\:L3NetworkVO]\ not\ found = A resource can not be found, details: resource[uuid:{0}, type:L3NetworkVO] not found

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:974
# args: vmTemplateVO.getDefaultL3NetworkUuid(),l3Uuids
defaultL3NetworkUuid[uuid\:%s]\ is\ not\ in\ l3NetworkUuids\ %s = defaultL3NetworkUuid[uuid:{0}] is not in l3NetworkUuids {1}

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:1047
# args: self.getUuid(),AutoScalingGroupState.Enabled.toString()
the\ auto\ scaling\ group[%s]\ state\ error,\ expected\:\ %s\ state = the auto scaling group[{0}] state error, expected: {1} state

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:1084
# args: self.getUuid()
The\ autoScalingGroup[%s]\ not\ attach\ any\ vm\ template = The autoScalingGroup[{0}] not attach any vm template

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:1138
# args: self.getUuid(),vmInstanceUuids,JSONObjectUtil.toJsonString(errors)
autoScalingGroup[%s]\ destroy\ vms[%s]\ failed\ completely,\ errors\ are\ %s = autoScalingGroup[{0}] destroy vms[{1}] failed completely, errors are {2}

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:1343
# args: 
Cannot\ find\ deleted\ target\ instance\ list = Cannot find deleted target instance list

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:1569
# args: 
need\ skip\ autoScalingGroup\ activity = need skip autoScalingGroup activity

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:1820
# args: ruleUuid,JSONObjectUtil.toJsonString(errors)
delete\ autoScalingRule[%s]\ triggers\ failed,\ errors\ are\ %s = delete autoScalingRule[{0}] triggers failed, errors are {1}

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:2437
# args: removalPolicy.toString()
Unsupported\ RemovalPolicy[%s]\ type = Unsupported RemovalPolicy[{0}] type

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisApiInterceptor.java:63
# args: address
IPMI\ Address\ %s\ is\ not\ valid = IPMI Address {0} is not valid

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisApiInterceptor.java:69
# args: 
Failed\ to\ reach\ the\ bare-metal\ chassis,\ please\ make\ sure\:\ 1.\ the\ IPMI\ connection\ is\ active;\ 2.\ the\ IPMI\ Address,\ Port,\ Username\ and\ Password\ are\ correct;\ 3.\ IPMI\ Over\ LAN\ is\ enabled\ in\ BIOS. = Failed to reach the bare-metal chassis, please make sure: 1. the IPMI connection is active; 2. the IPMI Address, Port, Username and Password are correct; 3. IPMI Over LAN is enabled in BIOS.

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisApiInterceptor.java:84
# args: address,port
Baremetal\ Chassis\ of\ IPMI\ address\ %s\ and\ IPMI\ port\ %d\ has\ already\ been\ created. = Baremetal Chassis of IPMI address {0} and IPMI port {1} has already been created.

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisApiInterceptor.java:95
# args: msg.getClusterUuid()
Cluster[uuid\:%s]\ does\ not\ exists. = Cluster[uuid:{0}] does not exists.

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisApiInterceptor.java:102
# args: msg.getClusterUuid()
Cluster[uuid\:%s]\ is\ not\ a\ baremetal\ cluster. = Cluster[uuid:{0}] is not a baremetal cluster.

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisApiInterceptor.java:108
# args: msg.getClusterUuid()
Cluster[uuid\:%s]\ is\ not\ Enabled. = Cluster[uuid:{0}] is not Enabled.

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisApiInterceptor.java:146
# args: address,port
IPMI\ Address\ and\ Port\ %s\:%d\ already\ exists. = IPMI Address and Port {0}:{1} already exists.

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisApiInterceptor.java:211
# args: clusterUuid
no\ usable\ baremetal\ pxeserver\ attached\ to\ cluster[uuid\:%s] = no usable baremetal pxeserver attached to cluster[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisManagerImpl.java:153
# args: chassis.getUuid(),chassis.getPxeServerUuid(),cmd.content
baremetal\ chassis[uuid\:%s]\ is\ supposed\ to\ using\ pxeserver[uuid\:%s],\ but\ it\ was\ pxeserver[uuid\:%s]\ that\ actually\ handled\ the\ DHCP\ request = baremetal chassis[uuid:{0}] is supposed to using pxeserver[uuid:{1}], but it was pxeserver[uuid:{2}] that actually handled the DHCP request

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisManagerImpl.java:639
# args: msg.getUuid()
failed\ to\ delete\ baremetal\ chassis\ %s = failed to delete baremetal chassis {0}

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisManagerImpl.java:706
# args: bmc.getUuid()
Failed\ to\ remotely\ power\ on\ baremetal\ chassis[uuid\:%s] = Failed to remotely power on baremetal chassis[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisManagerImpl.java:722
# args: bmc.getUuid()
Failed\ to\ remotely\ power\ reset\ baremetal\ chassis[uuid\:%s] = Failed to remotely power reset baremetal chassis[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisManagerImpl.java:733
# args: bmc.getUuid()
Failed\ to\ remotely\ pxe\ boot\ chassis[uuid\:%s] = Failed to remotely pxe boot chassis[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisManagerImpl.java:901
# args: bmc.getUuid()
failed\ to\ connect\ to\ chassis\ [uuid\:%s],\ please\ check\ ipmi\ connection. = failed to connect to chassis [uuid:{0}], please check ipmi connection.

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisManagerImpl.java:987
# args: e.getMessage()
fail\ to\ load\ chassis\ info\ from\ file,\ because\:\ %s = fail to load chassis info from file, because: {0}

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:66
# args: msg.getChassisUuid()
Baremetal\ chassis[uuid\:%s]\ does\ not\ exist = Baremetal chassis[uuid:{0}] does not exist

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:72
# args: chassis.getUuid()
Baremetal\ chassis[uuid\:%s]\ is\ not\ Enabled\ or\ Available,\ please\ choose\ another\ one. = Baremetal chassis[uuid:{0}] is not Enabled or Available, please choose another one.

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:78
# args: chassis.getUuid()
no\ corresponding\ pxeserver,\ please\ inspect\ baremetal\ chassis[uuid\:%s]\ again = no corresponding pxeserver, please inspect baremetal chassis[uuid:{0}] again

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:91
# args: chassis.getUuid()
No\ hardware\ info\ found\ for\ baremetal\ chassis[uuid\:%s],\ please\ choose\ another\ one. = No hardware info found for baremetal chassis[uuid:{0}], please choose another one.

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:102
# args: chassis.getPxeServerUuid()
baremetal\ pxeserver[uuid\:%s]\ is\ neither\ Enabled\ nor\ Connected,\ please\ check = baremetal pxeserver[uuid:{0}] is neither Enabled nor Connected, please check

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:119
# args: mac
Mac\ address\ %s\ is\ invalid.\ It\ should\ be\ like\ 6c\:b3\:11\:1b\:0b\:1e = Mac address {0} is invalid. It should be like 6c:b3:11:1b:0b:1e

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:125
# args: chassis.getUuid(),mac
Baremetal\ chassis[uuid\:%s]\ doesn't\ have\ nic\ with\ mac\ address\ %s = Baremetal chassis[uuid:{0}] doesn't have nic with mac address {1}

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:143
# args: 
duplicated\ bm\ bonding\ uuid\ detacted = duplicated bm bonding uuid detacted

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:147
# args: 
Baremetal\ Bonding\ does\ not\ exist = Baremetal Bonding does not exist

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:155
# args: 
duplicated\ l3\ network\ uuid\ detacted = duplicated l3 network uuid detacted

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:159
# args: 
the\ selected\ l3\ network\ doesn't\ exist = the selected l3 network doesn't exist

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:172
# args: chassis.getUuid()
the\ selected\ l3\ network\ cannot\ be\ assigned\ to\ chassis[uuid\:%s] = the selected l3 network cannot be assigned to chassis[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:184
# args: 
only\ iso\ image\ is\ supported\ in\ zstack\ baremetal\ service = only iso image is supported in zstack baremetal service

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:193
# args: 
only\ ImageStoreBackupStorage\ is\ supported\ in\ zstack\ baremetal\ service = only ImageStoreBackupStorage is supported in zstack baremetal service

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:207
# args: 
cannot\ recover\ baremetal\ instance\ that's\ not\ in\ Destroyed\ state = cannot recover baremetal instance that's not in Destroyed state

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:219
# args: 
cannot\ expunge\ baremetal\ instance\ that's\ not\ in\ Destroyed\ state = cannot expunge baremetal instance that's not in Destroyed state

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceBase.java:461
# args: bmc.getUuid()
Failed\ to\ remotely\ power\ off\ baremetal\ chassis[uuid\:%s] = Failed to remotely power off baremetal chassis[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceBase.java:266
# args: self.getClusterUuid()
failed\ to\ allocate\ baremetal\ pxeserver,\ make\ sure\ there\ is\ a\ pxeserver\ with\ enough\ available\ capacity\ attached\ on\ cluster[uuid\:%s] = failed to allocate baremetal pxeserver, make sure there is a pxeserver with enough available capacity attached on cluster[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceBase.java:453
# args: reboot ? "reset" : "on",bmc.getUuid()
Failed\ to\ remotely\ power\ %s\ baremetal\ chassis[uuid\:%s] = Failed to remotely power {0} baremetal chassis[uuid:{1}]

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceManagerImpl.java:1141
# args: msg.getL2NetworkUuid()
there\ are\ bm\ instances\ using\ ip\ address\ allocated\ from\ l2[uuid\:%s] = there are bm instances using ip address allocated from l2[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceManagerImpl.java:1149
# args: msg.getL3NetworkUuid()
there\ are\ bm\ instances\ using\ ip\ address\ allocated\ from\ l3[uuid\:%s] = there are bm instances using ip address allocated from l3[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceManagerImpl.java:1169
# args: msg.getIpRangeUuid()
there\ are\ bm\ instances\ using\ ip\ address\ allocated\ from\ ip\ range[uuid\:%s] = there are bm instances using ip address allocated from ip range[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/network/BaremetalNetworkApiInterceptor.java:39
# args: 
creating\ bm\ bonding\ is\ only\ allowed\ before\ creating\ bm\ instance = creating bm bonding is only allowed before creating bm instance

# at: src/main/java/org/zstack/baremetal/network/BaremetalNetworkApiInterceptor.java:48
# args: msg.getName()
bond\ name\ %s\ already\ exists = bond name {0} already exists

# at: src/main/java/org/zstack/baremetal/network/BaremetalNetworkApiInterceptor.java:73
# args: slave
Slave\ address\ %s\ is\ invalid.\ It\ should\ be\ like\ 6c\:b3\:11\:1b\:0b\:1e,6c\:b3\:11\:1b\:0b\:1f = Slave address {0} is invalid. It should be like 6c:b3:11:1b:0b:1e,6c:b3:11:1b:0b:1f

# at: src/main/java/org/zstack/baremetal/network/BaremetalNetworkApiInterceptor.java:79
# args: slave,msg.getChassisUuid()
mac\ address\ %s\ does\ not\ belong\ to\ chassis[uuid\:%s] = mac address {0} does not belong to chassis[uuid:{1}]

# at: src/main/java/org/zstack/baremetal/network/BaremetalNetworkApiInterceptor.java:85
# args: slave
mac\ address\ %s\ is\ already\ a\ bond\ slave = mac address {0} is already a bond slave

# at: src/main/java/org/zstack/baremetal/preconfiguration/PreconfigurationApiInterceptor.java:43
# args: 
cannot\ update\ predefined\ preconfiguration\ templates = cannot update predefined preconfiguration templates

# at: src/main/java/org/zstack/baremetal/preconfiguration/PreconfigurationApiInterceptor.java:55
# args: 
cannot\ delete\ predefined\ preconfiguration\ templates = cannot delete predefined preconfiguration templates

# at: src/main/java/org/zstack/baremetal/preconfiguration/PreconfigurationApiInterceptor.java:63
# args: 
cannot\ change\ state\ of\ predefined\ preconfiguration\ templates = cannot change state of predefined preconfiguration templates

# at: src/main/java/org/zstack/baremetal/preconfiguration/PreconfigurationManagerImpl.java:65
# args: msg.getTemplateUuid()
cannot\ find\ PreconfigurationTemplateVO[uuid\:%s],\ it\ may\ have\ been\ deleted = cannot find PreconfigurationTemplateVO[uuid:{0}], it may have been deleted

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:44
# args: msg.getClass().getSimpleName()
%s\ can\ only\ be\ called\ by\ admin\ account = {0} can only be called by admin account

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:74
# args: netmask
PXE\ Server\ DHCP\ Range\ Netmask\ %s\ is\ invalid. = PXE Server DHCP Range Netmask {0} is invalid.

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:80
# args: begin,end
PXE\ Server\ DHCP\ Range\ Start\ %s\ and\ Range\ Stop\ %s\ do\ not\ belong\ to\ the\ same\ subnet. = PXE Server DHCP Range Start {0} and Range Stop {1} do not belong to the same subnet.

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:88
# args: msg.getHostname()
PXE\ Server\ with\ hostname\ %s\ already\ exists. = PXE Server with hostname {0} already exists.

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:95
# args: 
storagePath\ should\ be\ an\ absolute\ path = storagePath should be an absolute path

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:113
# args: msg.getHostname()
failed\ to\ connect\ to\ %s,\ please\ check\ network\ connection\ between\ zstack\ management\ node\ and\ baremetal\ pxeserver = failed to connect to {0}, please check network connection between zstack management node and baremetal pxeserver

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:127
# args: msg.getHostname()
no\ local\ repo\ found\ under\ /opt/zstack-dvd\ of\ %s,\ please\ download\ zstack\ iso\ and\ create\ local\ repo\ first = no local repo found under /opt/zstack-dvd of {0}, please download zstack iso and create local repo first

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:141
# args: msg.getDhcpInterface()
PXE\ Server\ DHCP\ Interface\ %s\ does\ not\ exists,\ or\ it\ does\ not\ have\ an\ IP\ address. = PXE Server DHCP Interface {0} does not exists, or it does not have an IP address.

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:150
# args: msg.getDhcpRangeBegin(),msg.getDhcpRangeEnd(),msg.getDhcpInterface()
%s\ ~\ %s\ cannot\ connect\ to\ dhcp\ interface\ %s = {0} ~ {1} cannot connect to dhcp interface {2}

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:187
# args: msg.getClusterUuid(),msg.getPxeServerUuid()
cluster[uuid\:%s]\ and\ pxeserver[uuid\:%s]\ don't\ belong\ to\ one\ zone = cluster[uuid:{0}] and pxeserver[uuid:{1}] don't belong to one zone

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:196
# args: msg.getClusterUuid()
cluster[uuid\:%s]\ is\ not\ baremetal\ cluster = cluster[uuid:{0}] is not baremetal cluster

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:207
# args: msg.getPxeServerUuid(),msg.getClusterUuid()
baremetal\ pxeserver[uuid\:%s]\ already\ attached\ to\ cluster[uuid\:%s] = baremetal pxeserver[uuid:{0}] already attached to cluster[uuid:{1}]

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:233
# args: msg.getPxeServerUuid(),msg.getClusterUuid(),ip,begin,end
baremetal\ pxeserver[uuid\:%s]\ is\ not\ compatible\ with\ baremetal\ instances\ in\ cluster[uuid\:%s],\ existing\ nic\ ip\ %s\ is\ out\ of\ pxeserver\ dhcp\ range\ %s\ ~\ %s. = baremetal pxeserver[uuid:{0}] is not compatible with baremetal instances in cluster[uuid:{1}], existing nic ip {2} is out of pxeserver dhcp range {3} ~ {4}.

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:250
# args: msg.getPxeServerUuid(),msg.getClusterUuid()
baremetal\ pxeserver[uuid\:\ %s]\ not\ attached\ to\ cluster[uuid\:\ %s] = baremetal pxeserver[uuid: {0}] not attached to cluster[uuid: {1}]

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:286
# args: self.getUuid()
failed\ to\ init\ configs\ on\ baremetal\ pxeserver[uuid\:%s] = failed to init configs on baremetal pxeserver[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:423
# args: self.getUuid()
failed\ to\ create\ bm\ instance\ configs\ on\ baremetal\ pxeserver[uuid\:%s] = failed to create bm instance configs on baremetal pxeserver[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:454
# args: self.getUuid()
failed\ to\ delete\ bm\ instance\ configs\ on\ baremetal\ pxeserver[uuid\:%s] = failed to delete bm instance configs on baremetal pxeserver[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:485
# args: self.getUuid()
failed\ to\ create\ bm\ instance\ novnc\ proxy\ on\ baremetal\ pxeserver[uuid\:%s] = failed to create bm instance novnc proxy on baremetal pxeserver[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:516
# args: self.getUuid()
failed\ to\ delete\ bm\ instance\ novnc\ proxy\ on\ baremetal\ pxeserver[uuid\:%s] = failed to delete bm instance novnc proxy on baremetal pxeserver[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:549
# args: self.getUuid()
failed\ to\ create\ bm\ instance\ nginx\ proxy\ on\ baremetal\ pxeserver[uuid\:%s] = failed to create bm instance nginx proxy on baremetal pxeserver[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:580
# args: self.getUuid()
failed\ to\ delete\ bm\ instance\ nginx\ proxy\ on\ baremetal\ pxeserver[uuid\:%s] = failed to delete bm instance nginx proxy on baremetal pxeserver[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:611
# args: self.getUuid()
failed\ to\ start\ baremetal\ pxeserver[uuid\:%s] = failed to start baremetal pxeserver[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:644
# args: self.getUuid()
failed\ to\ stop\ baremetal\ pxeserver[uuid\:%s] = failed to stop baremetal pxeserver[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:959
# args: msg.getChassisUuid(),self.getUuid()
failed\ to\ create\ dhcp\ config\ of\ chassis[uuid\:%s]\ on\ pxeserver[uuid\:%s] = failed to create dhcp config of chassis[uuid:{0}] on pxeserver[uuid:{1}]

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:988
# args: msg.getChassisUuid(),self.getUuid()
failed\ to\ delete\ dhcp\ config\ of\ chassis[uuid\:%s]\ on\ pxeserver[uuid\:%s] = failed to delete dhcp config of chassis[uuid:{0}] on pxeserver[uuid:{1}]

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:1046
# args: self.getUuid(),ret.uuid
the\ uuid\ of\ baremtal\ pxeserver\ agent\ changed[expected\:%s,\ actual\:%s],\ it's\ most\ likely\ the\ agent\ was\ manually\ restarted.\ Issue\ a\ reconnect\ to\ sync\ the\ status = the uuid of baremtal pxeserver agent changed[expected:{0}, actual:{1}], it's most likely the agent was manually restarted. Issue a reconnect to sync the status

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:1229
# args: url,rsp.error
unable\ to\ connect\ to\ baremetal\ pxeserver[url\:%s],\ because\ %s = unable to connect to baremetal pxeserver[url:{0}], because {1}

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:1320
# args: cache.getImageUuid()
failed\ to\ mount\ baremetal\ cache\ of\ image[uuid\:%s] = failed to mount baremetal cache of image[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:1430
# args: msg.getImageUuid()
no\ enough\ space\ left\ in\ baremetal\ image\ cache\ for\ image[uuid\:%s] = no enough space left in baremetal image cache for image[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:1526
# args: 
unsupported\ backup\ storage\ type\ for\ baremetal = unsupported backup storage type for baremetal

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:104
# args: 
the\ start\ date\ must\ be\ greater\ than\ the\ end\ date = the start date must be greater than the end date

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:108
# args: 
resourceType\ and\ resourceUuid\ cannot\ be\ empty\ at\ the\ same\ time = resourceType and resourceUuid cannot be empty at the same time

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:226
# args: 
the\ minimal\ resource\ unit\ is\ megabyte,\ cannot\ be\ byte = the minimal resource unit is megabyte, cannot be byte

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:234
# args: 
price\ must\ be\ 0\ and\ 999999999.99 = price must be 0 and 999999999.99

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:241
# args: 
gpu\ price\ must\ be\ bound\ to\ gpu\ uuid\ empty = gpu price must be bound to gpu uuid empty

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:248
# args: price.getSystemTags()
gpu\ price\ must\ be\ bound\ to\ gpu\ uuid\ %s = gpu price must be bound to gpu uuid {0}

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:208
# args: resourceName
resourceName[%s]\ is\ invalid = resourceName[{0}] is invalid

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:260
# args: msg.getAccountUuid()
The\ account[uuid\=%s]\ has\ attach\ price\ table = The account[uuid={0}] has attach price table

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:266
# args: msg.getUuid()
This\ priceTable[uuid\=%s]\ is\ not\ allowed\ to\ delete = This priceTable[uuid={0}] is not allowed to delete

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:280
# args: 
accountUuid/tableUuid\ only\ one\ of\ them\ is\ allowed\ to\ be\ set = accountUuid/tableUuid only one of them is allowed to be set

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:286
# args: 
endDateInLong\ is\ not\ allowed\ to\ be\ negative = endDateInLong is not allowed to be negative

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:290
# args: 
endDateInLong\ and\ setEndDateInLongBaseOnCurrentTime\ are\ not\ allowed\ to\ set\ at\ the\ same\ time = endDateInLong and setEndDateInLongBaseOnCurrentTime are not allowed to set at the same time

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:303
# args: 
endDateInLong\ is\ set,\ no\ modification\ allowed = endDateInLong is set, no modification allowed

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:311
# args: 
endDateInLong\ cannot\ be\ earlier\ than\ dateInLong = endDateInLong cannot be earlier than dateInLong

# at: src/main/java/org/zstack/billing/BillingManagerImpl.java:254
# args: 
priceKeyName\ is\ null = priceKeyName is null

# at: src/main/java/org/zstack/billing/BillingManagerImpl.java:879
# args: currentPriceVO.getDateInLong()
dateInLong\ is\ less\ than\ %s = dateInLong is less than {0}

# at: src/main/java/org/zstack/billing/BillingManagerImpl.java:1281
# args: resourceUuid
Already\ have\ one\ userdata\ systemTag\ for\ instanceOffering[uuid\:\ %s]. = Already have one userdata systemTag for instanceOffering[uuid: {0}].

# at: src/main/java/org/zstack/billing/BillingManagerImpl.java:1346
# args: 
Shouldn't\ be\ more\ than\ one\ systemTag\ for\ one\ instanceOffering. = Shouldn't be more than one systemTag for one instanceOffering.

# at: src/main/java/org/zstack/billing/BillingManagerImpl.java:1323
# args: resourceUuid
Already\ have\ one\ userdata\ systemTag\ for\ diskOffering[uuid\:\ %s]. = Already have one userdata systemTag for diskOffering[uuid: {0}].

# at: src/main/java/org/zstack/billing/ResourceSpendingHelper.java:50
# args: resourceType
unsupported\ billing\ resource\ type\ [%s] = unsupported billing resource type [{0}]

# at: src/main/java/org/zstack/cloudformation/CloudFormationInterceptor.java:63
# args: msg.getUuid()
cannot\ find\ such\ ResourceStackVO\ by\ uuid\ [%s] = cannot find such ResourceStackVO by uuid [{0}]

# at: src/main/java/org/zstack/cloudformation/CloudFormationInterceptor.java:67
# args: validStatus
restart\ resource\ stack\ only\ support\ %s\ status! = restart resource stack only support {0} status!

# at: src/main/java/org/zstack/cloudformation/CloudFormationInterceptor.java:175
# args: 
templateContent\ and\ uuid\ mustn't\ both\ be\ empty\ or\ both\ be\ set! = templateContent and uuid mustn't both be empty or both be set!

# at: src/main/java/org/zstack/cloudformation/CloudFormationInterceptor.java:98
# args: validStatus
expect\ %s\ status! = expect {0} status!

# at: src/main/java/org/zstack/cloudformation/CloudFormationInterceptor.java:118
# args: 
templateContent\ and\ templateUuid\ mustn't\ both\ be\ empty! = templateContent and templateUuid mustn't both be empty!

# at: src/main/java/org/zstack/cloudformation/CloudFormationInterceptor.java:129
# args: 
templateContent\ and\ url\ mustn't\ both\ be\ empty\ or\ both\ be\ set! = templateContent and url mustn't both be empty or both be set!

# at: src/main/java/org/zstack/cloudformation/CloudFormationInterceptor.java:145
# args: 
only\ admin\ could\ enable/disable\ system\ StackTemplate = only admin could enable/disable system StackTemplate

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:856
# args: vo.getName()
cannot\ delete\ or\ update\ system\ template\:\ %s = cannot delete or update system template: {0}

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:385
# args: msg.getUuid()
ResourceStackVO\:\ [%s]\ has\ been\ deleted... = ResourceStackVO: [{0}] has been deleted...

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:415
# args: uuid
ResourceStackVO\ [%s]\ already\ been\ deleted! = ResourceStackVO [{0}] already been deleted!

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:641
# args: 
templateContent\ must\ be\ set! = templateContent must be set!

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:636
# args: template.getUuid()
template\ [%s]\ chosen\ is\ disabled = template [{0}] chosen is disabled

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:779
# args: p.getParamName(),p.getResourceType()
cannot\ find\ parameters\ for\ %s,\ which\ is\ %s\ type,\ please\ check\ parameters = cannot find parameters for {0}, which is {1} type, please check parameters

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:849
# args: 
StackTemplateVO\ has\ been\ deleted... = StackTemplateVO has been deleted...

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:872
# args: 
content\ must\ be\ set\ by\ templateContent\ or\ url! = content must be set by templateContent or url!

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:890
# args: 
get\ null\ content\ input = get null content input

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:897
# args: result.getTemplateVersion()
invalid\ cloudformation\ template\ version\:\ %s = invalid cloudformation template version: {0}

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:911
# args: msg.getUuid()
StackTemplateVO\:\ [%s]\ has\ been\ deleted... = StackTemplateVO: [{0}] has been deleted...

# at: src/main/java/org/zstack/cloudformation/CloudFormationUtils.java:20
# args: 
get\ null\ element\ in\ template\ content = get null element in template content

# at: src/main/java/org/zstack/cloudformation/CloudFormationUtils.java:24
# args: 
template\ must\ contain\ [ZStackTemplateFormatVersion] = template must contain [ZStackTemplateFormatVersion]

# at: src/main/java/org/zstack/cloudformation/CloudFormationUtils.java:27
# args: result.getTemplateVersion(),CloudFormationConstant.version
invalid\ ZStackTemplateFormatVersion\:\ %s,\ %s = invalid ZStackTemplateFormatVersion: {0}, {1}

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationCreator.java:156
# args: 
verb\ must\ contain\ '\:\:'! = verb must contain '::'!

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationCreator.java:197
# args: t[0],last.getClass().getName()
need\ List\ for\ resource\ [%s]\ output\ here,\ but\ got\ %s. = need List for resource [{0}] output here, but got {1}.

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationCreator.java:221
# args: value
invalid\ dynamic\ variables,\ which\ must\ contained\ ${\:\ %s = invalid dynamic variables, which must contained $'{: {0}'

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationCreator.java:283
# args: 
cannot\ find\ resource\ of\ properties\ set\ before! = cannot find resource of properties set before!

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationCreator.java:359
# args: 
Some\ actions\ are\ invalid = Some actions are invalid

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationDecoder.java:128
# args: e
Unable\ to\ create\ json\ template = Unable to create json template

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationDecoder.java:116
# args: jsonFile
cannot\ find\ such\ template\ file\:\ %s = cannot find such template file: {0}

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationDecoder.java:233
# args: 
no\ root\ element\ found,\ please\ check\ your\ cfn\ formation! = no root element found, please check your cfn formation!

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationDecoder.java:365
# args: e.getMessage()
Wrong\ json\ format,\ causes\:\ %s = Wrong json format, causes: {0}

# at: src/main/java/org/zstack/cloudformation/template/decoder/ConditionDecoder.java:59
# args: 
Mappings\ root\ body\ must\ be\ json\ object! = Mappings root body must be json object!

# at: src/main/java/org/zstack/cloudformation/template/decoder/ConditionDecoder.java:45
# args: 
Condition\ body\ cannot\ support\ json\ null\ or\ array! = Condition body cannot support json null or array!

# at: src/main/java/org/zstack/cloudformation/template/decoder/ConditionDecoder.java:41
# args: 
Only\ support\ ZStack\ Template\ Functions\ in\ 'Condition'\ field! = Only support ZStack Template Functions in 'Condition' field!

# at: src/main/java/org/zstack/cloudformation/template/decoder/ConditionDecoder.java:37
# args: 
Value\ must\ be\ boolean\ in\ 'Condition'\ field = Value must be boolean in 'Condition' field

# at: src/main/java/org/zstack/cloudformation/template/decoder/ConditionDecoder.java:30
# args: key,es.size()
Condition\ key\:\ %s\ only\ support\ 1\ element\ in\ the\ json\ object\ of\ value,\ but\ got\ %d\ elements! = Condition key: {0} only support 1 element in the json object of value, but got {1} elements!

# at: src/main/java/org/zstack/cloudformation/template/decoder/DecoderUtils.java:87
# args: msg
cannot\ find\ such\ msg\:\ %s\ for\ create = cannot find such msg: {0} for create

# at: src/main/java/org/zstack/cloudformation/template/decoder/MappingDecoder.java:56
# args: 
Mapping\ value\ body\ cannot\ support\ null! = Mapping value body cannot support null!

# at: src/main/java/org/zstack/cloudformation/template/decoder/MappingDecoder.java:54
# args: 
Mapping\ value\ body\ cannot\ support\ json\ array! = Mapping value body cannot support json array!

# at: src/main/java/org/zstack/cloudformation/template/decoder/MappingDecoder.java:66
# args: 
mappingName\ must\ be\ found\ in\ result,\ or\ it\ is\ invalid\ cfn\ json. = mappingName must be found in result, or it is invalid cfn json.

# at: src/main/java/org/zstack/cloudformation/template/decoder/OutputDecoder.java:83
# args: 
Mapping\ body\ cannot\ support\ json\ null! = Mapping body cannot support json null!

# at: src/main/java/org/zstack/cloudformation/template/decoder/OutputDecoder.java:81
# args: 
Mapping\ body\ cannot\ support\ non\ map\ value! = Mapping body cannot support non map value!

# at: src/main/java/org/zstack/cloudformation/template/decoder/OutputDecoder.java:70
# args: 
Description\ in\ Outputs\ must\ be\ String\ type! = Description in Outputs must be String type!

# at: src/main/java/org/zstack/cloudformation/template/decoder/ParameterDecoder.java:59
# args: 
paramName\ must\ be\ found\ in\ result,\ or\ it\ is\ invalid\ cfn\ json. = paramName must be found in result, or it is invalid cfn json.

# at: src/main/java/org/zstack/cloudformation/template/decoder/ParameterDecoder.java:129
# args: 
Parameters\ root\ body\ must\ be\ json\ object! = Parameters root body must be json object!

# at: src/main/java/org/zstack/cloudformation/template/decoder/ResourceDecoder.java:112
# args: 
resourceName\ must\ be\ found\ in\ result,\ or\ it\ is\ invalid\ cfn\ json. = resourceName must be found in result, or it is invalid cfn json.

# at: src/main/java/org/zstack/cloudformation/template/decoder/ResourceDecoder.java:123
# args: 
Parameters\ body\ cannot\ support\ null! = Parameters body cannot support null!

# at: src/main/java/org/zstack/cloudformation/template/decoder/ResourceDecoder.java:68
# args: 
Resource\ value\ body\ cannot\ support\ null! = Resource value body cannot support null!

# at: src/main/java/org/zstack/cloudformation/template/decoder/ResourceDecoder.java:48
# args: resource.getResourceName(),e.getKey(),resource.getResourceName()
Resource\ %s\ cannot\ depends\ on\ itself,\ please\ check\ %s\ in\ Resource\ [%s] = Resource {0} cannot depends on itself, please check {1} in Resource [{2}]

# at: src/main/java/org/zstack/cloudformation/template/decoder/ResourceDecoder.java:254
# args: 
Resource\ root\ body\ must\ be\ json\ object! = Resource root body must be json object!

# at: src/main/java/org/zstack/cloudformation/template/decoder/ResourceDecoder.java:216
# args: 
Resource\ Type\ must\ be\ String! = Resource Type must be String!

# at: src/main/java/org/zstack/cloudformation/template/function/IfTemplateFunction.java:42
# args: cond
cannot\ find\ condition[%s]\ in\ 'Conditions' = cannot find condition[{0}] in 'Conditions'

# at: src/main/java/org/zstack/cloudformation/template/function/OrTemplateFunction.java:42
# args: e.getAsString()
expect\ 'true',\ 'false'\ for\ the\ object,\ but\ got\ %s = expect 'true', 'false' for the object, but got {0}

# at: src/main/java/org/zstack/cloudformation/template/function/OrTemplateFunction.java:35
# args: keys,e.getAsString()
expect\ 'true',\ 'false'\ or\ an\ other\ Condition,\ current\ Conditions\ include\:\ %s,\ but\ got\ %s = expect 'true', 'false' or an other Condition, current Conditions include: {0}, but got {1}

# at: src/main/java/org/zstack/cloudformation/template/function/SelectTemplateFunction.java:83
# args: 
Fn\:\:Select\ out\ of\ range,\ please\ check\ your\ json\ file! = Fn::Select out of range, please check your json file!

# at: src/main/java/org/zstack/cloudformation/template/function/TemplateFunctionUtils.java:75
# args: e.getKey()
only\ functions\ can\ in\ Function,\ but\ found\ %s = only functions can in Function, but found {0}

# at: src/main/java/org/zstack/cloudformation/template/function/TemplateFunctionUtils.java:90
# args: 
element\ is\ null! = element is null!

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupBase.java:317
# args: resourceUuid,affinityGroupUuid
VM\ [uuid\:\ %s]\ has\ already\ been\ added\ to\ affinityGroup\ [uuid\:\ %s] = VM [uuid: {0}] has already been added to affinityGroup [uuid: {1}]

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupBase.java:334
# args: hostUuid,affinityGroupUuid
There\ are\ other\ VMs\ on\ this\ host\ [uuid\:\ %s]\ belonging\ to\ same\ affinityGroup\ [%s] = There are other VMs on this host [uuid: {0}] belonging to same affinityGroup [{1}]

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupBase.java:363
# args: self.getUuid(),host.getUuid(),vmUuid
affinityGroup\ [uuid\:%s]\ reserve\ host\ [uuid\:%s]\ for\ vm\ [uuid\:\ %s]\ failed = affinityGroup [uuid:{0}] reserve host [uuid:{1}] for vm [uuid: {2}] failed

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupBase.java:433
# args: inv.getResourceUuid(),self.getUuid()
vm\ [uuid\:%s]\ doesn't\ satisfy\ the\ affinityGroup\ [uuid\:%s] = vm [uuid:{0}] doesn't satisfy the affinityGroup [uuid:{1}]

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupFilterFlow.java:136
# args: 
can\ not\ satisfied\ affinity\ group\ conditions = can not satisfied affinity group conditions

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupInterceptor.java:42
# args: VmInstanceState.Running.toString(),VmInstanceState.Stopped.toString(),state.toString()
Vm\ can\ change\ its\ affinityGroup\ only\ in\ state\ [%s,%s],\ but\ vm\ is\ in\ state\ [%s] = Vm can change its affinityGroup only in state [{0},{1}], but vm is in state [{2}]

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupInterceptor.java:52
# args: msg.getUuid(),agUuid
Vm\ [uuid\:\ %s]\ is\ already\ added\ to\ affinityGroup\ [uuid\:\ %s] = Vm [uuid: {0}] is already added to affinityGroup [uuid: {1}]

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupInterceptor.java:77
# args: affinityGroupUuid
AffinityGroup\ [uuid\:\ %s]\ does\ not\ existed = AffinityGroup [uuid: {0}] does not existed

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupInterceptor.java:81
# args: 
Can\ not\ operate\ on\ affinity\ group\ created\ by\ system = Can not operate on affinity group created by system

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupInterceptor.java:88
# args: affinityGroupUuid
Can\ not\ operate\ on\ affinityGroup\ [uuid\:\ %s]\ which\ is\ not\ enabled = Can not operate on affinityGroup [uuid: {0}] which is not enabled

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupManagerImpl.java:98
# args: msg.getAffinityGroupUuid()
cannot\ find\ the\ affinity\ group[uuid\:%s],\ it\ may\ have\ been\ deleted = cannot find the affinity group[uuid:{0}], it may have been deleted

# at: src/main/java/org/zstack/compute/allocator/AttachedL2NetworkAllocatorFlow.java:103
# args: spec.getL3NetworkUuids()
no\ host\ found\ in\ clusters\ that\ has\ attached\ to\ L2Networks\ which\ have\ L3Networks%s = no host found in clusters that has attached to L2Networks which have L3Networks{0}

# at: src/main/java/org/zstack/compute/allocator/AttachedPrimaryStorageAllocatorFlow.java:79
# args: psuuids
no\ host\ found\ in\ clusters\ that\ have\ attached\ to\ primary\ storage\ %s = no host found in clusters that have attached to primary storage {0}

# at: src/main/java/org/zstack/compute/allocator/AttachedVolumePrimaryStorageAllocatorFlow.java:79
# args: requiredPsUuids,vm.getUuid()
no\ host\ found\ in\ clusters\ which\ have\ attached\ to\ all\ primary\ storage\ %s\ where\ vm[uuid\:%s]'s\ volumes\ locate = no host found in clusters which have attached to all primary storage {0} where vm[uuid:{1}]'s volumes locate

# at: src/main/java/org/zstack/compute/allocator/AvoidHostAllocatorFlow.java:30
# args: spec.getAvoidHostUuids()
after\ rule\ out\ avoided\ host%s,\ there\ is\ no\ host\ left\ in\ candidates = after rule out avoided host{0}, there is no host left in candidates

# at: src/main/java/org/zstack/compute/allocator/BackupStorageSelectPrimaryStorageAllocatorFlow.java:87
# args: spec.getRequiredBackupStorageUuid(),bsType
the\ backup\ storage[uuid\:%s,\ type\:%s]\ requires\ bound\ primary\ storage,\ however,\ the\ primary\ storage\ has\ not\ been\ added = the backup storage[uuid:{0}, type:{1}] requires bound primary storage, however, the primary storage has not been added

# at: src/main/java/org/zstack/compute/allocator/BackupStorageSelectPrimaryStorageAllocatorFlow.java:80
# args: spec.getImage().getUuid(),spec.getRequiredBackupStorageUuid(),type,psUuids
The\ image[uuid\:%s]\ is\ on\ the\ backup\ storage[uuid\:%s,\ type\:%s]\ that\ requires\ to\ work\ with\ primary\ storage[uuids\:%s],however,\ no\ host\ found\ suitable\ to\ work\ with\ those\ primary\ storage = The image[uuid:{0}] is on the backup storage[uuid:{1}, type:{2}] that requires to work with primary storage[uuids:{3}],however, no host found suitable to work with those primary storage

# at: src/main/java/org/zstack/compute/allocator/BackupStorageSelectPrimaryStorageAllocatorFlow.java:71
# args: spec.getImage().getUuid(),name,spec.getRequiredBackupStorageUuid(),spec.getImage().getType(),possiblePrimaryStorageTypes
The\ image[uuid\:%s,\ name\:%s]\ is\ on\ the\ backup\ storage[uuid\:%s,\ type\:%s]\ that\ requires\ to\ work\ with\ primary\ storage[types\:%s],however,\ no\ host\ found\ suitable\ to\ work\ with\ those\ primary\ storage = The image[uuid:{0}, name:{1}] is on the backup storage[uuid:{2}, type:{3}] that requires to work with primary storage[types:{4}],however, no host found suitable to work with those primary storage

# at: src/main/java/org/zstack/compute/allocator/DesignatedHostAllocatorFlow.java:107
# args: args
No\ host\ with\ %s\ found = No host with {0} found

# at: src/main/java/org/zstack/compute/allocator/FilterFlow.java:33
# args: filter.getClass().getSimpleName(),filter.filterErrorReason()
after\ filtering,\ HostAllocatorFilterExtensionPoint[%s]\ returns\ zero\ candidate\ host,\ it\ means\:\ %s = after filtering, HostAllocatorFilterExtensionPoint[{0}] returns zero candidate host, it means: {1}

# at: src/main/java/org/zstack/compute/allocator/HostAllocatorApiInterceptor.java:56
# args: 
either\ volumeUuid\ or\ volumeSnapshotUuid\ must\ be\ set = either volumeUuid or volumeSnapshotUuid must be set

# at: src/main/java/org/zstack/compute/allocator/HostAllocatorApiInterceptor.java:75
# args: 
zoneUuids,\ clusterUuids,\ hostUuids\ must\ at\ least\ have\ one\ be\ none-empty\ list,\ or\ all\ is\ set\ to\ true = zoneUuids, clusterUuids, hostUuids must at least have one be none-empty list, or all is set to true

# at: src/main/java/org/zstack/compute/allocator/HostCapacityAllocatorFlow.java:71
# args: spec.getCpuCapacity(),spec.getMemoryCapacity()
no\ host\ having\ cpu[%s],\ memory[%s\ bytes]\ found = no host having cpu[{0}], memory[{1} bytes] found

# at: src/main/java/org/zstack/compute/allocator/HostOsVersionAllocatorFlow.java:62
# args: currentVersion
no\ candidate\ host\ has\ version[%s] = no candidate host has version[{0}]

# at: src/main/java/org/zstack/compute/allocator/HostPrimaryStorageAllocatorFlow.java:221
# args: PrimaryStorageState.Enabled,PrimaryStorageState.Disabled,PrimaryStorageStatus.Connected
cannot\ find\ available\ primary\ storage[state\:\ %s\ or\ %s,\ status\:\ %s].\ Check\ the\ state/status\ of\ primary\ storage\ and\ make\ sure\ they\ have\ been\ attached\ to\ clusters = cannot find available primary storage[state: {0} or {1}, status: {2}]. Check the state/status of primary storage and make sure they have been attached to clusters

# at: src/main/java/org/zstack/compute/allocator/HostPrimaryStorageAllocatorFlow.java:217
# args: PrimaryStorageState.Enabled,PrimaryStorageStatus.Connected,spec.getDiskSize()
cannot\ find\ available\ primary\ storage[state\:\ %s,\ status\:\ %s,\ available\ capacity\ %s\ bytes].\ Check\ the\ state/status\ of\ primary\ storage\ and\ make\ sure\ they\ have\ been\ attached\ to\ clusters = cannot find available primary storage[state: {0}, status: {1}, available capacity {2} bytes]. Check the state/status of primary storage and make sure they have been attached to clusters

# at: src/main/java/org/zstack/compute/allocator/HostSortorChain.java:127
# args: e.getMessage(),host.getUuid(),e.getMessage()
[Host\ Allocation]\:\ %s\ on\ host[uuid\:%s].\ try\ next\ one.\ %s = [Host Allocation]: {0} on host[uuid:{1}]. try next one. {2}

# at: src/main/java/org/zstack/compute/allocator/HostStateAndHypervisorAllocatorFlow.java:97
# args: spec.getHypervisorType()
no\ host\ having\ state\=Enabled\ status\=Connected\ hypervisorType\=%s\ found = no host having state=Enabled status=Connected hypervisorType={0} found

# at: src/main/java/org/zstack/compute/allocator/HostStateAndHypervisorAllocatorFlow.java:99
# args: 
no\ host\ having\ state\=Enabled\ status\=Connected\ found = no host having state=Enabled status=Connected found

# at: src/main/java/org/zstack/compute/allocator/HostStateAndHypervisorAllocatorFlow.java:94
# args: candidates.size(),spec.getHypervisorType()
no\ Enabled\ hosts\ found\ in\ the\ [%s]\ candidate\ hosts\ having\ the\ hypervisor\ type\ [%s] = no Enabled hosts found in the [{0}] candidate hosts having the hypervisor type [{1}]

# at: src/main/java/org/zstack/compute/allocator/HostStateAndHypervisorAllocatorFlow.java:92
# args: candidates.size()
no\ Enabled\ hosts\ found\ in\ the\ [%s]\ candidate\ hosts = no Enabled hosts found in the [{0}] candidate hosts

# at: src/main/java/org/zstack/compute/allocator/HostStateAndHypervisorAllocatorFlow.java:90
# args: candidates.size()
no\ Connected\ hosts\ found\ in\ the\ [%s]\ candidate\ hosts = no Connected hosts found in the [{0}] candidate hosts

# at: src/main/java/org/zstack/compute/allocator/ImageBackupStorageAllocatorFlow.java:92
# args: spec.getImage().getUuid(),spec.getImage().getName()
the\ image[uuid\:%s,\ name\:%s]\ is\ deleted\ on\ all\ backup\ storage = the image[uuid:{0}, name:{1}] is deleted on all backup storage

# at: src/main/java/org/zstack/compute/allocator/ImageBackupStorageAllocatorFlow.java:126
# args: zoneUuids,spec.getImage().getUuid()
no\ host\ found\ in\ zones[uuids\:%s]\ that\ attaches\ to\ backup\ storage\ where\ image[%s]\ is\ on = no host found in zones[uuids:{0}] that attaches to backup storage where image[{1}] is on

# at: src/main/java/org/zstack/compute/allocator/ResourceBindingAllocatorFlow.java:98
# args: entry.getKey()
resource\ binding\ not\ support\ type\ %s\ yet = resource binding not support type {0} yet

# at: src/main/java/org/zstack/compute/allocator/ResourceBindingAllocatorFlow.java:117
# args: resources
no\ available\ host\ found\ with\ binded\ resource\ %s = no available host found with binded resource {0}

# at: src/main/java/org/zstack/compute/allocator/TagAllocatorFlow.java:68
# args: extp.getClass().getName()
InstanceOfferingTagAllocatorExtensionPoint[%s]\ return\ zero\ candidate\ host = InstanceOfferingTagAllocatorExtensionPoint[{0}] return zero candidate host

# at: src/main/java/org/zstack/compute/allocator/TagAllocatorFlow.java:104
# args: extp.getClass().getName()
DiskOfferingTagAllocatorExtensionPoint[%s]\ return\ zero\ candidate\ host = DiskOfferingTagAllocatorExtensionPoint[{0}] return zero candidate host

# at: src/main/java/org/zstack/compute/cluster/ClusterApiInterceptor.java:55
# args: 
if\ cluster\ type\ is\ baremetal,\ then\ hypervisorType\ must\ be\ baremetal\ too,\ or\ vice\ versa = if cluster type is baremetal, then hypervisorType must be baremetal too, or vice versa

# at: src/main/java/org/zstack/compute/cluster/ClusterApiInterceptor.java:71
# args: 
only\ kvm\ hosts'\ operating\ system\ can\ be\ updated,\ for\ now = only kvm hosts' operating system can be updated, for now

# at: src/main/java/org/zstack/compute/cluster/ClusterApiInterceptor.java:82
# args: msg.getUuid()
there\ are\ hosts\ in\ cluster[uuid\:%s]\ in\ the\ PreMaintenance\ state,\ cannot\ update\ cluster\ os\ right\ now = there are hosts in cluster[uuid:{0}] in the PreMaintenance state, cannot update cluster os right now

# at: src/main/java/org/zstack/compute/cluster/ClusterApiInterceptor.java:94
# args: msg.getUuid()
not\ all\ hosts\ in\ cluster[uuid\:%s]\ are\ in\ the\ Connected\ status,\ cannot\ update\ cluster\ os\ right\ now = not all hosts in cluster[uuid:{0}] are in the Connected status, cannot update cluster os right now

# at: src/main/java/org/zstack/compute/cpuPinning/CpuPinningBasicFactory.java:45
# args: r
invalid\ cpu\ pinning\ ref[%s].\ correct\ example\ is\ [1,3\:3-6,^5] = invalid cpu pinning ref[{0}]. correct example is [1,3:3-6,^5]

# at: src/main/java/org/zstack/compute/cpuPinning/CpuPinningBasicFactory.java:82
# args: pCpuNum
the\ host\ vm\ located\ only\ have\ %\ CPUs = the host vm located only have % CPUs

# at: src/main/java/org/zstack/compute/cpuPinning/CpuPinningFilterFlow.java:48
# args: 
vcpu\ pinning\ pcpu\ id\ >\ host\ cores = vcpu pinning pcpu id > host cores

# at: src/main/java/org/zstack/compute/cpuPinning/CpuRangeSet.java:58
# args: word
Invalid\ cpuset\ [%s] = Invalid cpuset [{0}]

# at: src/main/java/org/zstack/compute/host/HostApiInterceptor.java:78
# args: msg.getManagementIp()
managementIp[%s]\ is\ neither\ an\ IPv4\ address\ nor\ a\ valid\ hostname = managementIp[{0}] is neither an IPv4 address nor a valid hostname

# at: src/main/java/org/zstack/compute/host/HostApiInterceptor.java:88
# args: msg.getHostUuid(),hostStatus
can\ not\ maintain\ host[uuid\:%s,\ status\:%s]which\ is\ not\ Connected = can not maintain host[uuid:{0}, status:{1}]which is not Connected

# at: src/main/java/org/zstack/compute/host/HostBase.java:259
# args: vmFailedToMigrate,self.getUuid(),self.getName(),self.getManagementIp()
failed\ to\ migrate\ vm[uuids\:%s]\ on\ host[uuid\:%s,\ name\:%s,\ ip\:%s],\ will\ try\ stopping\ it. = failed to migrate vm[uuids:{0}] on host[uuid:{1}, name:{2}, ip:{3}], will try stopping it.

# at: src/main/java/org/zstack/compute/host/HostBase.java:609
# args: 
host\ is\ connecting,\ ping\ failed = host is connecting, ping failed

# at: src/main/java/org/zstack/compute/host/HostBase.java:1085
# args: 
an\ other\ connect\ host\ task\ is\ running,\ cancel\ the\ new\ task\ and\ wait\ return = an other connect host task is running, cancel the new task and wait return

# at: src/main/java/org/zstack/compute/host/HostManagerImpl.java:282
# args: msg.getManagementIp()
there\ has\ been\ a\ host\ having\ managementIp[%s] = there has been a host having managementIp[{0}]

# at: src/main/java/org/zstack/compute/host/HostManagerImpl.java:288
# args: msg.getClusterUuid()
cluster[uuid\:%s]\ is\ not\ existing = cluster[uuid:{0}] is not existing

# at: src/main/java/org/zstack/compute/host/HostManagerImpl.java:531
# args: msg.getCancellationApiId()
no\ running\ api[%s]\ task\ on\ hosts = no running api[{0}] task on hosts

# at: src/main/java/org/zstack/compute/host/HostManagerImpl.java:624
# args: d.getPrimaryStorageUuid()
primary\ storage[uuid\:%s]\ becomes\ disconnected,\ the\ host\ has\ no\ connected\ primary\ storage\ attached = primary storage[uuid:{0}] becomes disconnected, the host has no connected primary storage attached

# at: src/main/java/org/zstack/compute/host/HostMevocoApiInterceptor.java:38
# args: nameips.stream().map( it -> it.get(1, String.class) + "/" + it.get(0, String.class)).collect(Collectors.joining(", "))
host(s)\ [%s]\ is\ not\ Connected,\ not\ support\ to\ power\ off = host(s) [{0}] is not Connected, not support to power off

# at: src/main/java/org/zstack/compute/host/HostSecurityLevelAllocatorFilterExtensionPoint.java:68
# args: 
vm\ security\ level\ not\ consistent\ with\ vms\ running\ on\ host = vm security level not consistent with vms running on host

# at: src/main/java/org/zstack/compute/host/MevocoHostBase.java:204
# args: host.getUuid(),host.getName(),host.getState()
host[uuid\:%s,\ name\:%s]\ is\ in\ state[%s],\ cannot\ perform\ required\ operation = host[uuid:{0}, name:{1}] is in state[{2}], cannot perform required operation

# at: src/main/java/org/zstack/compute/host/MevocoHostBase.java:485
# args: ret.getError()
operation\ error,\ because\ %s = operation error, because {0}

# at: src/main/java/org/zstack/compute/host/MevocoHostBase.java:377
# args: vmInstanceVO.getUuid(),vmInstanceVO.getState()
only\ support\ do\ live\ snapshot\ on\ vm\ state[%s],\ but\ vm\ is\ on\ [%s]\ state = only support do live snapshot on vm state[{0}], but vm is on [{1}] state

# at: src/main/java/org/zstack/compute/host/MevocoHostBaseFactory.java:71
# args: huuid,cidr
host[uuid\:%s]\ has\ multi\ ips\ in\ cidr[%s] = host[uuid:{0}] has multi ips in cidr[{1}]

# at: src/main/java/org/zstack/compute/host/MevocoHostManagerImpl.java:344
# args: msg.getHostUuid()
host[uuid\:%s]\ can\ not\ find = host[uuid:{0}] can not find

# at: src/main/java/org/zstack/compute/host/MevocoHostManagerImpl.java:336
# args: clusterUuids,hypervisorType
cluster[uuids\:%s,\ hypervisorType\:%s]\ are\ not\ exist! = cluster[uuids:{0}, hypervisorType:{1}] are not exist!

# at: src/main/java/org/zstack/compute/vm/ChangeVmPasswordFlow.java:50
# args: 
not\ dest\ host\ found\ in\ db,\ can't\ send\ change\ password\ cmd\ to\ the\ host! = not dest host found in db, can't send change password cmd to the host!

# at: src/main/java/org/zstack/compute/vm/ChangeVmPasswordFlow.java:51
# args: 
not\ system\ tag\ found\ on\ vm,\ vm\ must\ have\ the\ following\ system\ tag\:\ qemuga,\ if\ you\ installed\ qemu-ga\ yourself,\ please\ use\ CreateSystemTag\ first. = not system tag found on vm, vm must have the following system tag: qemuga, if you installed qemu-ga yourself, please use CreateSystemTag first.

# at: src/main/java/org/zstack/compute/vm/ChangeVmPasswordFlow.java:54
# args: 
not\ account\ preference\ found,\ \ send\ change\ password\ cmd\ to\ the\ host! = not account preference found,  send change password cmd to the host!

# at: src/main/java/org/zstack/compute/vm/DeleteVmGC.java:50
# args: hostUuid
the\ host[uuid\:%s]\ is\ not\ connected = the host[uuid:{0}] is not connected

# at: src/main/java/org/zstack/compute/vm/IsoOperator.java:40
# args: vmUuid,isoUuid
VM[uuid\:%s]\ has\ attached\ ISO[uuid\:%s] = VM[uuid:{0}] has attached ISO[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/IsoOperator.java:48
# args: vmUuid
All\ vm[uuid\:%s]\ CD-ROMs\ have\ mounted\ ISO = All vm[uuid:{0}] CD-ROMs have mounted ISO

# at: src/main/java/org/zstack/compute/vm/MacOperator.java:77
# args: mac
This\ is\ not\ a\ valid\ MAC\ address\ [%s] = This is not a valid MAC address [{0}]

# at: src/main/java/org/zstack/compute/vm/MacOperator.java:87
# args: mac
Not\ a\ valid\ MAC\ address\ [%s] = Not a valid MAC address [{0}]

# at: src/main/java/org/zstack/compute/vm/MacOperator.java:90
# args: 
Disallowed\ address = Disallowed address

# at: src/main/java/org/zstack/compute/vm/MacOperator.java:93
# args: mac
Expected\ unicast\ mac\ address,\ found\ multicast\ MAC\ address\ [%s] = Expected unicast mac address, found multicast MAC address [{0}]

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:192
# args: 
vm[uuid\:\ %s]'s\ state\ is\ not\ Stopped\ now,\ cannot\ operate\ 'changevmimage'\ action = vm[uuid: {0}]'s state is not Stopped now, cannot operate 'changevmimage' action

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:602
# args: 
can\ not\ find\ image\ store\ backup\ storage,\ unable\ to\ commit\ volume\ snapshot\ as\ image = can not find image store backup storage, unable to commit volume snapshot as image

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:397
# args: vivo.getRootVolumeUuid()
cannot\ find\ backupStorage\ for\ volume\:\ %s = cannot find backupStorage for volume: {0}

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:898
# args: inv.getInventory().getUuid(),state
vm\ running\ on\ local\ storage\ %s\ state\ is\ %s\ not\ running/stopped/paused,\ can\ not\ attach\ volume = vm running on local storage {0} state is {1} not running/stopped/paused, can not attach volume

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:1120
# args: pvo.getType(),bsType
Destination\ PrimaryStorageType\ is\ %s,\ but\ the\ selected\ BackupStorageType\ for\ source\ Volume\ is\ %s,\ which\ cannot\ be\ matched = Destination PrimaryStorageType is {0}, but the selected BackupStorageType for source Volume is {1}, which cannot be matched

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:1507
# args: 
direction\ must\ be\ set\ to\ in\ or\ out = direction must be set to in or out

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:1549
# args: inbound
inboundBandwidth\ must\ be\ set\ no\ more\ than\ %s. = inboundBandwidth must be set no more than {0}.

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:1560
# args: outbound
outboundBandwidth\ must\ be\ set\ no\ more\ than\ %s. = outboundBandwidth must be set no more than {0}.

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:1651
# args: self.getUuid()
vm\ [%s]'\ state\ must\ be\ Running\ or\ Paused\ to\ sync\ nic\ qos = vm [{0}]' state must be Running or Paused to sync nic qos

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:1656
# args: 
vm\ [%s]'s\ HostUuid\ is\ null,\ cannot\ sync\ nic\ qos = vm [{0}]'s HostUuid is null, cannot sync nic qos

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:2056
# args: amsg.getVmInstanceUuid()
not\ dest\ host\ found\ in\ db\ by\ uuid\:\ %s,\ can't\ send\ change\ password\ cmd\ to\ the\ host! = not dest host found in db by uuid: {0}, can't send change password cmd to the host!

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:2084
# args: 
state\ is\ not\ correct\ while\ change\ password. = state is not correct while change password.

# at: src/main/java/org/zstack/compute/vm/VmAllocateCdRomFlow.java:55
# args: spec.getVmInventory().getUuid()
vm[uuid\:%s]\ cdRom\ deviceId\ repetition = vm[uuid:{0}] cdRom deviceId repetition

# at: src/main/java/org/zstack/compute/vm/VmAllocateNicFlow.java:81
# args: v.getUuid()
there\ is\ no\ available\ ipRange\ on\ L3\ network\ [%s] = there is no available ipRange on L3 network [{0}]

# at: src/main/java/org/zstack/compute/vm/VmAllocatePrimaryStorageForAttachingDiskFlow.java:49
# args: spec.getVmInventory().getUuid()
\ Can\ not\ find\ the\ vm's\ host,\ please\ start\ the\ vm[%s],\ then\ mount\ the\ disk =  Can not find the vm's host, please start the vm[{0}], then mount the disk

# at: src/main/java/org/zstack/compute/vm/VmDownloadIsoFlow.java:68
# args: iso.getUuid(),host.getZoneUuid(),spec.getVmInventory().getName(),spec.getVmInventory().getUuid()
cannot\ find\ the\ iso[uuid\:%s]\ in\ any\ connected\ backup\ storage\ attached\ to\ the\ zone[uuid\:%s].\ check\ below\:\n1.\ if\ the\ backup\ storage\ is\ attached\ to\ the\ zone\ where\ the\ VM[name\:\ %s,\ uuid\:%s]\ is\ running\n2.\ if\ the\ backup\ storage\ is\ in\ connected\ status,\ if\ not,\ try\ reconnecting\ it = cannot find the iso[uuid:{0}] in any connected backup storage attached to the zone[uuid:{1}]. check below:\n1. if the backup storage is attached to the zone where the VM[name: {2}, uuid:{3}] is running\n2. if the backup storage is in connected status, if not, try reconnecting it

# at: src/main/java/org/zstack/compute/vm/VmImageSelectBackupStorageFlow.java:92
# args: imageUuid,spec.getVmInventory().getName(),spec.getVmInventory().getUuid()
cannot\ find\ the\ image[uuid\:%s]\ in\ any\ connected\ backup\ storage.\ check\ below\:\n1.\ if\ the\ backup\ storage\ is\ attached\ to\ the\ zone\ where\ the\ VM[name\:\ %s,\ uuid\:%s]\ is\ in\n2.\ if\ the\ backup\ storage\ is\ in\ connected\ status,\ if\ not,\ try\ reconnecting\ it = cannot find the image[uuid:{0}] in any connected backup storage. check below:\n1. if the backup storage is attached to the zone where the VM[name: {1}, uuid:{2}] is in\n2. if the backup storage is in connected status, if not, try reconnecting it

# at: src/main/java/org/zstack/compute/vm/VmImageSelectBackupStorageFlow.java:86
# args: imageUuid,spec.getVmInventory().getZoneUuid(),spec.getVmInventory().getName(),spec.getVmInventory().getUuid()
cannot\ find\ the\ image[uuid\:%s]\ in\ any\ connected\ backup\ storage\ attached\ to\ the\ zone[uuid\:%s].\ check\ below\:\n1.\ if\ the\ backup\ storage\ is\ attached\ to\ the\ zone\ where\ the\ VM[name\:\ %s,\ uuid\:%s]\ is\ in\n2.\ if\ the\ backup\ storage\ is\ in\ connected\ status,\ if\ not,\ try\ reconnecting\ it = cannot find the image[uuid:{0}] in any connected backup storage attached to the zone[uuid:{1}]. check below:\n1. if the backup storage is attached to the zone where the VM[name: {2}, uuid:{3}] is in\n2. if the backup storage is in connected status, if not, try reconnecting it

# at: src/main/java/org/zstack/compute/vm/VmImageSelectBackupStorageFlow.java:114
# args: zoneUuid,isoImageUuid
no\ backup\ storage\ attached\ to\ the\ zone[uuid\:%s]\ contains\ the\ ISO[uuid\:%s] = no backup storage attached to the zone[uuid:{0}] contains the ISO[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:341
# args: msg.getVmInstanceUuid(),msg.getIsoUuid()
VM[uuid\:%s]\ already\ has\ an\ ISO[uuid\:%s]\ attached = VM[uuid:{0}] already has an ISO[uuid:{1}] attached

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:500
# args: ipv4Count
there\ are\ %d\ ipv4\ network\ on\ same\ nic = there are {0} ipv4 network on same nic

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:133
# args: msg.getVmInstanceUuid(),vo.getState().toString()
Can\ not\ create\ CD-ROM\ for\ vm[uuid\:%s]\ which\ is\ in\ state[%s]\  = Can not create CD-ROM for vm[uuid:{0}] which is in state[{1}] 

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:141
# args: 
rootDiskSize\ is\ needed\ when\ image\ media\ type\ is\ ISO = rootDiskSize is needed when image media type is ISO

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:151
# args: msg.getVmInstanceUuid(),msg.getHostUuid()
the\ vm[uuid\:%s]\ is\ already\ on\ host[uuid\:%s] = the vm[uuid:{0}] is already on host[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:207
# args: 
the\ VM\ cannot\ do\ online\ cpu/memory\ update\ because\ of\ disabling\ Instance\ Offering\ Online\ Modification.\ Please\ stop\ the\ VM\ then\ do\ the\ cpu/memory\ update\ again = the VM cannot do online cpu/memory update because of disabling Instance Offering Online Modification. Please stop the VM then do the cpu/memory update again

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:213
# args: vo.getUuid(),vo.getState(),StringUtils.join(list(VmInstanceState.Running, VmInstanceState.Stopped), ",")
The\ state\ of\ vm[uuid\:%s]\ is\ %s.\ Only\ these\ state[%s]\ is\ allowed\ to\ update\ cpu\ or\ memory. = The state of vm[uuid:{0}] is {1}. Only these state[{2}] is allowed to update cpu or memory.

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:184
# args: vo.getUuid()
can't\ decrease\ capacity\ when\ vm[uuid\:%s]\ is\ running = can't decrease capacity when vm[uuid:{0}] is running

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:224
# args: vo.getUuid()
can't\ decrease\ cpu\ of\ vm[uuid\:%s]\ when\ it\ is\ running = can't decrease cpu of vm[uuid:{0}] when it is running

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:230
# args: vo.getUuid()
can't\ decrease\ memory\ size\ of\ vm[uuid\:%s]\ when\ it\ is\ running = can't decrease memory size of vm[uuid:{0}] when it is running

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:241
# args: 
either\ l3NetworkUuids\ or\ imageUuid\ must\ be\ set = either l3NetworkUuids or imageUuid must be set

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:256
# args: ip
%s\ is\ not\ a\ valid\ IPv4\ address = {0} is not a valid IPv4 address

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:282
# args: ip,vmNicVO.getUuid()
ip\ address\ [%s]\ already\ set\ to\ vmNic\ [uuid\:%s] = ip address [{0}] already set to vmNic [uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:267
# args: ip,rangeVO.getNetworkCidr()
ip\ address\ [%s]\ is\ not\ in\ ip\ range\ [%s] = ip address [{0}] is not in ip range [{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:276
# args: ip
%s\ is\ not\ a\ valid\ IPv6\ address = {0} is not a valid IPv6 address

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:287
# args: ip,rangeVO.getStartIp(),rangeVO.getEndIp()
ip\ address\ [%s]\ is\ not\ in\ ip\ range\ [startIp\ %s,\ endIp\ %s] = ip address [{0}] is not in ip range [startIp {1}, endIp {2}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:321
# args: msg.getVmInstanceUuid(),msg.getL3NetworkUuid()
the\ VM[uuid\:%s]\ has\ no\ nic\ on\ the\ L3\ network[uuid\:%s] = the VM[uuid:{0}] has no nic on the L3 network[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:332
# args: o,msg.getBootOrder()
invalid\ boot\ device[%s]\ in\ boot\ order%s = invalid boot device[{0}] in boot order{1}

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:356
# args: cdRomUuid
The\ cdRom[uuid\:%s]\ does\ not\ exist = The cdRom[uuid:{0}] does not exist

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:360
# args: msg.getVmInstanceUuid(),cdRomUuid
VM[uuid\:%s]\ cdRom[uuid\:%s]\ has\ mounted\ the\ ISO = VM[uuid:{0}] cdRom[uuid:{1}] has mounted the ISO

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:378
# args: msg.getVmInstanceUuid()
VM[uuid\:%s]\ has\ multiple\ ISOs\ attached,\ specify\ the\ isoUuid\ when\ detaching = VM[uuid:{0}] has multiple ISOs attached, specify the isoUuid when detaching

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:482
# args: l3Uuid
unable\ to\ attach\ a\ L3\ network.\ The\ L3\ network[uuid\:%s]\ is\ disabled = unable to attach a L3 network. The L3 network[uuid:{0}] is disabled

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:553
# args: staticIp,l3Uuid
the\ static\ IP[%s]\ is\ not\ in\ any\ IP\ range\ of\ the\ L3\ network[uuid\:%s] = the static IP[{0}] is not in any IP range of the L3 network[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:560
# args: staticIp,l3Uuid
the\ static\ IP[%s]\ has\ been\ occupied\ on\ the\ L3\ network[uuid\:%s] = the static IP[{0}] has been occupied on the L3 network[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:432
# args: msg.getVmInstanceUuid(),state
unable\ to\ attach\ a\ L3\ network.\ The\ vm[uuid\:\ %s]\ is\ not\ Running\ or\ Stopped;\ the\ current\ state\ is\ %s = unable to attach a L3 network. The vm[uuid: {0}] is not Running or Stopped; the current state is {1}

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:446
# args: newAddedL3Uuids,l2Uuids
unable\ to\ attach\ a\ L3\ network.\ The\ L3\ network[uuid\:%s]\ are\ belonged\ to\ different\ l2\ networks\ [uuids\:%s] = unable to attach a L3 network. The L3 network[uuid:{0}] are belonged to different l2 networks [uuids:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:453
# args: newAddedL3Uuids,l2Uuids
unable\ to\ attach\ a\ L3\ network.\ The\ L3\ network[uuid\:%s]\ are\ belonged\ to\ l2\ networks\ [uuids\:%s]\ that\ have\ not\ been\ attached\ to\ any\ cluster = unable to attach a L3 network. The L3 network[uuid:{0}] are belonged to l2 networks [uuids:{1}] that have not been attached to any cluster

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:465
# args: attachedL3Uuids,msg.getVmInstanceUuid()
unable\ to\ attach\ a\ L3\ network.\ The\ L3\ network[uuid\:%s]\ is\ already\ attached\ to\ the\ vm[uuid\:\ %s] = unable to attach a L3 network. The L3 network[uuid:{0}] is already attached to the vm[uuid: {1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:472
# args: attachedL3Uuids,msg.getVmInstanceUuid()
unable\ to\ attach\ a\ non-guest\ L3\ network.\ The\ L3\ network[uuid\:%s]\ is\ already\ attached\ to\ the\ vm[uuid\:\ %s] = unable to attach a non-guest L3 network. The L3 network[uuid:{0}] is already attached to the vm[uuid: {1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:485
# args: l3Uuid
unable\ to\ attach\ a\ L3\ network.\ The\ L3\ network[uuid\:%s]\ is\ a\ system\ network\ and\ vm\ is\ a\ user\ vm = unable to attach a L3 network. The L3 network[uuid:{0}] is a system network and vm is a user vm

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:503
# args: statefulIpv6
there\ are\ %d\ ipv6\ stateful\ or\ stateless\ network\ on\ same\ nic = there are {0} ipv6 stateful or stateless network on same nic

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:535
# args: e.getKey(),newAddedL3Uuids
static\ ip\ l3\ uuid[%s]\ is\ not\ included\ in\ nic\ l3\ [%s] = static ip l3 uuid[{0}] is not included in nic l3 [{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:583
# args: msg.getVmInstanceUuid(),state
unable\ to\ attach\ the\ nic.\ The\ vm[uuid\:\ %s]\ is\ not\ Running\ or\ Stopped;\ the\ current\ state\ is\ %s = unable to attach the nic. The vm[uuid: {0}] is not Running or Stopped; the current state is {1}

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:590
# args: vmNicVO.getVmInstanceUuid()
unable\ to\ attach\ the\ nic.\ The\ nic\ has\ been\ attached\ with\ vm[uuid\:\ %s] = unable to attach the nic. The nic has been attached with vm[uuid: {0}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:601
# args: vmNicVO.getL3NetworkUuid(),msg.getVmInstanceUuid()
unable\ to\ attach\ the\ nic.\ Its\ L3\ network[uuid\:%s]\ is\ already\ attached\ to\ the\ vm[uuid\:\ %s] = unable to attach the nic. Its L3 network[uuid:{0}] is already attached to the vm[uuid: {1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:606
# args: vmNicVO.getL3NetworkUuid(),msg.getVmInstanceUuid()
unable\ to\ attach\ the\ nic\ with\ a\ non-guest\ L3\ network.\ Its\ L3\ network[uuid\:%s]\ is\ already\ attached\ to\ the\ vm[uuid\:\ %s] = unable to attach the nic with a non-guest L3 network. Its L3 network[uuid:{0}] is already attached to the vm[uuid: {1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:615
# args: l3NetworkVO.getUuid()
unable\ to\ attach\ the\ nic.\ Its\ L3\ network[uuid\:%s]\ is\ disabled = unable to attach the nic. Its L3 network[uuid:{0}] is disabled

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:618
# args: l3NetworkVO.getUuid()
unable\ to\ attach\ the\ nic.\ Its\ L3\ network[uuid\:%s]\ is\ a\ system\ network\ and\ vm\ is\ a\ user\ vm = unable to attach the nic. Its L3 network[uuid:{0}] is a system network and vm is a user vm

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:625
# args: l3NetworkVO.getL2NetworkUuid()
unable\ to\ attach\ the\ nic.\ Its\ l2\ network\ [uuid\:%s]\ that\ have\ not\ been\ attached\ to\ any\ cluster = unable to attach the nic. Its l2 network [uuid:{0}] that have not been attached to any cluster

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:640
# args: msg.getVmInstanceUuid(),state
unable\ to\ detach\ a\ L3\ network.\ The\ vm[uuid\:\ %s]\ is\ not\ Running\ or\ Stopped;\ the\ current\ state\ is\ %s = unable to detach a L3 network. The vm[uuid: {0}] is not Running or Stopped; the current state is {1}

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:666
# args: msg.getVmInstanceUuid(),state
vm[uuid\:%s]\ can\ only\ attach\ volume\ when\ state\ is\ Running\ or\ Stopped,\ current\ state\ is\ %s = vm[uuid:{0}] can only attach volume when state is Running or Stopped, current state is {1}

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:674
# args: 
image\ mediaType\ is\ ISO\ but\ missing\ root\ disk\ settings = image mediaType is ISO but missing root disk settings

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:678
# args: 
Unexpected\ root\ disk\ settings = Unexpected root disk settings

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:689
# args: 
Missing\ CPU/memory\ settings = Missing CPU/memory settings

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:693
# args: 
Unexpected\ CPU/memory\ settings = Unexpected CPU/memory settings

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:881
# args: cdRomIsoUuid
The\ image[uuid\=%s]\ does\ not\ exist = The image[uuid={0}] does not exist

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:886
# args: 
Do\ not\ allow\ to\ mount\ duplicate\ ISO = Do not allow to mount duplicate ISO

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:901
# args: 
The\ console\ password\ cannot\ start\ with\ 'password'\ which\ may\ trigger\ a\ VNC\ security\ issue = The console password cannot start with 'password' which may trigger a VNC security issue

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:910
# args: msg.getVmNicUuid()
vmNic[uuid\:%s]\ is\ not\ attached\ to\ vmInstance = vmNic[uuid:{0}] is not attached to vmInstance

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:917
# args: msg.getL3NetworkUuid(),msg.getVmNicUuid()
L3\ network[uuid\:%s]\ has\ already\ been\ to\ attached\ vmNic[uuid\:%s] = L3 network[uuid:{0}] has already been to attached vmNic[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:937
# args: ipVO.getL3NetworkUuid(),msg.getVmNicUuid()
there\ is\ another\ IPv6\ stateful-dhcp\ network[uuid\:%s]\ attached\ vmNic[uuid\:%s] = there is another IPv6 stateful-dhcp network[uuid:{0}] attached vmNic[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:926
# args: ipVO.getL3NetworkUuid(),msg.getVmNicUuid()
there\ is\ another\ IPv4\ network[uuid\:%s]\ attached\ vmNic[uuid\:%s] = there is another IPv4 network[uuid:{0}] attached vmNic[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:955
# args: l3Vo.getL2NetworkUuid(),oldL3.getL2NetworkUuid()
l2Network\ [uuid\:%s]\ to\ be\ attached\ is\ different\ from\ l2Network\ [uuid\:%s]\ of\ the\ nic = l2Network [uuid:{0}] to be attached is different from l2Network [uuid:{1}] of the nic

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:974
# args: vmCdRomVO.getUuid()
The\ CdRom[%s]\ Already\ the\ default = The CdRom[{0}] Already the default

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:235
# args: vo.getUuid(),vo.getName()
vm[uuid\:%s,\ name\:%s]\ has\ been\ deleted = vm[uuid:{0}, name:{1}] has been deleted

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:766
# args: self.getUuid(),l3Uuid
the\ vm[uuid\:%s]\ has\ no\ nic\ on\ the\ L3\ network[uuid\:%s] = the vm[uuid:{0}] has no nic on the L3 network[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:1154
# args: 
the\ vm\ has\ been\ deleted = the vm has been deleted

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:3822
# args: isoUuid,psUuid,self.getName(),self.getUuid()
the\ ISO[uuid\:%s]\ is\ on\ backup\ storage\ that\ is\ not\ compatible\ of\ the\ primary\ storage[uuid\:%s]\ where\ the\ VM[name\:%s,\ uuid\:%s]\ is\ on = the ISO[uuid:{0}] is on backup storage that is not compatible of the primary storage[uuid:{1}] where the VM[name:{2}, uuid:{3}] is on

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:4224
# args: self.getHostUuid(),cpuNum - oldCpuNum,struct.alignedMemory - oldMemorySize
host[uuid\:%s]\ capacity\ is\ not\ enough\ to\ offer\ cpu[%s],\ memory[%s\ bytes] = host[uuid:{0}] capacity is not enough to offer cpu[{1}], memory[{2} bytes]

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:4444
# args: isoUuid,self.getUuid()
ISO[uuid\:%s]\ is\ not\ attached\ to\ VM[uuid\:%s] = ISO[uuid:{0}] is not attached to VM[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:5174
# args: self.getUuid()
unable\ to\ start\ the\ vm[uuid\:%s].\ It\ doesn't\ have\ any\ nic,\ please\ attach\ a\ nic\ and\ try\ again = unable to start the vm[uuid:{0}]. It doesn't have any nic, please attach a nic and try again

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:5411
# args: cdRomSpecs.size(),max
One\ vm\ cannot\ create\ %s\ CDROMs,\ vm\ can\ only\ add\ %s\ CDROMs = One vm cannot create {0} CDROMs, vm can only add {1} CDROMs

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:6301
# args: msg.getVmInstanceUuid(),max
VM[uuid\:%s]\ can\ only\ add\ %s\ CDROMs = VM[uuid:{0}] can only add {1} CDROMs

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:6371
# args: self.getUuid(),msg.getPriority(),reply.getError()
update\ vm[%s]\ priority\ to\ [%s]\ failed,because\ %s = update vm[{0}] priority to [{1}] failed,because {2}

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:58
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceStartNewCreatedVmExtensionPoint[%s]\ refuses\ to\ create\ vm[uuid\:%s]\ because\ %s = VmInstanceStartNewCreatedVmExtensionPoint[{0}] refuses to create vm[uuid:{1}] because {2}

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:176
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceRebootExtensionPoint[%s]\ refuses\ to\ reboot\ vm[uuid\:%s]\ because\ %s = VmInstanceRebootExtensionPoint[{0}] refuses to reboot vm[uuid:{1}] because {2}

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:218
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceDestroyVmExtensionPoint[%s]\ refuses\ to\ destroy\ vm[uuid\:%s]\ because\ %s = VmInstanceDestroyVmExtensionPoint[{0}] refuses to destroy vm[uuid:{1}] because {2}

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:259
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceStartExtensionPoint[%s]\ refuses\ to\ start\ vm[uuid\:%s]\ because\ %s = VmInstanceStartExtensionPoint[{0}] refuses to start vm[uuid:{1}] because {2}

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:251
# args: 
Spice\ certificate\ does\ not\ exist,\ Please\ check\ if\ spice\ tls\ is\ enabled = Spice certificate does not exist, Please check if spice tls is enabled

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:434
# args: msg.getImageUuid(),msg.getZoneUuid()
the\ image[uuid\:%s]\ is\ not\ on\ any\ backup\ storage\ that\ has\ been\ attached\ to\ the\ zone[uuid\:%s] = the image[uuid:{0}] is not on any backup storage that has been attached to the zone[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:541
# args: bss.get(0).getUuid(),bss.get(0).getType()
no\ primary\ storage\ accessible\ to\ the\ backup\ storage[uuid\:%s,\ type\:%s]\ is\ found = no primary storage accessible to the backup storage[uuid:{0}, type:{1}] is found

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:560
# args: psUuids,zoneUuid
the\ primary\ storages[uuids\:%s]\ has\ not\ attached\ any\ cluster\ on\ the\ zone[uuid\:%s] = the primary storages[uuids:{0}] has not attached any cluster on the zone[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:577
# args: clusterUuids
no\ l2Networks\ found\ in\ clusters\ that\ have\ attached\ to\ primary\ storages[uuids\:%s] = no l2Networks found in clusters that have attached to primary storages[uuids:{0}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:502
# args: image.getName(),image.getUuid()
the\ image[name\:%s,\ uuid\:%s]\ is\ an\ ISO,\ rootDiskSize\ must\ be\ set = the image[name:{0}, uuid:{1}] is an ISO, rootDiskSize must be set

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:542
# args: image.getName(),image.getUuid()
zoneUuid\ must\ be\ set\ because\ the\ image[name\:%s,\ uuid\:%s]\ is\ on\ multiple\ backup\ storage = zoneUuid must be set because the image[name:{0}, uuid:{1}] is on multiple backup storage

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1453
# args: tuple.get(0, String.class),tuple.get(1, String.class)
unable\ to\ enable\ this\ function.\ There\ are\ multi\ nics\ of\ L3\ network[uuid\:%s]\ in\ the\ vm[uuid\:\ %s] = unable to enable this function. There are multi nics of L3 network[uuid:{0}] in the vm[uuid: {1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1466
# args: hostname,tag
hostname[%s]\ specified\ in\ system\ tag[%s]\ is\ not\ a\ valid\ domain\ name = hostname[{0}] specified in system tag[{1}] is not a valid domain name

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1478
# args: hostnameCount
only\ one\ hostname\ system\ tag\ is\ allowed,\ but\ %s\ got = only one hostname system tag is allowed, but {0} got

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1514
# args: ip,sysTag
%s\ is\ not\ a\ valid\ IPv6\ address.\ Please\ correct\ your\ system\ tag[%s]\ of\ static\ IP = {0} is not a valid IPv6 address. Please correct your system tag[{1}] of static IP

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1508
# args: ip,sysTag
%s\ is\ not\ a\ valid\ IPv4\ address.\ Please\ correct\ your\ system\ tag[%s]\ of\ static\ IP = {0} is not a valid IPv4 address. Please correct your system tag[{1}] of static IP

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1530
# args: ip,l3Uuid,cr.getReason()
IP[%s]\ is\ not\ available\ on\ the\ L3\ network[uuid\:%s]\ because\:\ %s = IP[{0}] is not available on the L3 network[uuid:{1}] because: {2}

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1573
# args: uuid
l3\ network\ [uuid\:\ %s]\ is\ added\ to\ vm\ more\ than\ once = l3 network [uuid: {0}] is added to vm more than once

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1567
# args: statefulIpv6Count
there\ are\ %d\ ipv6\ stateful\ network\ on\ same\ nic = there are {0} ipv6 stateful network on same nic

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1590
# args: primaryL3Uuid,sysTag
L3\ network[uuid\:%s]\ not\ found.\ Please\ correct\ your\ system\ tag[%s]\ of\ dualStackNic = L3 network[uuid:{0}] not found. Please correct your system tag[{1}] of dualStackNic

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1595
# args: primaryL3Uuid,secondaryL3Uuid
L3\ networks[primaryL3Uuid\:%s,\ secondaryL3Uuid\:%s]\ of\ dualStackNic\ is\ not\ on\ same\ l2\ network = L3 networks[primaryL3Uuid:{0}, secondaryL3Uuid:{1}] of dualStackNic is not on same l2 network

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1606
# args: secondaryL3Uuid
L3\ networks[uuid\:%s]\ does\ not\ have\ ip\ range = L3 networks[uuid:{0}] does not have ip range

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1629
# args: tag,sameTag.getResourceUuid(),hostname,l3Uuid
conflict\ hostname\ in\ system\ tag[%s];\ there\ has\ been\ a\ VM[uuid\:%s]\ having\ hostname[%s]\ on\ L3\ network[uuid\:%s] = conflict hostname in system tag[{0}]; there has been a VM[uuid:{1}] having hostname[{2}] on L3 network[uuid:{3}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1662
# args: o,order
invalid\ boot\ device[%s]\ in\ boot\ order[%s] = invalid boot device[{0}] in boot order[{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1680
# args: resourceUuid
Already\ have\ one\ userdata\ systemTag\ for\ vm[uuid\:\ %s]. = Already have one userdata systemTag for vm[uuid: {0}].

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1700
# args: 
Shouldn't\ be\ more\ than\ one\ userdata\ systemTag\ for\ one\ vm. = Shouldn't be more than one userdata systemTag for one vm.

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1823
# args: type
vm\ machine\ type\ requires\ [q35,\ pc],\ but\ get\ [%s] = vm machine type requires [q35, pc], but get [{0}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:2235
# args: ref.getResourceUuid()
the\ resource[uuid\:%s]\ is\ a\ ROOT\ volume,\ you\ cannot\ change\ its\ owner,\ instead,change\ the\ owner\ of\ the\ VM\ the\ root\ volume\ belongs\ to = the resource[uuid:{0}] is a ROOT volume, you cannot change its owner, instead,change the owner of the VM the root volume belongs to

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:182
# args: vmType
clean\ traffic\ is\ not\ supported\ for\ vm\ type\ [%s] = clean traffic is not supported for vm type [{0}]

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:172
# args: msg.getMac()
Duplicate\ mac\ address\ [%s] = Duplicate mac address [{0}]

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:91
# args: VmInstanceState.Stopped,msg.getVmInstanceUuid()
Can\ not\ set\ security\ level\ to\ not\ %s\ vm\ [uuid\:%s] = Can not set security level to not {0} vm [uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:108
# args: 
The\ operation\ only\ allows\ on\ user\ vm = The operation only allows on user vm

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:138
# args: msg.getVmInstanceUuid(),volumeVOS.stream().map(VolumeVO::getUuid).collect(Collectors.toList()),primaryStorageUuid,(totalCapacity - snapshotsCapacity) * msg.getNames().size(),primaryStorageVO.getCapacity().getAvailableCapacity()
there\ are\ not\ enough\ capacity\ for\ full\ vm\ clone\ to\ vm[uuid\:\ %s],\ volumes[uuid\:\ %s]\ on\ primary\ storage[uuid\:\ %s]\ required\:\ %s\ bytes,\ current\ available\ capacity\ is\ %s\ bytes = there are not enough capacity for full vm clone to vm[uuid: {0}], volumes[uuid: {1}] on primary storage[uuid: {2}] required: {3} bytes, current available capacity is {4} bytes

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:152
# args: msg.getVmNicUuid()
The\ nic\ [%s%s]\ is\ not\ mounted\ on\ the\ VM = The nic [{0}{1}] is not mounted on the VM

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:158
# args: 
The\ operation\ only\ allows\ on\ user\ vm\  = The operation only allows on user vm 

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:163
# args: vmInstanceVO.getUuid()
The\ operation\ only\ allows\ when\ vm\ [%s]\ state\ is\ stopped\  = The operation only allows when vm [{0}] state is stopped 

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:192
# args: msg.getVmInstanceUuid()
user\ has\ no\ privilege\ to\ change\ image\ of\ vm\ %s = user has no privilege to change image of vm {0}

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:205
# args: 
Can't\ change\ vm\ image\ when\ it's\ not\ stopped = Can't change vm image when it's not stopped

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:211
# args: 
Can't\ change\ vm\ image\ without\ L3\ network = Can't change vm image without L3 network

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:226
# args: msg.getVmInstanceUuid()
make\ sure\ the\ primary\ storage\ vm[uuid\:%s]\ was\ on\ is\ Enabled\ and\ Connected = make sure the primary storage vm[uuid:{0}] was on is Enabled and Connected

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:241
# args: msg.getVmInstanceUuid()
make\ sure\ the\ last\ host\ vm[uuid\:%s]\ was\ on\ is\ Enabled\ and\ Connected = make sure the last host vm[uuid:{0}] was on is Enabled and Connected

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:260
# args: msg.getVmInstanceUuid(),msg.getImageUuid()
user\ has\ no\ privilege\ to\ change\ root\ volume\ of\ vm\ %s\ using\ image\ %s = user has no privilege to change root volume of vm {0} using image {1}

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:271
# args: 
either\ uuid\ or\ account\ or\ password\ must\ be\ set = either uuid or account or password must be set

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:279
# args: msg.getDirection()
direction\ must\ be\ set\ in\ (in,\ out),\ but\ was\ %s = direction must be set in (in, out), but was {0}

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:285
# args: 
Monitor\ number\ must\ be\ 1\ or\ 2\ or\ 4. = Monitor number must be 1 or 2 or 4.

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:293
# args: 
outboundBandwidth\ and\ inboundBandwidth\ must\ be\ set\ at\ lease\ one. = outboundBandwidth and inboundBandwidth must be set at lease one.

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:302
# args: 
the\ nic\ can't\ apply\ Qos\ with\ the\ port\ mirror\ service\ at\ same\ time. = the nic can't apply Qos with the port mirror service at same time.

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:311
# args: msg.getUuid()
nic\ id\:\ %s\ does\ not\ exist... = nic id: {0} does not exist...

# at: src/main/java/org/zstack/configuration/ConfigurationApiInterceptor.java:86
# args: msg.getAllocatorStrategy()
unsupported\ host\ allocation\ strategy[%s] = unsupported host allocation strategy[{0}]

# at: src/main/java/org/zstack/configuration/ConfigurationApiInterceptor.java:72
# args: msg.getType()
unsupported\ instance\ offering\ type[%s] = unsupported instance offering type[{0}]

# at: src/main/java/org/zstack/configuration/ConfigurationApiInterceptor.java:76
# args: msg.getCpuNum()
cpu\ num[%s]\ is\ less\ than\ 1 = cpu num[{0}] is less than 1

# at: src/main/java/org/zstack/configuration/ConfigurationApiInterceptor.java:80
# args: msg.getMemorySize()
memory\ size[%s\ bytes]\ is\ less\ than\ 16M,\ no\ modern\ operating\ system\ is\ likely\ able\ to\ boot\ with\ such\ small\ memory\ size = memory size[{0} bytes] is less than 16M, no modern operating system is likely able to boot with such small memory size

# at: src/main/java/org/zstack/configuration/ConfigurationApiInterceptor.java:92
# args: msg.getAllocationStrategy()
unsupported\ primary\ storage\ allocation\ strategy[%s] = unsupported primary storage allocation strategy[{0}]

# at: src/main/java/org/zstack/console/AbstractConsoleProxyBackend.java:101
# args: 
the\ console\ agent\ is\ not\ connected;\ it's\ mostly\ like\ the\ management\ node\ just\ starts,\ please\ wait\ for\ the\ console\ agent\ connected,\ or\ you\ can\ reconnect\ it\ manually\ if\ disconnected\ for\ a\ long\ time. = the console agent is not connected; it's mostly like the management node just starts, please wait for the console agent connected, or you can reconnect it manually if disconnected for a long time.

# at: src/main/java/org/zstack/console/AbstractConsoleProxyBackend.java:122
# args: vm.getUuid()
cannot\ find\ host\ IP\ of\ the\ vm[uuid\:%s],\ is\ the\ vm\ running??? = cannot find host IP of the vm[uuid:{0}], is the vm running???

# at: src/main/java/org/zstack/console/ConsoleApiInterceptor.java:52
# args: msg.getVmInstanceUuid(),state
Console\ is\ only\ available\ when\ the\ VM[uuid\:%s]\ is\ Running,\ but\ the\ current\ state\ is\ %s = Console is only available when the VM[uuid:{0}] is Running, but the current state is {1}

# at: src/main/java/org/zstack/console/ConsoleProxyBase.java:62
# args: uri.toString()
establish\ VNC\:\ unexpected\ uri\:\ %s = establish VNC: unexpected uri: {0}

# at: src/main/java/org/zstack/console/ConsoleProxyBase.java:148
# args: ret.getError()
unable\ to\ check\ console\ proxy\ availability,\ because\ %s = unable to check console proxy availability, because {0}

# at: src/main/java/org/zstack/console/ManagementServerConsoleProxyBackend.java:153
# args: 
Ansible\ private\ key\ not\ found. = Ansible private key not found.

# at: src/main/java/org/zstack/console/ManagementServerConsoleProxyBackend.java:347
# args: uuid
invalid\ management\ node\ UUID[%s] = invalid management node UUID[{0}]

# at: src/main/java/org/zstack/console/ManagementServerConsoleProxyBackend.java:468
# args: 
failed\ to\ configure\ consoleProxyOverriddenIp = failed to configure consoleProxyOverriddenIp

# at: src/main/java/org/zstack/console/ManagementServerConsoleProxyBackend.java:491
# args: 
failed\ to\ reconnect\ console\ proxy = failed to reconnect console proxy

# at: src/main/java/org/zstack/core/ansible/AnsibleRunner.java:397
# args: 
User\ name\ or\ password\ or\ port\ number\ may\ be\ problematic = User name or password or port number may be problematic

# at: src/main/java/org/zstack/core/ansible/CallBackNetworkChecker.java:70
# args: targetIp,callbackIp,callBackPort
cannot\ nmap\ from\ agent\:\ %s\ to\ callback\ address\:\ %s\:%s = cannot nmap from agent: {0} to callback address: {1}:{2}

# at: src/main/java/org/zstack/core/ansible/SshFolderMd5Checker.java:106
# args: srcFolder,srcRes.getStdout(),srcRes.getStderr()
cannot\ check\ md5sum\ of\ files\ in\ the\ folder[%s].\nstdout\:%s\nstderr\:%s = cannot check md5sum of files in the folder[{0}].\nstdout:{1}\nstderr:{2}

# at: src/main/java/org/zstack/core/ansible/SshFolderMd5Checker.java:121
# args: dstFolder,hostname,dstRes.getStdout(),dstRes.getStderr()
cannot\ check\ md5sum\ of\ files\ in\ the\ folder[%s]\ on\ the\ host[ip\:%s].\nstdout\:%s\nstderr\:%s = cannot check md5sum of files in the folder[{0}] on the host[ip:{1}].\nstdout:{2}\nstderr:{3}

# at: src/main/java/org/zstack/core/cloudbus/CloudBusImpl2.java:681
# args: errMsg
message\ is\ not\ in\ corrected\ JSON\ mediaType,\ %s = message is not in corrected JSON mediaType, {0}

# at: src/main/java/org/zstack/core/cloudbus/CloudBusImpl3.java:543
# args: rsp.getStatusCode(),rsp.getBody()
HTTP\ ERROR,\ status\ code\:\ %s,\ body\:\ %s = HTTP ERROR, status code: {0}, body: {1}

# at: src/main/java/org/zstack/core/cloudbus/EventFacadeImpl.java:68
# args: EventFacade.WEBHOOK_TYPE
for\ webhooks\ with\ type[%s],\ the\ field\ opaque\ cannot\ be\ null = for webhooks with type[{0}], the field opaque cannot be null

# at: src/main/java/org/zstack/core/config/GlobalConfigFacadeImpl.java:90
# args: msg.getCategory(),msg.getName()
Unable\ to\ find\ GlobalConfig[category\:\ %s,\ name\:\ %s] = Unable to find GlobalConfig[category: {0}, name: {1}]

# at: src/main/java/org/zstack/core/errorcode/ElaborationManagerImpl.java:77
# args: 
non\ file\ or\ jsoncontent\ input = non file or jsoncontent input

# at: src/main/java/org/zstack/core/errorcode/ElaborationManagerImpl.java:82
# args: 
file\ or\ jsoncontent\ cannot\ both\ nonempty = file or jsoncontent cannot both nonempty

# at: src/main/java/org/zstack/core/errorcode/ElaborationManagerImpl.java:114
# args: e.getMessage()
Unable\ to\ scan\ folder\:\ %s = Unable to scan folder: {0}

# at: src/main/java/org/zstack/core/errorcode/ElaborationManagerImpl.java:118
# args: filename
%s\ is\ not\ existed\ or\ is\ empty\ folder = {0} is not existed or is empty folder

# at: src/main/java/org/zstack/core/errorcode/ElaborationManagerImpl.java:255
# args: 
elaboration\ code\ must\ be\ number! = elaboration code must be number!

# at: src/main/java/org/zstack/core/errorcode/ElaborationManagerImpl.java:328
# args: 
arg\ 'startTime'\ should\ format\ like\ 'yyyy-MM-dd\ HH\:mm\:ss'\ or\ '1545380003000' = arg 'startTime' should format like 'yyyy-MM-dd HH:mm:ss' or '1545380003000'

# at: src/main/java/org/zstack/core/errorcode/ElaborationManagerImpl.java:325
# args: from
%s\ is\ not\ a\ Long\ value\ Number = {0} is not a Long value Number

# at: src/main/java/org/zstack/core/errorcode/ElaborationManagerImpl.java:368
# args: returnValue.get(0).getContent(),returnValue.get(0).getReason()
%s\:\ %s = {0}: {1}

# at: src/main/java/org/zstack/core/errorcode/ElaborationManagerImpl.java:476
# args: 
input\ args\ 'regex'\ or\ 'category'\ must\ be\ set = input args 'regex' or 'category' must be set

# at: src/main/java/org/zstack/core/externalservice/ExternalServiceManagerImpl.java:17
# args: service.getName()
service[%s]\ has\ been\ registered = service[{0}] has been registered

# at: src/main/java/org/zstack/core/gc/GarbageCollectorManagerImpl.java:244
# args: vo.getUuid(),vo.getName()
cannot\ trigger\ a\ finished\ GC\ job[uuid\:%s,\ name\:%s] = cannot trigger a finished GC job[uuid:{0}, name:{1}]

# at: src/main/java/org/zstack/core/progress/ProgressApiInterceptor.java:38
# args: msg.getApiId()
parameter\ apiId[%s]\ is\ not\ a\ valid\ uuid. = parameter apiId[{0}] is not a valid uuid.

# at: src/main/java/org/zstack/core/rest/RESTFacadeImpl.java:526
# args: method.toString().toLowerCase(),url,rsp.getStatusCode(),rsp.getBody()
failed\ to\ %s\ to\ %s,\ status\ code\:\ %s,\ response\ body\:\ %s = failed to {0} to {1}, status code: {2}, response body: {3}

# at: src/main/java/org/zstack/core/rest/RESTFacadeImpl.java:513
# args: method.toString().toLowerCase(),url,e.getMessage()
failed\ to\ %s\ to\ %s,\ IO\ Error\:\ %s = failed to {0} to {1}, IO Error: {2}

# at: src/main/java/org/zstack/core/rest/RESTFacadeImpl.java:569
# args: url,finalTimeout
unable\ to\ echo\ %s\ in\ %sms = unable to echo {0} in {1}ms

# at: src/main/java/org/zstack/core/retry/Retry.java:102
# args: __name__,times,interval
an\ operation[%s]\ fails\ after\ retrying\ %s\ times\ with\ the\ interval\ %s\ seconds = an operation[{0}] fails after retrying {1} times with the interval {2} seconds

# at: src/main/java/org/zstack/core/salt/SaltRunner.java:296
# args: stateName,targetIp,retry
failed\ to\ run\ salt\ state[%s]\ on\ system[%s],\ failed\ after\ %s\ retries = failed to run salt state[{0}] on system[{1}], failed after {2} retries

# at: src/main/java/org/zstack/core/salt/SaltSetupMinionJob.java:84
# args: targetIp
scp\ is\ not\ found\ on\ system[%s],\ unable\ to\ setup\ salt = scp is not found on system[{0}], unable to setup salt

# at: src/main/java/org/zstack/core/timeout/ApiTimeoutManagerImpl.java:81
# args: ApiTimeoutGlobalProperty.MINIMAL_TIMEOUT
api\ timeout\ cannot\ be\ set\ smaller\ than\ %s = api timeout cannot be set smaller than {0}

# at: src/main/java/org/zstack/core/webhook/WebhookApiInterceptor.java:28
# args: url
Invalid\ url[%s] = Invalid url[{0}]

# at: src/main/java/org/zstack/daho/core/DahoApiInterceptor.java:99
# args: 
parameters\ [accountUuid]\ only\ can\ be\ used\ by\ admin\ user! = parameters [accountUuid] only can be used by admin user!

# at: src/main/java/org/zstack/daho/core/DahoApiInterceptor.java:54
# args: msg.getExpirePolicy()
expire\ policy\:\ %s\ is\ not\ valid = expire policy: {0} is not valid

# at: src/main/java/org/zstack/daho/core/DahoApiInterceptor.java:57
# args: msg.getVlan()
vlanId[%s]\ has\ been\ existed! = vlanId[{0}] has been existed!

# at: src/main/java/org/zstack/daho/core/DahoSdkImpl.java:129
# args: 
create\ daho\ vll\ task\ failed! = create daho vll task failed!

# at: src/main/java/org/zstack/daho/core/DahoSdkImpl.java:170
# args: msg.getAccountUuid()
no\ aliyun\ account\ found\ for\ accountUuid\:\ %s = no aliyun account found for accountUuid: {0}

# at: src/main/java/org/zstack/drs/DRSBase.java:201
# args: 
Advice\ not\ allowed\ while\ scheduling = Advice not allowed while scheduling

# at: src/main/java/org/zstack/drs/DRSBase.java:264
# args: 
delete\ DRS\ is\ not\ allowed\ while\ the\ vm\ is\ being\ migrated = delete DRS is not allowed while the vm is being migrated

# at: src/main/java/org/zstack/drs/DRSBase.java:324
# args: 
Scheduling\ is\ not\ allowed\ while\ the\ vm\ is\ being\ migrated = Scheduling is not allowed while the vm is being migrated

# at: src/main/java/org/zstack/drs/DRSBase.java:435
# args: 
Lack\ of\ host\ CPU,\ memory\ monitoring\ data = Lack of host CPU, memory monitoring data

# at: src/main/java/org/zstack/drs/DRSInterceptor.java:55
# args: msg.getClusterUuid()
The\ cluster[%s]\ has\ created\ DRS = The cluster[{0}] has created DRS

# at: src/main/java/org/zstack/drs/DRSInterceptor.java:59
# args: 
DRS\ is\ disabled = DRS is disabled

# at: src/main/java/org/zstack/drs/DRSInterceptor.java:64
# args: 
thresholds\ can\ not\ be\ empty = thresholds can not be empty

# at: src/main/java/org/zstack/drs/DRSInterceptor.java:73
# args: threshold.getThresholdName()
illegal\ thresholdName[%s] = illegal thresholdName[{0}]

# at: src/main/java/org/zstack/drs/DRSInterceptor.java:77
# args: threshold.getOperator()
illegal\ threshold\ operator[%s] = illegal threshold operator[{0}]

# at: src/main/java/org/zstack/drs/DRSInterceptor.java:81
# args: 
thresholdValue\ can\ not\ be\ empty = thresholdValue can not be empty

# at: src/main/java/org/zstack/drs/DRSInterceptor.java:86
# args: 
illegal\ thresholdValue,\ valid\ range\:\ (0,\ 100] = illegal thresholdValue, valid range: (0, 100]

# at: src/main/java/org/zstack/drs/DRSInterceptor.java:103
# args: 
GlobalConfig\ ENABLE_DRS\ is\ closed = GlobalConfig ENABLE_DRS is closed

# at: src/main/java/org/zstack/drs/DRSInterceptor.java:107
# args: msg.getUuid(),vo.getState().toString()
The\ DRS[%s]\ state\ is\ %s = The DRS[{0}] state is {1}

# at: src/main/java/org/zstack/drs/DRSInterceptor.java:122
# args: adviceVO.getDrsUuid()
The\ DRS[%s]\ automation\ level\ is\ not\ manual = The DRS[{0}] automation level is not manual

# at: src/main/java/org/zstack/drs/DRSInterceptor.java:136
# args: msg.getAdviceUuid()
advice[%s]\ has\ expired = advice[{0}] has expired

# at: src/main/java/org/zstack/drs/DRSInterceptor.java:145
# args: 
Successfully\ executed,\ no\ repeated\ executions\ allowed = Successfully executed, no repeated executions allowed

# at: src/main/java/org/zstack/drs/DRSInterceptor.java:152
# args: adviceVO.getVmUuid()
The\ vm[%s]\ has\ been\ deleted = The vm[{0}] has been deleted

# at: src/main/java/org/zstack/drs/DRSInterceptor.java:155
# args: adviceVO.getVmUuid()
The\ vm[%s]\ state\ is\ not\ running = The vm[{0}] state is not running

# at: src/main/java/org/zstack/drs/DRSInterceptor.java:158
# args: adviceVO.getVmUuid(),adviceVO.getVmSourceHostUuid()
The\ vm[%s]\ is\ no\ longer\ on\ the\ source\ host[%s] = The vm[{0}] is no longer on the source host[{1}]

# at: src/main/java/org/zstack/drs/DRSManagerImpl.java:242
# args: msg.getClusterUuid()
The\ cluster[%s]\ does\ not\ support\ DRS. = The cluster[{0}] does not support DRS.

# at: src/main/java/org/zstack/drs/DRSManagerImpl.java:258
# args: reasons
Can\ not\ create\ DRS,\ %s = Can not create DRS, {0}

# at: src/main/java/org/zstack/drs/DRSManagerImpl.java:290
# args: 
hostUuids\ is\ empty = hostUuids is empty

# at: src/main/java/org/zstack/drs/DRSManagerImpl.java:297
# args: 
query\ hosts\ utilization\ data\ failed = query hosts utilization data failed

# at: src/main/java/org/zstack/externalservice/cronjob/CronJobImpl.java:54
# args: 
crond\ is\ not\ running = crond is not running

# at: src/main/java/org/zstack/flowMeter/FlowMeterApiInterceptor.java:55
# args: msg.getvRouterUuid()
All\ the\ networks\ should\ be\ in\ the\ virtual\ router[%s] = All the networks should be in the virtual router[{0}]

# at: src/main/java/org/zstack/flowMeter/FlowMeterApiInterceptor.java:63
# args: vo.getL3NetworkUuid(),vo.getFlowMeterUuid()
The\ network[%s]\ have\ been\ added\ into\ the\ flow\ meter[%s] = The network[{0}] have been added into the flow meter[{1}]

# at: src/main/java/org/zstack/flowMeter/FlowMeterApiInterceptor.java:71
# args: 
The\ virtual\ router\ have\ been\ added\ into\ other\ flow\ meter = The virtual router have been added into other flow meter

# at: src/main/java/org/zstack/flowMeter/FlowMeterApiInterceptor.java:77
# args: msg.getVersion(),FlowMeterConstants.TYPE.NetFlow.toString()
invalid\ type\ parameter\ is\ %s\ and\ should\ be\ in\ %s = invalid type parameter is {0} and should be in {1}

# at: src/main/java/org/zstack/flowMeter/FlowMeterApiInterceptor.java:154
# args: msg.getServer()
[%s]\ is\ not\ formatted\ as\ IP\ address = [{0}] is not formatted as IP address

# at: src/main/java/org/zstack/flowMeter/FlowMeterApiInterceptor.java:143
# args: collector.getUuid()
Collector\ duplicate\ with\ %s = Collector duplicate with {0}

# at: src/main/java/org/zstack/flowMeter/FlowMeterApiInterceptor.java:164
# args: collectorVO.getFlowMeterUuid()
FlowMeter[%s]\ doesn't\ exist = FlowMeter[{0}] doesn't exist

# at: src/main/java/org/zstack/flowMeter/FlowMeterApiInterceptor.java:168
# args: collectorVO.getFlowMeterUuid(),vo.getVersion().toString()
FlowMeter[%s]\ IPv6\ doesn't\ support\ version[%s] = FlowMeter[{0}] IPv6 doesn't support version[{1}]

# at: src/main/java/org/zstack/flowMeter/FlowMeterApiInterceptor.java:150
# args: 
no\ specify\ parameter = no specify parameter

# at: src/main/java/org/zstack/flowMeter/FlowMeterApiInterceptor.java:159
# args: msg.getUuid()
Flow\ collector[%s]\ doesn't\ exist = Flow collector[{0}] doesn't exist

# at: src/main/java/org/zstack/flowMeter/FlowMeterApiInterceptor.java:183
# args: server,port,collector.getUuid()
Collector\ [%s\ %d]\ duplicate\ with\ %s = Collector [{0} {1}] duplicate with {2}

# at: src/main/java/org/zstack/flowMeter/FlowMeterManagerImpl.java:148
# args: FlowMeterSystemTags.FLOW_EXPIRE_INTERVAL_TOKEN
%s\ must\ be\ a\ number = {0} must be a number

# at: src/main/java/org/zstack/guesttools/GuestToolsApiInterceptor.java:43
# args: msg.getUuid()
cannot\ get\ latest\ guest-tools\ for\ vm[uuid\:%s]\ because\ it's\ hypervisor\ type\ is\ not\ supported = cannot get latest guest-tools for vm[uuid:{0}] because it's hypervisor type is not supported

# at: src/main/java/org/zstack/guesttools/GuestToolsApiInterceptor.java:50
# args: msg.getUuid()
cannot\ get\ latest\ guest-tools\ for\ vm[uuid\:%s]\ because\ it's\ not\ running = cannot get latest guest-tools for vm[uuid:{0}] because it's not running

# at: src/main/java/org/zstack/guesttools/GuestToolsApiInterceptor.java:57
# args: msg.getUuid()
cannot\ get\ latest\ guest-tools\ for\ vm[uuid\:%s]\ because\ it's\ not\ user\ vm = cannot get latest guest-tools for vm[uuid:{0}] because it's not user vm

# at: src/main/java/org/zstack/guesttools/GuestToolsApiInterceptor.java:67
# args: msg.getUuid()
cannot\ attach\ guest-tools\ iso\ to\ vm[uuid\:%s]\ because\ it's\ hypervisor\ type\ is\ not\ supported = cannot attach guest-tools iso to vm[uuid:{0}] because it's hypervisor type is not supported

# at: src/main/java/org/zstack/guesttools/GuestToolsApiInterceptor.java:74
# args: msg.getUuid()
cannot\ attach\ guest-tools\ iso\ to\ vm[uuid\:%s]\ because\ it's\ not\ running = cannot attach guest-tools iso to vm[uuid:{0}] because it's not running

# at: src/main/java/org/zstack/guesttools/GuestToolsApiInterceptor.java:81
# args: msg.getUuid()
cannot\ attach\ guest-tools\ iso\ to\ vm[uuid\:%s]\ because\ it's\ not\ user\ vm = cannot attach guest-tools iso to vm[uuid:{0}] because it's not user vm

# at: src/main/java/org/zstack/guesttools/GuestToolsApiInterceptor.java:88
# args: msg.getUuid()
cannot\ attach\ guest-tools\ iso\ to\ vm[uuid\:%s]\ because\ it\ has\ no\ cdrom = cannot attach guest-tools iso to vm[uuid:{0}] because it has no cdrom

# at: src/main/java/org/zstack/guesttools/GuestToolsApiInterceptor.java:98
# args: msg.getUuid()
cannot\ attach\ guest-tools\ iso\ to\ vm[uuid\:%s]\ because\ it\ has\ VirtioSCSI\ data\ volume\ attached = cannot attach guest-tools iso to vm[uuid:{0}] because it has VirtioSCSI data volume attached

# at: src/main/java/org/zstack/guesttools/GuestToolsApiInterceptor.java:109
# args: msg.getUuid()
cannot\ get\ guest-tools\ info\ from\ vm[uuid\:%s]\ because\ it's\ hypervisor\ type\ is\ not\ supported = cannot get guest-tools info from vm[uuid:{0}] because it's hypervisor type is not supported

# at: src/main/java/org/zstack/guesttools/GuestToolsApiInterceptor.java:116
# args: msg.getUuid()
cannot\ get\ guest-tools\ info\ from\ vm[uuid\:%s]\ because\ it's\ not\ running = cannot get guest-tools info from vm[uuid:{0}] because it's not running

# at: src/main/java/org/zstack/guesttools/GuestToolsApiInterceptor.java:123
# args: msg.getUuid()
cannot\ get\ guest-tools\ info\ from\ vm[uuid\:%s]\ because\ it's\ not\ user\ vm = cannot get guest-tools info from vm[uuid:{0}] because it's not user vm

# at: src/main/java/org/zstack/guesttools/GuestToolsManagerImpl.java:243
# args: Platform.getManagementServerId(),msg.getHostUuid()
no\ proper\ guest\ tools\ iso\ found\ in\ management\ node[uuid\:%s]\ for\ host[uuid\:%s] = no proper guest tools iso found in management node[uuid:{0}] for host[uuid:{1}]

# at: src/main/java/org/zstack/guesttools/kvm/GuestToolsForLinuxOnKvmBackend.java:93
# args: vm.getUuid()
The\ vmInstance\ [uuid]\ zwatch\ agent\ version\ was\ not\ found = The vmInstance [uuid] zwatch agent version was not found

# at: src/main/java/org/zstack/guesttools/kvm/GuestToolsForWindowsOnKvmBackend.java:59
# args: host.getUuid()
failed\ to\ download\ guest\ tools\ iso\ because\ no\ kvm\ host[uuid\:%s]\ found = failed to download guest tools iso because no kvm host[uuid:{0}] found

# at: src/main/java/org/zstack/guesttools/kvm/GuestToolsForWindowsOnKvmBackend.java:127
# args: vm.getUuid(),rsp.getError()
failed\ to\ attach\ guest\ tools\ iso\ to\ vm[uuid\:%s],\ because\:%s = failed to attach guest tools iso to vm[uuid:{0}], because:{1}

# at: src/main/java/org/zstack/guesttools/kvm/GuestToolsForWindowsOnKvmBackend.java:160
# args: vm.getUuid(),rsp.getError()
failed\ to\ get\ guest\ tools\ info\ from\ vm[uuid\:%s],\ because\:%s = failed to get guest tools info from vm[uuid:{0}], because:{1}

# at: src/main/java/org/zstack/ha/HaKvmHostSiblingChecker.java:236
# args: struct.getHostUuid(),struct.getHostIp(),errors
hosts\ failed\ to\ port\ scan\ the\ failure\ host[uuid\:%s,\ ip\:%s],\ errors\ are\ %s = hosts failed to port scan the failure host[uuid:{0}, ip:{1}], errors are {2}

# at: src/main/java/org/zstack/ha/HaKvmWorker.java:88
# args: checkers.indexOf(checker) + 1,checkers.size(),checker.getClass().getSimpleName(),s.getSuccessTimes() * s.getSuccessInterval()
(%d/%d)\ start\ HaHostChecker\ %s\:\ predict\ time\ is\ [%d]\ seconds = ({0}/{1}) start HaHostChecker {2}: predict time is [{3}] seconds

# at: src/main/java/org/zstack/ha/HaKvmWorker.java:144
# args: self.getName(),self.getUuid()
cannot\ find\ the\ host\ of\ the\ vm[name\:%s,\ uuid\:%s],\ hostUuid\ is\ null = cannot find the host of the vm[name:{0}, uuid:{1}], hostUuid is null

# at: src/main/java/org/zstack/ha/HaKvmWorker.java:151
# args: 
no\ HaHostChecker\ found,\ cannot\ do\ HA = no HaHostChecker found, cannot do HA

# at: src/main/java/org/zstack/ha/HaKvmWorker.java:158
# args: self.getUuid()
can\ not\ ha\ because\ device\ still\ attached\ to\ vm[%s] = can not ha because device still attached to vm[{0}]

# at: src/main/java/org/zstack/ha/HaManagementNodeChecker.java:99
# args: 
the\ management\ node\ fails\ to\ scan\ the\ host = the management node fails to scan the host

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:1363
# args: vmUuid
the\ VM[uuid\:%s]\ volume\ stored\ location\ primary\ storage\ is\ in\ a\ state\ of\ maintenance = the VM[uuid:{0}] volume stored location primary storage is in a state of maintenance

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:232
# args: newValue
the\ value[%s]\ is\ lesser\ than\ 0 = the value[{0}] is lesser than 0

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:247
# args: hostUuids,HostStatus.Connected
host[uuid\:%s]\ is\ not\ %s,\ but\ still\ have\ vm\ on\ it,\ please\ resolve\ hosts'\ problems\ before\ enable\ ha = host[uuid:{0}] is not {1}, but still have vm on it, please resolve hosts' problems before enable ha

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:255
# args: hostUuids,HostStatus.Connected
host[uuid\:%s]\ is\ not\ %s,\ but\ still\ have\ vm\ on\ it,\ please\ resolve\ hosts'\ problems\ before\ update\ fencer\ strategy = host[uuid:{0}] is not {1}, but still have vm on it, please resolve hosts' problems before update fencer strategy

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:472
# args: 
there\ is\ already\ a\ HA\ GC\ job\ for\ the\ VM,\ wait\ it\ to\ run = there is already a HA GC job for the VM, wait it to run

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:480
# args: HaGlobalConfig.NEVER_STOP_VM_FAILURE_RETRY_DELAY.value(Long.class)
A\ GC\ job\ is\ submitted\ to\ HA\ the\ VM[retry\ delay\:\ %s\ seconds] = A GC job is submitted to HA the VM[retry delay: {0} seconds]

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:998
# args: 
HA\ is\ successfully\ completed = HA is successfully completed

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:1006
# args: 
Failed\ to\ HA\ the\ VM = Failed to HA the VM

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:908
# args: 
vm\ stopped\ unexpectedly,\ double\ check\ state = vm stopped unexpectedly, double check state

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:917
# args: vmUuid,hostUuid
cannot\ determine\ VM[%s]\ status\ on\ host[%s],\ try\ to\ start\ it = cannot determine VM[{0}] status on host[{1}], try to start it

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:1112
# args: 
vm\ state\ is\ stopped,\ try\ to\ start\ it = vm state is stopped, try to start it

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:934
# args: vmUuid,hostUuid
VM[%s]\ is\ running\ on\ host[%s] = VM[{0}] is running on host[{1}]

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:947
# args: vmUuid,hostUuid
VM[%s]\ is\ paused\ on\ host[%s] = VM[{0}] is paused on host[{1}]

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:975
# args: vm.getHypervisorType()
the\ hypervisor[%s]\ does\ not\ support\ VM\ HA = the hypervisor[{0}] does not support VM HA

# at: src/main/java/org/zstack/ha/HostCheckResult.java:49
# args: ratio,threshold,hostUuid,errors
[HA\ Worker]\:\ the\ success\ ratio[%s]\ below\ the\ threshold[%s],\ the\ host[uuid\:%s]\ is\ judged\ as\ dead,\ errors\ are\ %s.\ Start\ HA\ all\ the\ vms\ on\ this\ host\ before = [HA Worker]: the success ratio[{0}] below the threshold[{1}], the host[uuid:{2}] is judged as dead, errors are {3}. Start HA all the vms on this host before

# at: src/main/java/org/zstack/ha/HostCheckResult.java:46
# args: ratio,threshold
[HA\ worker]\:\ all\ host\ checkers\ are\ finished\ and\ the\ success\ ratio\ is\ %s\ that\ is\ greater\ than\ the\ threshold[%s];\ no\ HA\ need\ for\ the\ vms\ on\ this\ host\ before.\ Please\ wait\ for\ the\ host\ reconnected = [HA worker]: all host checkers are finished and the success ratio is {0} that is greater than the threshold[{1}]; no HA need for the vms on this host before. Please wait for the host reconnected

# at: src/main/java/org/zstack/ha/NeverStopVmGC.java:89
# args: 
Failed\ to\ start\ the\ NeverStop\ VM = Failed to start the NeverStop VM

# at: src/main/java/org/zstack/ha/NeverStopVmGC.java:80
# args: 
VM\ is\ started\ successfully = VM is started successfully

# at: src/main/java/org/zstack/ha/NeverStopVmGC.java:74
# args: 
VM\ state\ is\ not\ running,\ try\ to\ start\ it = VM state is not running, try to start it

# at: src/main/java/org/zstack/hybrid/account/HybridAccountApiInterceptor.java:45
# args: type
keyType\ not\ supported\ type\ [%s] = keyType not supported type [{0}]

# at: src/main/java/org/zstack/hybrid/account/HybridAccountApiInterceptor.java:85
# args: msg.getKey(),accountUuid
key\:\ [%s]\ already\ existed\ by\ accountUuid\:\ [%s] = key: [{0}] already existed by accountUuid: [{1}]

# at: src/main/java/org/zstack/hybrid/datacenter/DataCenterApiInterceptor.java:63
# args: msg.getRegionId(),ak
regionId\ [%s]\ already\ created\ by\ ak\ [%s] = regionId [{0}] already created by ak [{1}]

# at: src/main/java/org/zstack/hybrid/datacenter/DataCenterApiInterceptor.java:46
# args: type
dcType\ not\ supported\ type\ [%s] = dcType not supported type [{0}]

# at: src/main/java/org/zstack/hybrid/datacenter/DataCenterManagerImpl.java:96
# args: msg.getUuid()
DataCenter\ [%s]\ is\ still\ in\ sync\ progress,\ please\ wait. = DataCenter [{0}] is still in sync progress, please wait.

# at: src/main/java/org/zstack/hybrid/identityzone/IdentityZoneApiInterceptor.java:55
# args: msg.getZoneId(),izo.getUuid()
identity\ zone\ [%s]\ already\ existed,\ uuid\ is\:\ %s = identity zone [{0}] already existed, uuid is: {1}

# at: src/main/java/org/zstack/hybrid/identityzone/IdentityZoneApiInterceptor.java:72
# args: type,dvo.getDcType().toString()
type\ [%s]\ is\ not\ matched\ datacenter\ type\ [%s] = type [{0}] is not matched datacenter type [{1}]

# at: src/main/java/org/zstack/hybrid/identityzone/IdentityZoneApiInterceptor.java:82
# args: 
either\ dataCenterUuid\ or\ regionId\ should\ be\ set,\ please\ check\ the\ parameters. = either dataCenterUuid or regionId should be set, please check the parameters.

# at: src/main/java/org/zstack/hybrid/identityzone/IdentityZoneManagerImpl.java:111
# args: msg.getUuid()
IdentityZone\ [%s]\ is\ still\ in\ sync\ progress,\ please\ wait. = IdentityZone [{0}] is still in sync progress, please wait.

# at: src/main/java/org/zstack/hybrid/network/HybridEipCascadeExtension.java:88
# args: 
EcsInstance\ must\ be\ running\ or\ stopped\ while\ deleting\ eip\  = EcsInstance must be running or stopped while deleting eip 

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:86
# args: vbri.getUuid(),vbri.getDataCenterUuid(),vrouteri.getUuid(),vrouteri.getDataCenterUuid()
router\ interface\ must\ be\ in\ the\ same\ datacenter,\ but\ ri[%s]\ is\ in\ dc[%s]\ and\ ri[%s]\ is\ in\ dc[%s] = router interface must be in the same datacenter, but ri[{0}] is in dc[{1}] and ri[{2}] is in dc[{3}]

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:96
# args: vrouteri.getUuid(),vrouteri.getStatus()
router\ interface[%s]\ status\ is\ not\ idle,\ it\ is\ %s = router interface[{0}] status is not idle, it is {1}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:104
# args: vrouteri.getUuid(),vrouteri.getOppositeInterfaceUuid()
router\ interface[%s]\ already\ has\ a\ connection,\ it\ is\ %s = router interface[{0}] already has a connection, it is {1}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:112
# args: 
accessPointUuid\ cannot\ be\ null\ if\ the\ router\ interface\ on\ VBR\ type\ router = accessPointUuid cannot be null if the router interface on VBR type router

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:186
# args: 
cannot\ delete\ system\ entry = cannot delete system entry

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:192
# args: 
only\ support\ intranet\ rule\ in\ vpc = only support intranet rule in vpc

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:197
# args: msg.getCidr()
%s\ is\ not\ a\ valid\ cidr = {0} is not a valid cidr

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:207
# args: 
security\ group\ rule\ already\ existed = security group rule already existed

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:213
# args: msg.getDstCidrBlock()
dstCidrBlock[%s]\ is\ not\ a\ valid\ cidr = dstCidrBlock[{0}] is not a valid cidr

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:242
# args: msg.getNextHopType()
next\ hop\ type\ [%s]\ not\ supported\ create\ route\ entry\ now! = next hop type [{0}] not supported create route entry now!

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:238
# args: msg.getNextHopUuid()
no\ such\ vpn\ gateway\:\ %s = no such vpn gateway: {0}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:227
# args: rivo.getvRouterType().toString(),msg.getvRouterType()
nexthop\ routerInterface\ belongs\ to\ %s,\ but\ the\ entry\ belongs\ to\ %s = nexthop routerInterface belongs to {0}, but the entry belongs to {1}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:220
# args: msg.getNextHopUuid()
no\ such\ ecs\ instance\:\ %s = no such ecs instance: {0}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:252
# args: 
virtual\ border\ router\ only\ support\ routerinterface\ as\ next\ hop\ type = virtual border router only support routerinterface as next hop type

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:272
# args: msg.getCidrBlock(),vpcCidr
vswitch's\ cidr\ [%s]\ not\ in\ the\ vpc's\ [%s] = vswitch's cidr [{0}] not in the vpc's [{1}]

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:279
# args: old.getUuid()
cidr\ is\ overlap\ by\ another\ vswitch\:\ %s = cidr is overlap by another vswitch: {0}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:292
# args: msg.getCidrBlock()
invalid\ CidrBlock\:\ %s,\ which\ must\ subnet\ in\ '10.0.0.0/8',\ '172.16.0.0/12',\ '192.168.0.0/16' = invalid CidrBlock: {0}, which must subnet in '10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16'

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:308
# args: msg.getvRouterUuid()
no\ such\ virtual\ router\:\ %s = no such virtual router: {0}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:303
# args: msg.getvRouterUuid()
no\ such\ virtual\ border\ router\:\ %s = no such virtual border router: {0}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:315
# args: msg.getLocalGatewayIp()
localGateway\ is\ not\ IPv4\:\ %s = localGateway is not IPv4: {0}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:318
# args: msg.getPeerGatewayIp()
peerGateway\ is\ not\ IPv4\:\ %s = peerGateway is not IPv4: {0}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:321
# args: msg.getPeeringSubnetMask()
peerGateway\ is\ not\ subnet\ mask\:\ %s = peerGateway is not subnet mask: {0}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:325
# args: msg.getVlanId()
vlanId\ is\ not\ number\:\ %s = vlanId is not number: {0}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:335
# args: msg.getEcsUuid(),msg.getEipUuid(),hevo.getAllocateResourceUuid()
couldn't\ attach\ eip\ to\ ecs\:\ [%s]\ ,\ eip\ \:[%s]\ already\ attached\ ecs\:[%s]\  = couldn't attach eip to ecs: [{0}] , eip :[{1}] already attached ecs:[{2}] 

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:340
# args: msg.getEcsUuid()
ecs\ [%s]\ already\ has\ public\ ip\ now = ecs [{0}] already has public ip now

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:346
# args: msg.getEipUuid(),msg.getEcsUuid()
couldn't\ attach\ eip\ [%s]\ to\ ecs\:\ [%s]\ ,\ ecs\ is\ already\ attached = couldn't attach eip [{0}] to ecs: [{1}] , ecs is already attached

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:353
# args: msg.getEipUuid(),msg.getEcsUuid()
eip[%s]\ and\ ecs[%s]\ should\ be\ in\ the\ same\ dataCenter\  = eip[{0}] and ecs[{1}] should be in the same dataCenter 

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:362
# args: msg.getEipUuid()
couldn't\ detach\ eip\ \:[%s],\ it\ is\ not\ attached\ on\ any\ instance\  = couldn't detach eip :[{0}], it is not attached on any instance 

# at: src/main/java/org/zstack/hybrid/network/vpn/VpcVpnApiInterceptor.java:45
# args: msg.getId()
%s\ is\ not\ a\ valid\ ipv4\ address = {0} is not a valid ipv4 address

# at: src/main/java/org/zstack/hybrid/network/vpn/VpcVpnApiInterceptor.java:51
# args: 
localCidr\ must\ be\ Cidr! = localCidr must be Cidr!

# at: src/main/java/org/zstack/hybrid/network/vpn/VpcVpnApiInterceptor.java:55
# args: 
remoteCidr\ must\ be\ Cidr! = remoteCidr must be Cidr!

# at: src/main/java/org/zstack/hybrid/network/vpn/VpcVpnApiInterceptor.java:62
# args: 
localCidr\ and\ remoteCidr\ must\ be\ Cidr! = localCidr and remoteCidr must be Cidr!

# at: src/main/java/org/zstack/hybrid/network/vpn/VpcVpnGatewayCascadeExtension.java:80
# args: gateways.get(0).getUuid()
vpngateway\ [%s]\ existed,\ cannot\ delete\ remote = vpngateway [{0}] existed, cannot delete remote

# at: src/main/java/org/zstack/iam2/IAM2AttributeHelper.java:420
# args: vid,msg.getProjectUuid()
virtual\ id[uuid\:%s]\ is\ platform\ user\ can\ not\ be\ added\ to\ project[uuid\:%s] = virtual id[uuid:{0}] is platform user can not be added to project[uuid:{1}]

# at: src/main/java/org/zstack/iam2/IAM2AttributeHelper.java:450
# args: 
Can\ not\ add\ both\ platform\ role\ and\ project\ role\ to\ virtual\ id = Can not add both platform role and project role to virtual id

# at: src/main/java/org/zstack/iam2/IAM2AttributeHelper.java:458
# args: virtualIDUuid
Can\ not\ add\ project\ role\ to\ platform\ virtual\ id[uuid\:%s] = Can not add project role to platform virtual id[uuid:{0}]

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:319
# args: msg.getName()
wrong\ virtual\ ID[name\:%s],\ not\ existing\ or\ wrong\ password = wrong virtual ID[name:{0}], not existing or wrong password

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:326
# args: 
additional\ authentication\ failed = additional authentication failed

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:366
# args: msg.getProjectName()
project[name\:%s]\ not\ existing = project[name:{0}] not existing

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:374
# args: puuid,msg.getProjectName()
no\ account\ found\ for\ project[uuid\:%s,\ name\:%s] = no account found for project[uuid:{0}, name:{1}]

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:380
# args: msg.getSession().getUserUuid()
wrong\ virtual\ ID[uuid\:%s],\ not\ existing\ or\ wrong\ password = wrong virtual ID[uuid:{0}], not existing or wrong password

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:385
# args: vid.getName()
virtual\ ID[name\:%s]\ is\ disabled = virtual ID[name:{0}] is disabled

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:391
# args: vid.getName(),msg.getProjectName()
virtual\ ID[name\:%s]\ not\ belonging\ to\ the\ project[name\:%s] = virtual ID[name:{0}] not belonging to the project[name:{1}]

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:647
# args: results.size()
There\ are\ %d\ problems\ with\ the\ file.\  = There are {0} problems with the file. 

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:664
# args: e.getMessage()
fail\ to\ load\ VirtualID\ info\ from\ file.\ because\n%s = fail to load VirtualID info from file. because\n{0}

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:675
# args: 
name\ cannot\ be\ empty.\  = name cannot be empty. 

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:683
# args: cmsg.getUsername()
userName[%s]\ is\ repeated.\  = userName[{0}] is repeated. 

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:681
# args: cmsg.username.length()
name\ exceeds\ max\ length\ of\ string.\ expected\ was\ <\=\ 255,\ actual\ was\ %s.\  = name exceeds max length of string. expected was <= 255, actual was {0}. 

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:679
# args: 
username\ cannot\ be\ empty.\  = username cannot be empty. 

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:689
# args: cmsg.password.length()
Incorrect\ password\ length.\ expected\ was\ >\=\ 6\ and\ <\=\ 255,\ actual\ was\ %s.\  = Incorrect password length. expected was >= 6 and <= 255, actual was {0}. 

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:687
# args: 
password\ cannot\ be\ empty.\  = password cannot be empty. 

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:697
# args: 
email\ format\ does\ not\ match.\  = email format does not match. 

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:753
# args: noMatchNames
organization[%s]\ is\ not\ exist.\  = organization[{0}] is not exist. 

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:761
# args: repeatNames
organization[%s]\ in\ line\ is\ repeated.\  = organization[{0}] in line is repeated. 

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:769
# args: repeatNames
organization[%s]\ is\ repeated.\  = organization[{0}] is repeated. 

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:799
# args: noMatchName
project[%s]\ is\ not\ exist.\  = project[{0}] is not exist. 

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:963
# args: 
fail\ to\ build\ VirtualID\ info\ from\ file.\  = fail to build VirtualID info from file. 

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:1034
# args: resourceUuid,projectUuid
virtualID[uuid\:%s]\ not\ in\ project[uuid\:%s] = virtualID[uuid:{0}] not in project[uuid:{1}]

# at: src/main/java/org/zstack/iam2/IAM2OrganizationBase.java:86
# args: self.getUuid()
Can\ not\ do\ operations,\ because\ current\ organization[uuid\:%s]\ is\ staled,\ please\ enable\ it = Can not do operations, because current organization[uuid:{0}] is staled, please enable it

# at: src/main/java/org/zstack/iam2/IAM2OrganizationBase.java:192
# args: puuid,self.getUuid()
organization[uuid\:%s]\ is\ parent\ of\ the\ organization[uuid\:%s],\ cannot\ set\ it\ as\ a\ child\ organization = organization[uuid:{0}] is parent of the organization[uuid:{1}], cannot set it as a child organization

# at: src/main/java/org/zstack/iam2/IAM2ProjectBase.java:106
# args: self.getUuid(),self.getName(),self.getState(),msg.getClass()
the\ project[uuid\:\ %s,\ name\:%s]\ is\ in\ state\ of\ %s\ which\ disallows\ the\ operation[%s] = the project[uuid: {0}, name:{1}] is in state of {2} which disallows the operation[{3}]

# at: src/main/java/org/zstack/iam2/IAM2VirtualIDBase.java:132
# args: self.getUuid()
Can\ not\ do\ operations,\ because\ Current\ virtualID[uuid\:%s]\ is\ staled,\ please\ enable\ it = Can not do operations, because Current virtualID[uuid:{0}] is staled, please enable it

# at: src/main/java/org/zstack/iam2/IAM2VirtualIDBase.java:554
# args: 
only\ admin\ and\ the\ virtual\ ID\ itself\ can\ do\ the\ update = only admin and the virtual ID itself can do the update

# at: src/main/java/org/zstack/iam2/IAM2VirtualIDBase.java:558
# args: msg.getVirtualIDUuid()
old\ password\ is\ not\ equal\ to\ the\ original\ password,\ cannot\ update\ the\ password\ of\ virtual\ ID[uuid\:%s] = old password is not equal to the original password, cannot update the password of virtual ID[uuid:{0}]

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:43
# args: attr.getValue()
attribute\ name\ cannot\ be\ null,\ value[%s] = attribute name cannot be null, value[{0}]

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:47
# args: attr.getName()
attribute\ name[%s]\ exceed\ the\ max\ length\ of\ 2048\ chars = attribute name[{0}] exceed the max length of 2048 chars

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:50
# args: attr.getName(),attr.getValue()
attribute[name\:%s]\ value[%s]\ exceed\ the\ max\ length\ of\ 2048\ chars = attribute[name:{0}] value[{1}] exceed the max length of 2048 chars

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:151
# args: 
admin\ is\ a\ reserved\ name,\ please\ use\ another\ name = admin is a reserved name, please use another name

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:159
# args: msg.getName()
invalid\ name[%s],\ there\ has\ been\ a\ project\ or\ account\ with\ the\ same\ name = invalid name[{0}], there has been a project or account with the same name

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:167
# args: msg.getUuid()
attribute[uuid\:%s]\ is\ not\ for\ any\ group = attribute[uuid:{0}] is not for any group

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:175
# args: msg.getUuid()
attribute[uuid\:%s]\ is\ not\ for\ any\ organization = attribute[uuid:{0}] is not for any organization

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:183
# args: msg.getUuid()
attribute[uuid\:%s]\ is\ not\ for\ any\ project = attribute[uuid:{0}] is not for any project

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:191
# args: msg.getUuid()
attribute[uuid\:%s]\ is\ not\ for\ any\ virtual\ ID = attribute[uuid:{0}] is not for any virtual ID

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:211
# args: 
retire\ policy\ must\ be\ deleted\ before\ pull\ the\ project\ out\ of\ Retired\ state = retire policy must be deleted before pull the project out of Retired state

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:223
# args: state
login\ is\ prohibited\ because\ the\ project\ is\ in\ state\ of\ %s = login is prohibited because the project is in state of {0}

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:237
# args: name
no\ quota[name\:%s]\ found = no quota[name:{0}] found

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:261
# args: msg.getUuid()
organization[uuid\:%s]\ is\ a\ Company\ that\ cannot\ have\ parent\ organization = organization[uuid:{0}] is a Company that cannot have parent organization

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:273
# args: msg.getName()
duplicate\ virtualID\ name[%s] = duplicate virtualID name[{0}]

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:291
# args: msg.getName()
duplicate\ project\ name[%s] = duplicate project name[{0}]

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:299
# args: msg.getName()
invalid\ project\ name[%s],\ an\ account\ or\ project\ with\ the\ same\ name\ exists = invalid project name[{0}], an account or project with the same name exists.

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:315
# args: refVO.getProjectUuid(),refVO.getOrganizationUuid()
The\ project[uuid\=%s]\ has\ been\ attached\ to\ the\ organization[uuid\=%s] = The project[uuid={0}] has been attached to the organization[uuid={1}]

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:325
# args: msg.getProjectUuid()
The\ project[uuid\=%s]\ is\ not\ attached = The project[uuid={0}] is not attached

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:336
# args: uuids
organizations%s\ are\ company\ that\ cannot\ be\ children\ of\ other\ organization = organizations{0} are company that cannot be children of other organization

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:398
# args: staleVirtualIDs
can\ not\ operate\ stale\ virtual\ ids\:\ %s = can not operate stale virtual ids: {0}

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:417
# args: wrong,msg.getGroupUuid()
virtual\ ids%s\ not\ in\ the\ project\ the\ group[uuid\:%s]\ belongs\ to = virtual ids{0} not in the project the group[uuid:{1}] belongs to

# at: src/main/java/org/zstack/iam2/attribute/SystemAttributes.java:69
# args: 
attribute[name\:%s]\ is\ a\ system\ attribute\ that\ cannot\ be\ updated = attribute[name:{0}] is a system attribute that cannot be updated

# at: src/main/java/org/zstack/iam2/attribute/organization/OrganizationSupervisor.java:37
# args: inv.getValue()
virtual\ ID[uuid\:%s]\ not\ existing = virtual ID[uuid:{0}] not existing

# at: src/main/java/org/zstack/iam2/attribute/organization/OrganizationSupervisor.java:44
# args: inv.getValue(),((IAM2OrganizationAttributeInventory) inv).getOrganizationUuid()
virtual\ ID[uuid\:%s]\ not\ in\ organization[uuid\:%s] = virtual ID[uuid:{0}] not in organization[uuid:{1}]

# at: src/main/java/org/zstack/iam2/attribute/organization/OrganizationSupervisor.java:49
# args: oinv.getOrganizationUuid()
organization[uuid\:%s]\ already\ has\ a\ supervisor = organization[uuid:{0}] already has a supervisor

# at: src/main/java/org/zstack/iam2/attribute/project/Retire.java:65
# args: pinv.getUuid(),pinv.getName()
the\ project[uuid\:%s,\ name\:%s]\ already\ has\ a\ retire\ policy = the project[uuid:{0}, name:{1}] already has a retire policy

# at: src/main/java/org/zstack/iam2/attribute/project/RetirePolicy.java:52
# args: 
invalid\ value,\ no\ 'at',\ 'after'\ or\ 'exceed'\ found = invalid value, no 'at', 'after' or 'exceed' found

# at: src/main/java/org/zstack/iam2/attribute/project/RetirePolicy.java:57
# args: value
invalid\ value,\ %s = invalid value, {0}

# at: src/main/java/org/zstack/iam2/attribute/project/RetirePolicy.java:63
# args: ss[0],Means.values()
invalid\ means[%s],\ allowed\ means\ are\ %s = invalid means[{0}], allowed means are {1}

# at: src/main/java/org/zstack/iam2/attribute/project/RetirePolicy.java:98
# args: policyValue
invalid\ spending\ value[%s],\ it\ should\ be\ in\ format\ of\ for\ example\ 10.001 = invalid spending value[{0}], it should be in format of for example 10.001

# at: src/main/java/org/zstack/iam2/attribute/project/RetirePolicy.java:92
# args: policyValue,Double.MAX_VALUE
invalid\ spending\ value[%s],\ spending\ value\ should\ between\ 0\ and\ %f = invalid spending value[{0}], spending value should between 0 and {1}

# at: src/main/java/org/zstack/iam2/attribute/project/RetirePolicy.java:85
# args: policyValue
invalid\ time[%s],\ it\ should\ be\ in\ format\ of\ for\ example\ 10m,\ 1h,\ 2d = invalid time[{0}], it should be in format of for example 10m, 1h, 2d

# at: src/main/java/org/zstack/iam2/attribute/project/RetirePolicy.java:76
# args: policyValue
invalid\ date[%s],\ it\ should\ be\ in\ format\ of\ yyyy-MM-dd\ HH\:mm\:ss = invalid date[{0}], it should be in format of yyyy-MM-dd HH:mm:ss

# at: src/main/java/org/zstack/iam2/attribute/project/RetirePolicy.java:105
# args: policyValue,dateFormat.format(new Timestamp(System.currentTimeMillis()))
invalid\ date\ or\ time[%s],\ it\ cannot\ be\ before\ current\ time[%s] = invalid date or time[{0}], it cannot be before current time[{1}]

# at: src/main/java/org/zstack/iam2/attribute/virtualid/AbstractAdminAttribute.java:17
# args: vid,attributeName
virtual\ ID[uuid\:%s]\ already\ has\ admin\ related\ attributes,\ can\ not\ add\ %s = virtual ID[uuid:{0}] already has admin related attributes, can not add {1}

# at: src/main/java/org/zstack/iam2/attribute/virtualid/IAM2ProjectOperator.java:35
# args: idinv.getVirtualIDUuid()
virtual\ id[uuid\:%s]\ already\ has\ a\ project\ operator\ attribute = virtual id[uuid:{0}] already has a project operator attribute

# at: src/main/java/org/zstack/iam2/attribute/virtualid/PlatformAdminZoneRelation.java:36
# args: inv.getValue()
cannot\ find\ zone[uuid\:%s] = cannot find zone[uuid:{0}]

# at: src/main/java/org/zstack/iam2/attribute/virtualid/ProjectAdmin.java:71
# args: inv.getValue()
project[uuid\:%s]\ already\ has\ a\ project\ admin = project[uuid:{0}] already has a project admin

# at: src/main/java/org/zstack/iam2/attribute/virtualid/ProjectAdmin.java:83
# args: inv.getValue()
project[uuid\:%s]\ not\ existing = project[uuid:{0}] not existing

# at: src/main/java/org/zstack/iam2/rbac/IAM2AuthorizationBackend.java:130
# args: deniedApis
the\ operations[%s]\ is\ denied = the operations[{0}] is denied

# at: src/main/java/org/zstack/iam2/rbac/IAM2SessionAPIRequestChecker.java:28
# args: session.getAccountUuid()
project\ of\ account[uuid\:%s]\ not\ exists = project of account[uuid:{0}] not exists

# at: src/main/java/org/zstack/iam2/rbac/IAM2SessionAPIRequestChecker.java:37
# args: projectUuid
project[uuid\:%s]\ is\ retired,\ reject\ all\ operations = project[uuid:{0}] is retired, reject all operations

# at: src/main/java/org/zstack/iam2/IAM2QuotaChangeChecker.java:112
# args: quota.getName(),quota.getIdentityUuid(),updatedValue,organizationUuid
the\ quota[name\:%s]\ of\ Account[uuid\:%s]\ can\ not\ be\ %d,\ otherwise\ it\ will\ exceeds\ the\ quota\ of\ organization[uuid\:%s] = the quota[{0}] of Account[uuid:{1}] can not be {2}, otherwise it will exceeds the quota of organization[uuid:{3}]

# at: src/main/java/org/zstack/identity/AccountBase.java:323
# args: group.getUuid(),msg.getAccountUuid()
the\ user\ group[uuid\:%s]\ does\ not\ belong\ to\ the\ account[uuid\:%s] = the user group[uuid:{0}] does not belong to the account[uuid:{1}]

# at: src/main/java/org/zstack/identity/AccountBase.java:425
# args: msg.getName(),msg.getIdentityUuid()
cannot\ find\ Quota[name\:\ %s]\ for\ the\ account[uuid\:\ %s] = cannot find Quota[name: {0}] for the account[uuid: {1}]

# at: src/main/java/org/zstack/identity/AccountBase.java:504
# args: self.getUuid(),ruuid
the\ account[uuid\:\ %s]\ doesn't\ have\ a\ resource[uuid\:\ %s] = the account[uuid: {0}] doesn't have a resource[uuid: {1}]

# at: src/main/java/org/zstack/identity/AccountBase.java:561
# args: user.getUuid(),msg.getAccountUuid()
the\ user[uuid\:%s]\ does\ not\ belong\ to\ the\ account[uuid\:%s] = the user[uuid:{0}] does not belong to the account[uuid:{1}]

# at: src/main/java/org/zstack/identity/AccountBase.java:566
# args: user.getUuid()
old\ password\ is\ not\ equal\ to\ the\ original\ password,\ cannot\ update\ the\ password\ of\ user[uuid\:%s] = old password is not equal to the original password, cannot update the password of user[uuid:{0}]

# at: src/main/java/org/zstack/identity/AccountInterceptor.java:55
# args: 
wrong\ password = wrong password

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1612
# args: JSONObjectUtil.toJsonString(s)
a\ statement\ must\ have\ effect\ field.\ Invalid\ statement[%s] = a statement must have effect field. Invalid statement[{0}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1615
# args: JSONObjectUtil.toJsonString(s)
a\ statement\ must\ have\ action\ field.\ Invalid\ statement[%s] = a statement must have action field. Invalid statement[{0}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1618
# args: JSONObjectUtil.toJsonString(s)
a\ statement\ must\ have\ a\ non-empty\ action\ field.\ Invalid\ statement[%s] = a statement must have a non-empty action field. Invalid statement[{0}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:165
# args: resourceUuid
cannot\ find\ the\ resource[uuid\:%s];\ wrong\ resourceUuid\ or\ the\ resource\ is\ admin\ resource = cannot find the resource[uuid:{0}]; wrong resourceUuid or the resource is admin resource

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:399
# args: msg.getUserUuid()
the\ user\ specified\ by\ the\ userUuid[%s]\ does\ not\ belong\ to\ the\ current\ account,\ and\ the\ current\ account\ is\ not\ an\ admin\ account,\ so\ it\ has\ no\ permission\ to\ check\ the\ user'spermissions = the user specified by the userUuid[{0}] does not belong to the current account, and the current account is not an admin account, so it has no permission to check the user'spermissions

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1009
# args: accountUuid
cannot\ find\ the\ account[uuid\:%s] = cannot find the account[uuid:{0}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1447
# args: 
accountName\ and\ accountUuid\ cannot\ both\ be\ null,\ you\ must\ specify\ at\ least\ one = accountName and accountUuid cannot both be null, you must specify at least one

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1458
# args: msg.getName(),msg.getAccountUuid()
unable\ to\ create\ a\ group.\ A\ group\ called\ %s\ is\ already\ under\ the\ account[uuid\:%s] = unable to create a group. A group called {0} is already under the account[uuid:{1}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1468
# args: msg.getName(),msg.getAccountUuid()
unable\ to\ create\ a\ user.\ A\ user\ called\ %s\ is\ already\ under\ the\ account[uuid\:%s] = unable to create a user. A user called {0} is already under the account[uuid:{1}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1477
# args: msg.getName()
unable\ to\ create\ an\ account.\ An\ account\ already\ called\ %s = unable to create an account. An account already called {0}

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1484
# args: 
account\ cannot\ delete\ itself = account cannot delete itself

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1490
# args: 
cannot\ delete\ builtin\ admin\ account. = cannot delete builtin admin account.

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1496
# args: 
Only\ admin\ can\ delete\ account. = Only admin can delete account.

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1504
# args: 
the\ current\ session\ is\ an\ account\ session.\ You\ need\ to\ specify\ the\ field\ 'uuid'\ of\ the\ user\ you\ want\ to\ update = the current session is an account session. You need to specify the field 'uuid' of the user you want to update

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1519
# args: msg.getUuid()
your\ are\ login\ as\ a\ user,\ you\ cannot\ another\ user[uuid\:%s] = your are login as a user, you cannot another user[uuid:{0}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1527
# args: 
all\ is\ set\ to\ false,\ accountUuids\ cannot\ be\ null\ or\ empty = all is set to false, accountUuids cannot be null or empty

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1535
# args: 
toPublic\ is\ set\ to\ false,\ accountUuids\ cannot\ be\ null\ or\ empty = toPublic is set to false, accountUuids cannot be null or empty

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1584
# args: policy.getName(),policy.getUuid(),msg.getSession().getAccountUuid()
policy[name\:\ %s,\ uuid\:\ %s]\ doesn't\ belong\ to\ the\ account[uuid\:\ %s] = policy[name: {0}, uuid: {1}] doesn't belong to the account[uuid: {2}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1598
# args: user.getName(),user.getUuid(),msg.getSession().getAccountUuid()
user[name\:\ %s,\ uuid\:\ %s]\ doesn't\ belong\ to\ the\ account[uuid\:\ %s] = user[name: {0}, uuid: {1}] doesn't belong to the account[uuid: {2}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1602
# args: group.getName(),group.getUuid(),msg.getSession().getAccountUuid()
group[name\:\ %s,\ uuid\:\ %s]\ doesn't\ belong\ to\ the\ account[uuid\:\ %s] = group[name: {0}, uuid: {1}] doesn't belong to the account[uuid: {2}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1643
# args: msg.getName()
unable\ to\ update\ name.\ An\ account\ already\ called\ %s = unable to update name. An account already called {0}

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1654
# args: msg.getUuid()
old\ password\ is\ not\ equal\ to\ the\ original\ password,\ cannot\ update\ the\ password\ of\ account[uuid\:\ %s] = old password is not equal to the original password, cannot update the password of account[uuid: {0}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1659
# args: 
the\ name\ of\ admin\ account\ cannot\ be\ updated = the name of admin account cannot be updated

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1665
# args: 
only\ admin\ account\ can\ update\ it's\ password = only admin account can update it's password

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1672
# args: account.getUuid(),account.getName(),msg.getUuid()
account[uuid\:\ %s,\ name\:\ %s]\ is\ a\ normal\ account,\ it\ cannot\ reset\ the\ password\ of\ another\ account[uuid\:\ %s] = account[uuid: {0}, name: {1}] is a normal account, it cannot reset the password of another account[uuid: {2}]

# at: src/main/java/org/zstack/identity/rbac/OperationTargetAPIRequestChecker.java:190
# args: rbacEntity.getApiMessage().getSession().getAccountUuid(),uuid,resourceType.getSimpleName()
permission\ denied,\ the\ account[uuid\:%s]\ is\ not\ the\ owner\ of\ the\ resource[uuid\:%s,\ type\:%s] = permission denied, the account[uuid:{0}] is not the owner of the resource[uuid:{1}, type:{2}]

# at: src/main/java/org/zstack/identity/rbac/OperationTargetAPIRequestChecker.java:210
# args: rbacEntity.getApiMessage().getSession().getAccountUuid(),resourceWithNoAccess,resourceType.getSimpleName()
the\ account[uuid\:%s]\ has\ no\ access\ to\ the\ resources[uuid\:%s,\ type\:%s] = the account[uuid:{0}] has no access to the resources[uuid:{1}, type:{2}]

# at: src/main/java/org/zstack/identity/rbac/RBACAPIRequestChecker.java:80
# args: rbacEntity.getApiMessage().getClass().getName()
operation[API\:%s]\ is\ denied\ by\ default,\ please\ contact\ admin\ to\ correct\ it = operation[API:{0}] is denied by default, please contact admin to correct it

# at: src/main/java/org/zstack/identity/rbac/RBACAPIRequestChecker.java:187
# args: p.getName(),p.getUuid()
the\ operation\ is\ denied\ by\ the\ policy[name\:%s\ uuid\:%s] = the operation is denied by the policy[name:{0} uuid:{1}]

# at: src/main/java/org/zstack/identity/rbac/RBACAPIRequestChecker.java:200
# args: p.getName(),p.getUuid(),fname
the\ operation\ is\ denied\ by\ the\ policy[name\:%s,\ uuid\:%s],\ field[%s]\ is\ not\ permitted\ to\ set = the operation is denied by the policy[name:{0}, uuid:{1}], field[{2}] is not permitted to set

# at: src/main/java/org/zstack/identity/rbac/RBACApiInterceptor.java:92
# args: 
cannot\ update\ a\ system\ or\ predefined\ role = cannot update a system or predefined role

# at: src/main/java/org/zstack/identity/rbac/RBACApiInterceptor.java:108
# args: 
cannot\ delete\ a\ system\ or\ predefined\ role = cannot delete a system or predefined role

# at: src/main/java/org/zstack/identity/AccountQuotaChangeChecker.java:31
# args: quota.getName(),quota.getIdentityUuid(),updatedValue
the\ quota[name\:%s]\ of\ account[uuid\:%s]\ can\ not\ be\ %d = the quota[{0}] of account[uuid:{1}] can not be {2}

# at: src/main/java/org/zstack/identity/AccountQuotaChangeChecker.java:55
# args: accountUuid,quotaName,usage.getUsed(),updatedValue
the\ account[uuid\:%s]\ used\ [name\:%s,\ usedValue\:%s]\ exceeds\ request\ quota\:\ %d = the account[uuid:{0}] used [name:{1}, usedValue:{2}] exceeds request quota: {3}

# at: src/main/java/org/zstack/image/BackupStorageDeleteBitGC.java:35
# args: backupStorageUuid,bsStatus
the\ backup\ storage[uuid\:%s]\ is\ not\ in\ status\ of\ Connected,\ current\ status\ is\ %s = the backup storage[uuid:{0}] is not in status of Connected, current status is {1}

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:88
# args: vol.getUuid(),vol.getStatus()
volume[uuid\:%s]\ is\ not\ Ready,\ it's\ %s = volume[uuid:{0}] is not Ready, it's {1}

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:92
# args: vol.getUuid(),vol.getState()
volume[uuid\:%s]\ is\ not\ Enabled,\ it's\ %s = volume[uuid:{0}] is not Enabled, it's {1}

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:99
# args: vsvo.getUuid(),vsvo.getStatus()
volume\ snapshot[uuid\:%s]\ is\ not\ Ready,\ it's\ %s = volume snapshot[uuid:{0}] is not Ready, it's {1}

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:103
# args: vsvo.getUuid(),vsvo.getState()
volume\ snapshot[uuid\:%s]\ is\ not\ Enabled,\ it's\ %s = volume snapshot[uuid:{0}] is not Enabled, it's {1}

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:174
# args: 
ISO\ cannot\ be\ used\ as\ system\ image = ISO cannot be used as system image

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:180
# args: msg.getFormat()
unknown\ format[%s] = unknown format[{0}]

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:184
# args: msg.getType()
unsupported\ image\ type[%s] = unsupported image type[{0}]

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:203
# args: msg.getBackupStorageUuids(),BackupStorageStatus.Connected,BackupStorageState.Enabled
no\ backup\ storage\ specified\ in\ uuids%s\ is\ available\ for\ adding\ this\ image;\ they\ are\ not\ in\ status\ %s\ or\ not\ in\ state\ %s,\ or\ the\ uuid\ is\ invalid\ backup\ storage\ uuid = no backup storage specified in uuids{0} is available for adding this image; they are not in status {1} or not in state {2}, or the uuid is invalid backup storage uuid

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:214
# args: 
url\ must\ starts\ with\ 'file\:///',\ 'http\://',\ 'https\://'\ 'ftp\://',\ 'sftp\://'\ or\ '/' = url must starts with 'file:///', 'http://', 'https://' 'ftp://', 'sftp://' or '/'

# at: src/main/java/org/zstack/image/ImageBase.java:168
# args: self.getUuid(),self.getName()
the\ image[uuid\:%s,\ name\:%s]\ is\ not\ on\ any\ backup\ storage = the image[uuid:{0}, name:{1}] is not on any backup storage

# at: src/main/java/org/zstack/image/ImageBase.java:178
# args: self.getUuid(),self.getName()
No\ connected\ backup\ storage\ found\ for\ image[uuid\:%s,\ name\:%s] = No connected backup storage found for image[uuid:{0}, name:{1}]

# at: src/main/java/org/zstack/image/ImageBase.java:366
# args: msg.getImageUuid(),JSONObjectUtil.toJsonString(errors)
detach\ iso[uuid\=%s]\ from\ vm\ failed,\ errors\ are\ %s = detach iso[uuid={0}] from vm failed, errors are {1}

# at: src/main/java/org/zstack/image/ImageBase.java:713
# args: self.getUuid(),self.getName(),bsUuid
the\ image[uuid\:%s,\ name\:%s]\ is\ not\ on\ the\ backup\ storage[uuid\:%s] = the image[uuid:{0}, name:{1}] is not on the backup storage[uuid:{2}]

# at: src/main/java/org/zstack/image/ImageBase.java:655
# args: self.getUuid(),self.getName(),ref.getStatus(),bsUuid
the\ image[uuid\:%s,\ name\:%s]'s\ status[%s]\ is\ not\ Deleted\ on\ the\ backup\ storage[uuid\:%s] = the image[uuid:{0}, name:{1}]'s status[{2}] is not Deleted on the backup storage[uuid:{3}]

# at: src/main/java/org/zstack/image/ImageBase.java:697
# args: self.getUuid(),self.getName()
the\ image[uuid\:%s,\ name\:%s]\ is\ not\ deleted\ on\ any\ backup\ storage = the image[uuid:{0}, name:{1}] is not deleted on any backup storage

# at: src/main/java/org/zstack/image/ImageBase.java:718
# args: self.getUuid(),self.getName(),bsUuid
the\ image[uuid\:%s,\ name\:%s]\ is\ not\ deleted\ on\ the\ backup\ storage[uuid\:%s] = the image[uuid:{0}, name:{1}] is not deleted on the backup storage[uuid:{2}]

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:524
# args: bootModeCount
only\ one\ bootMode\ system\ tag\ is\ allowed,\ but\ %d\ got = only one bootMode system tag is allowed, but {0} got

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:542
# args: bootMode,systemTag
[%s]\ specified\ in\ system\ tag\ [%s]\ is\ not\ a\ valid\ boot\ mode = [{0}] specified in system tag [{1}] is not a valid boot mode

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:1032
# args: 
upload\ session\ expired = upload session expired

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:1534
# args: msgData.getBackupStorageUuids(),JSONObjectUtil.toJsonString(errs)
unable\ to\ allocate\ backup\ storage\ specified\ by\ uuids%s,\ list\ errors\ are\:\ %s = unable to allocate backup storage specified by uuids{0}, list errors are: {1}

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:1645
# args: msgData.getRootVolumeUuid()
failed\ to\ create\ image\ from\ root\ volume[uuid\:%s]\ on\ all\ backup\ storage,\ see\ cause\ for\ one\ of\ errors = failed to create image from root volume[uuid:{0}] on all backup storage, see cause for one of errors

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:1916
# args: msgData.getBackupStorageUuids(),JSONObjectUtil.toJsonString(errs)
failed\ to\ allocate\ all\ backup\ storage[uuid\:%s],\ a\ list\ of\ error\:\ %s = failed to allocate all backup storage[uuid:{0}], a list of error: {1}

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:2018
# args: msgData.getVolumeUuid(),msgData.getBackupStorageUuids()
failed\ to\ create\ data\ volume\ template\ from\ volume[uuid\:%s]\ on\ all\ backup\ storage%s.\ See\ cause\ for\ one\ of\ errors = failed to create data volume template from volume[uuid:{0}] on all backup storage{1}. See cause for one of errors

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:2104
# args: imageUuid
image[uuid\:%s]\ is\ not\ on\ creating,\ please\ wait\ for\ it\ to\ cancel\ itself. = image[uuid:{0}] is not on creating, please wait for it to cancel itself.

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:2110
# args: volumeUuid
volume[uuid\:%s]\ has\ been\ deleted.\ no\ need\ to\ cancel = volume[uuid:{0}] has been deleted. no need to cancel

# at: src/main/java/org/zstack/image/ImageMevocoApiInterceptor.java:35
# args: 
Failed\ to\ set\ security\ level,\ because\ security\ level\ is\ disabled. = Failed to set security level, because security level is disabled.

# at: src/main/java/org/zstack/image/ImageMevocoApiInterceptor.java:45
# args: msg.getSecurityLevel(),Arrays.stream(SecurityLevel.values()).map(SecurityLevel::getCode).collect(Collectors.toList())
Unknown\ security\ level\ code[%s],\ supported\ values\ are\ %s = Unknown security level code[{0}], supported values are {1}

# at: src/main/java/org/zstack/imagereplicator/ImageReplicatorImpl.java:318
# args: targetBsUuid
target\ backup\ storage[uuid\:%s]\ became\ unavailable = target backup storage[uuid:{0}] became unavailable

# at: src/main/java/org/zstack/imagereplicator/ReplicationGroupApiInterceptor.java:30
# args: String.join(",", msg.getBackupStorageUuids()),msg.getReplicationGroupUuid()
One\ or\ more\ backup\ storage[uuids\:%s]\ has\ been\ added\ to\ replication\ group[uuid\:%s] = One or more backup storage[uuids:{0}] has been added to replication group[uuid:{1}]

# at: src/main/java/org/zstack/imagereplicator/ReplicationGroupApiInterceptor.java:41
# args: bsUuid
Backup\ storage[uuids\:%s]\ is\ not\ of\ type\ ImageStore = Backup storage[uuids:{0}] is not of type ImageStore

# at: src/main/java/org/zstack/imagereplicator/ReplicationGroupApiInterceptor.java:51
# args: bsUuid
Backup\ storage[uuids\:%s]\ is\ not\ attached\ to\ any\ Zone = Backup storage[uuids:{0}] is not attached to any Zone

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:63
# args: l3NetworkUuid
Network\ [uuid\:\ %s]\ does't\ not\ have\ IPsec\ service = Network [uuid: {0}] does't not have IPsec service

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:73
# args: rcidr,tempCidr
the\ remote\ CIDR[%s]\ and\ remote\ CIDR[%s]\ are\ overlaped = the remote CIDR[{0}] and remote CIDR[{1}] are overlaped

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:97
# args: lcidr,tempCidr
the\ CIDR[%s]\ of\ local\ router\ and\ remote\ CIDR[%s]\ are\ overlaped = the CIDR[{0}] of local router and remote CIDR[{1}] are overlaped

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:110
# args: 
all\ networks\ in\ same\ IPsecConnection\ should\ be\ same\ type = all networks in same IPsecConnection should be same type

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:116
# args: L3NetworkConstant.L3_BASIC_NETWORK_TYPE
IPsecConnection\ can\ ONLY\ have\ 1\ network\ for\ %s = IPsecConnection can ONLY have 1 network for {0}

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:127
# args: l3Uuid
L3Network\ [uuid\:\ %s]\ has\ not\ been\ attached\ to\ vpc\ router = L3Network [uuid: {0}] has not been attached to vpc router

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:133
# args: 
all\ networks\ in\ same\ IPsecConnection\ must\ be\ attached\ to\ same\ VPC\ router = all networks in same IPsecConnection must be attached to same VPC router

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:150
# args: tuples.get(0).get(0, String.class),tuples.get(0).get(1, String.class)
there\ already\ have\ ipsec\ connection[uuid\:%s,\ name\:%s]\ with\ the\ same\ vrouter\ and\ peerAddress = there already have ipsec connection[uuid:{0}, name:{1}] with the same vrouter and peerAddress

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:174
# args: msg.getVipUuid(),useForList.toString()
the\ vip[uuid\:%s]\ has\ been\ used\ for\ %s = the vip[uuid:{0}] has been used for {1}

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:179
# args: msg.getPeerAddress()
the\ peerAddress[%s]\ cannot\ be\ the\ same\ to\ the\ VIP\ address = the peerAddress[{0}] cannot be the same to the VIP address

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:183
# args: msg.getPeerAddress()
the\ peerAddress[%s]\ is\ not\ an\ IPv4\ address = the peerAddress[{0}] is not an IPv4 address

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:195
# args: 
the\ authKey\ cannot\ contain\ white\ space\ and\ special\ characters\ of\ '\"`\\ = the authKey cannot contain white space and special characters of '\"`\\

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:229
# args: 
must\ include\ l3\ networks\ in\ APIAttachL3NetworksToIPsecConnectionMsg = must include l3 networks in APIAttachL3NetworksToIPsecConnectionMsg

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:236
# args: l3NetworkUuid
L3\ network\ [%s]\ is\ not\ vpc\ network,\ can\ not\ be\ attached\ or\ detached\ to\ ipsec = L3 network [{0}] is not vpc network, can not be attached or detached to ipsec

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:217
# args: l3NetworkUuid,msg.getIPsecConnectionUuid()
L3\ network\ [%s]\ can\ not\ be\ attached\ to\ ipsec\ [uuid\ \:%s]twice = L3 network [{0}] can not be attached to ipsec [uuid :{1}]twice

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:240
# args: l3NetworkUuid,msg.getIPsecConnectionUuid()
L3\ network\ [%s]\ is\ not\ be\ attached\ to\ ipsec\ [uuid\ \:%s] = L3 network [{0}] is not be attached to ipsec [uuid :{1}]

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:250
# args: cidr,msg.getIPsecConnectionUuid()
Cidr\ [%s]\ is\ already\ in\ the\ Cidrs\ of\ ipsec\ [uuid\ \:%s] = Cidr [{0}] is already in the Cidrs of ipsec [uuid :{1}]

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:264
# args: cidr,msg.getIPsecConnectionUuid()
Cidr\ [%s]\ is\ not\ in\ Cidrs\ of\ ipsec\ [uuid\ \:%s] = Cidr [{0}] is not in Cidrs of ipsec [uuid :{1}]

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:272
# args: msg.getUuid()
can\ not\ change\ state\ because\ ipsec\ [uuid\:%s]\ status\ is\ not\ ready = can not change state because ipsec [uuid:{0}] status is not ready

# at: src/main/java/org/zstack/ipsec/IPsecManagerImpl.java:132
# args: msg.getIPsecConnectionUuid()
cannot\ find\ the\ IPsecconnection[uuid\:%s],\ it\ may\ have\ been\ deleted = cannot find the IPsecconnection[uuid:{0}], it may have been deleted

# at: src/main/java/org/zstack/ipsec/IPsecManagerImpl.java:336
# args: Long.toString(range2.getStart()),Long.toString(range2.getEnd()),Long.toString(cur.getStart()),Long.toString(cur.getEnd()),msg.getVipUuid()
Current\ port\ range[%s,\ %s]\ is\ conflicted\ with\ used\ port\ range\ [%s,\ %s]\ with\ vip[uuid\:\ %s]\ protocol\:\ UDP = Current port range[{0}, {1}] is conflicted with used port range [{2}, {3}] with vip[uuid: {4}] protocol: UDP

# at: src/main/java/org/zstack/ipsec/IPsecManagerImpl.java:373
# args: cidr,l3Inv.getUuid(),uuid,rCidr
cidr[%s]\ of\ attached\ L3Network\ [uuid\:%s]\ is\ overlapped\ with\ ipsec\ [uuid\:%s]\ remote\ cidr[%s] = cidr[{0}] of attached L3Network [uuid:{1}] is overlapped with ipsec [uuid:{2}] remote cidr[{3}]

# at: src/main/java/org/zstack/ipsec/vyos/VyosCreateIPsecFlow.java:90
# args: errorCode.getDescription()
create\ ipsec\ to\ ha\ route\ failed,\ because\ %s = create ipsec to ha route failed, because {0}

# at: src/main/java/org/zstack/ipsec/vyos/VyosDeleteIPsecFlow.java:80
# args: errorCode.getDescription()
delete\ ipsec\ from\ ha\ group\ failed\ because\ %s = delete ipsec from ha group failed because {0}

# at: src/main/java/org/zstack/ipsec/vyos/VyosIPsecBackend.java:607
# args: rsp.getError()
operation\ error,\ because\:%s = operation error, because:{0}

# at: src/main/java/org/zstack/ipsec/vyos/VyosIPsecBackend.java:162
# args: rcidr,cidr
the\ remoteCidr[%s]\ is\ overlaped\ with\ VirtualRouter\ interface\ cidr[%s] = the remoteCidr[{0}] is overlaped with VirtualRouter interface cidr[{1}]

# at: src/main/java/org/zstack/ipsec/vyos/VyosIPsecBackend.java:279
# args: 
vyos\ doesn't\ support\ aes-192\ as\ IkeEncryptionAlgorithm,\ available\ options\ aes-128,\ aes-256,\ 3des = vyos doesn't support aes-192 as IkeEncryptionAlgorithm, available options aes-128, aes-256, 3des

# at: src/main/java/org/zstack/ipsec/vyos/VyosIPsecBackend.java:285
# args: 
vyos\ doesn't\ support\ aes-192\ as\ PolicyEncryptionAlgorithm,\ available\ options\ aes-128,\ aes-256,\ 3des = vyos doesn't support aes-192 as PolicyEncryptionAlgorithm, available options aes-128, aes-256, 3des

# at: src/main/java/org/zstack/ipsec/vyos/VyosIPsecBackend.java:291
# args: msg.getIkeDhGroup()
vyos\ doesn't\ support\ %d\ as\ Ike\ DhGroup\  = vyos doesn't support {0} as Ike DhGroup 

# at: src/main/java/org/zstack/ipsec/vyos/VyosIPsecBackend.java:424
# args: errorCode.getDescription()
sync\ to\ ha\ group\ failed,\ because\:%s = sync to ha group failed, because:{0}

# at: src/main/java/org/zstack/ipsec/vyos/VyosIPsecBackend.java:646
# args: errorCode.getDescription()
apply\ to\ ha\ group\ failed,\ because\ %s = apply to ha group failed, because {0}

# at: src/main/java/org/zstack/kvm/KVMApiInterceptor.java:37
# args: msg.getManagementIp()
there\ has\ been\ a\ kvm\ host\ having\ management\ ip[%s] = there has been a kvm host having management ip[{0}]

# at: src/main/java/org/zstack/kvm/KVMConnectExtensionForL2Network.java:127
# args: l2.getType()
KVMConnectExtensionForL2Network\ wont's\ support\ L2Network[type\:%s] = KVMConnectExtensionForL2Network wont's support L2Network[type:{0}]

# at: src/main/java/org/zstack/kvm/KVMConsoleHypervisorBackend.java:68
# args: rsp.getPort(),vm.getUuid()
unexpected\ VNC\ port\ number[%d]\ for\ VM\ [uuid\:%s] = unexpected VNC port number[{0}] for VM [uuid:{1}]

# at: src/main/java/org/zstack/kvm/KVMHost.java:333
# args: self.getUuid()
host[uuid\:%s]\ has\ been\ deleted = host[uuid:{0}] has been deleted

# at: src/main/java/org/zstack/kvm/KVMHost.java:499
# args: msg.getVmInstanceUuid(),self.getUuid(),self.getManagementIp(),ret.getError()
unable\ to\ get\ first\ boot\ dev\ of\ vm[uuid\:%s]\ on\ kvm\ host\ [uuid\:%s,\ ip\:%s],\ because\ %s = unable to get first boot dev of vm[uuid:{0}] on kvm host [uuid:{1}, ip:{2}], because {3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:713
# args: self.getManagementIp(),getSelf().getUsername(),getSelf().getPort(),result.getExitErrorMessage()
unable\ to\ connect\ to\ KVM[ip\:%s,\ username\:%s,\ sshPort\:%d\ ]\ to\ do\ DNS\ check,\ please\ check\ if\ username/password\ is\ wrong;\ %s = unable to connect to KVM[ip:{0}, username:{1}, sshPort:{2} ] to do DNS check, please check if username/password is wrong; {3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:795
# args: self.getUuid(),self.getStatus()
the\ host[uuid\:%s,\ status\:%s]\ is\ not\ Connected = the host[uuid:{0}, status:{1}] is not Connected

# at: src/main/java/org/zstack/kvm/KVMHost.java:1121
# args: volume.getUuid(),state
cannot\ do\ volume\ snapshot\ merge\ when\ vm[uuid\:%s]\ is\ in\ state\ of\ %s.\ The\ operation\ is\ only\ allowed\ when\ vm\ is\ Running\ or\ Stopped = cannot do volume snapshot merge when vm[uuid:{0}] is in state of {1}. The operation is only allowed when vm is Running or Stopped

# at: src/main/java/org/zstack/kvm/KVMHost.java:1128
# args: KVMConstant.MIN_LIBVIRT_LIVE_BLOCK_COMMIT_VERSION,libvirtVersion
live\ volume\ snapshot\ merge\ needs\ libvirt\ version\ greater\ than\ %s,\ current\ libvirt\ version\ is\ %s.\ Please\ stop\ vm\ and\ redo\ the\ operation\ or\ detach\ the\ volume\ if\ it's\ data\ volume = live volume snapshot merge needs libvirt version greater than {0}, current libvirt version is {1}. Please stop vm and redo the operation or detach the volume if it's data volume

# at: src/main/java/org/zstack/kvm/KVMHost.java:1217
# args: msg.getVmUuid(),vmState
vm[uuid\:%s]\ is\ not\ Running\ or\ Stopped,\ current\ state[%s] = vm[uuid:{0}] is not Running or Stopped, current state[{1}]

# at: src/main/java/org/zstack/kvm/KVMHost.java:1578
# args: msg.getVmInstanceUuid(),self.getUuid(),self.getManagementIp(),ret.getError()
failed\ to\ update\ nic[vm\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],because\ %s = failed to update nic[vm:{0}] on kvm host[uuid:{1}, ip:{2}],because {3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:1625
# args: msg.getNicInventory().getUuid(),msg.getNicInventory().getVmInstanceUuid(),self.getUuid(),self.getManagementIp(),ret.getError()
failed\ to\ attach\ nic[uuid\:%s,\ vm\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],because\ %s = failed to attach nic[uuid:{0}, vm:{1}] on kvm host[uuid:{2}, ip:{3}],because {4}

# at: src/main/java/org/zstack/kvm/KVMHost.java:1672
# args: vol.getUuid(),vol.getInstallPath(),vm.getUuid(),vm.getName(),getSelf().getUuid(),getSelf().getManagementIp(),ret.getError()
failed\ to\ detach\ data\ volume[uuid\:%s,\ installPath\:%s]\ from\ vm[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = failed to detach data volume[uuid:{0}, installPath:{1}] from vm[uuid:{2}, name:{3}] on kvm host[uuid:{4}, ip:{5}], because {6}

# at: src/main/java/org/zstack/kvm/KVMHost.java:1759
# args: vol.getUuid(),vol.getInstallPath(),vm.getUuid(),vm.getName(),getSelf().getUuid(),getSelf().getManagementIp(),ret.getError()
failed\ to\ attach\ data\ volume[uuid\:%s,\ installPath\:%s]\ to\ vm[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = failed to attach data volume[uuid:{0}, installPath:{1}] to vm[uuid:{2}, name:{3}] on kvm host[uuid:{4}, ip:{5}], because {6}

# at: src/main/java/org/zstack/kvm/KVMHost.java:1799
# args: vminv.getUuid(),vminv.getName(),self.getUuid(),self.getManagementIp(),e.getMessage()
failed\ to\ destroy\ vm[uuid\:%s\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = failed to destroy vm[uuid:{0} name:{1}] on kvm host[uuid:{2}, ip:{3}], because {4}

# at: src/main/java/org/zstack/kvm/KVMHost.java:1928
# args: vminv.getUuid(),vminv.getName(),self.getUuid(),self.getManagementIp(),e.getMessage()
failed\ to\ stop\ vm[uuid\:%s\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = failed to stop vm[uuid:{0} name:{1}] on kvm host[uuid:{2}, ip:{3}], because {4}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2015
# args: msg.getHostUuid(),ret.getError()
Host[%s]\ update\ spice\ channel\ config\ faild,\ because\ %s = Host[{0}] update spice channel config faild, because {1}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2414
# args: msg.getPhysicalInterface(),context.getInventory().getUuid(),context.getInventory().getManagementIp()
failed\ to\ check\ physical\ network\ interfaces[names\ \:\ %s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s] = failed to check physical network interfaces[names : {0}] on kvm host[uuid:{1}, ip:{2}]

# at: src/main/java/org/zstack/kvm/KVMHost.java:2477
# args: self.getUuid(),ret.getHostUuid()
detected\ abnormal\ status[host\ uuid\ change,\ expected\:\ %s\ but\:\ %s]\ of\ kvmagent,it's\ mainly\ caused\ by\ kvmagent\ restarts\ behind\ zstack\ management\ server.\ Report\ this\ to\ ping\ task,\ it\ will\ issue\ a\ reconnect\ soon = detected abnormal status[host uuid change, expected: {0} but: {1}] of kvmagent,it's mainly caused by kvmagent restarts behind zstack management server. Report this to ping task, it will issue a reconnect soon

# at: src/main/java/org/zstack/kvm/KVMHost.java:2602
# args: self.getUuid(),self.getManagementIp(),connectPath,rsp.getError()
unable\ to\ connect\ to\ kvm\ host[uuid\:%s,\ ip\:%s,\ url\:%s],\ because\ %s = unable to connect to kvm host[uuid:{0}, ip:{1}, url:{2}], because {3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2660
# args: 
host\ can\ not\ access\ any\ primary\ storage,\ please\ check\ network = host can not access any primary storage, please check network

# at: src/main/java/org/zstack/kvm/KVMHost.java:2836
# args: getSelf().getPort(),KVMGlobalConfig.TEST_SSH_PORT_ON_OPEN_TIMEOUT.value(Long.class)
the\ host'\ ssh\ port[%s]\ not\ open\ after\ %s\ seconds,\ connect\ timeout = the host' ssh port[{0}] not open after {1} seconds, connect timeout

# at: src/main/java/org/zstack/kvm/KVMHost.java:2891
# args: checkList
failed\ to\ ping\ all\ DNS/IP\ in\ %s;\ please\ check\ /etc/resolv.conf\ to\ make\ sure\ your\ host\ is\ able\ to\ reach\ public\ internet = failed to ping all DNS/IP in {0}; please check /etc/resolv.conf to make sure your host is able to reach public internet

# at: src/main/java/org/zstack/kvm/KVMHost.java:2889
# args: self.getManagementIp(),getSelf().getUsername(),getSelf().getPort(),ret.getExitErrorMessage()
unable\ to\ connect\ to\ KVM[ip\:%s,\ username\:%s,\ sshPort\:\ %d,\ ]\ to\ do\ DNS\ check,\ please\ check\ if\ username/password\ is\ wrong;\ %s = unable to connect to KVM[ip:{0}, username:{1}, sshPort: {2}, ] to do DNS check, please check if username/password is wrong; {3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2917
# args: self.getManagementIp(),restf.getHostName(),ret.getStderr(),ret.getExitErrorMessage()
the\ KVM\ host[ip\:%s]\ cannot\ access\ the\ management\ node's\ callback\ url.\ It\ seems\ that\ the\ KVM\ host\ cannot\ reach\ the\ management\ IP[%s].\ %s\ %s = the KVM host[ip:{0}] cannot access the management node's callback url. It seems that the KVM host cannot reach the management IP[{1}]. {2} {3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2914
# args: self.getManagementIp(),getSelf().getUsername(),getSelf().getPort(),ret.getExitErrorMessage()
unable\ to\ connect\ to\ KVM[ip\:%s,\ username\:%s,\ sshPort\:%d]\ to\ check\ the\ management\ node\ connectivity,please\ check\ if\ username/password\ is\ wrong;\ %s = unable to connect to KVM[ip:{0}, username:{1}, sshPort:{2}] to check the management node connectivity,please check if username/password is wrong; {3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:3123
# args: 
cannot\ find\ either\ 'vmx'\ or\ 'svm'\ in\ /proc/cpuinfo,\ please\ make\ sure\ you\ have\ enabled\ virtualization\ in\ your\ BIOS\ setting = cannot find either 'vmx' or 'svm' in /proc/cpuinfo, please make sure you have enabled virtualization in your BIOS setting

# at: src/main/java/org/zstack/kvm/KVMHost.java:2748
# args: self.getUuid(),self.getClusterUuid()
host\ [uuid\:%s]\ cannot\ be\ added\ to\ cluster\ [uuid\:%s]\ because\ qemu/libvirt\ version\ does\ not\ match = host [uuid:{0}] cannot be added to cluster [uuid:{1}] because qemu/libvirt version does not match

# at: src/main/java/org/zstack/kvm/KVMHost.java:2769
# args: self.getUuid(),self.getClusterUuid()
host\ [uuid\:%s]\ cannot\ be\ added\ to\ cluster\ [uuid\:%s]\ because\ cpu\ model\ name\ does\ not\ match = host [uuid:{0}] cannot be added to cluster [uuid:{1}] because cpu model name does not match

# at: src/main/java/org/zstack/kvm/KVMHost.java:3402
# args: 
host\ is\ not\ in\ the\ connected\ status,\ cannot\ update\ os = host is not in the connected status, cannot update os

# at: src/main/java/org/zstack/kvm/KVMHost.java:3400
# args: 
host\ is\ in\ the\ premaintenance\ state,\ cannot\ update\ os = host is in the premaintenance state, cannot update os

# at: src/main/java/org/zstack/kvm/KVMHost.java:4331
# args: hostUuid,errorCode
fail\ to\ check\ file\ %s\ on\ host[uuid\:%s] = failed to check file[0] on host[uuid:{1}]

# at: src/main/java/org/zstack/kvm/KVMHostAllocatorFilterExtensionPoint.java:63
# args: 
cannot\ adapt\ version\ for\ the\ bellow\ rpm\:\ libvirt\ /\ qemu\ /\ cpumodel = cannot adapt version for the bellow rpm: libvirt / qemu / cpumodel

# at: src/main/java/org/zstack/kvm/KVMHostCapacityExtension.java:57
# args: host.getUuid(),rsp.getTotalMemory(),reservedSize
The\ host[uuid\:%s]'s\ available\ memory\ capacity[%s]\ is\ lower\ than\ the\ reserved\ capacity[%s] = The host[uuid:{0}]'s available memory capacity[{1}] is lower than the reserved capacity[{2}]

# at: src/main/java/org/zstack/kvm/KVMHostFactory.java:111
# args: e.getMessage()
fail\ to\ load\ host\ info\ from\ file.\ because\n%s = fail to load host info from file. because\n{0}

# at: src/main/java/org/zstack/kvm/KVMHostFactory.java:284
# args: os, vo.getName(), vo.getManagementIp()
the\ operation\ system[%s]\ of\ host[name\:%s,\ ip\:%s]\ is\ invalid = the operation system[{0}] of host[name:{1},ip:{2}] is invalid

# at: src/main/java/org/zstack/kvm/KVMHostFactory.java:310
# args: vo.getClusterUuid(),thatOs,vo.getName(),vo.getManagementIp(),os
cluster[uuid\:%s]\ already\ has\ host\ with\ os\ version[%s],\ but\ new\ added\ host[name\:%s\ ip\:%s]\ has\ different\ host\ os\ version[%s] = cluster[uuid:{0}] already has host with os version[{1}], but new added host[name:{2} ip:{3}] has different host os version[{4}]

# at: src/main/java/org/zstack/kvm/KVMHostFactory.java:482
# args: str.toString()
there\ are\ still\ hosts\ not\ have\ the\ same\ cpu\ model,\ details\:\ %s = there are still hosts not have the same cpu model, details: {0}

# at: src/main/java/org/zstack/kvm/KVMHostFactory.java:496
# args: KVMSystemTags.VM_PREDEFINED_PCI_BRIDGE_NUM_TOKEN
pci\ bridge\ need\ a\ value\ greater\ than\ 0\ and\ lower\ than\ 32 = pci bridge need a value greater than 0 and lower than 32

# at: src/main/java/org/zstack/kvm/KVMHostFactory.java:741
# args: hostUuid
host[uuid\:%s]\ does\ not\ have\ cpu\ model\ information,\ you\ can\ reconnect\ the\ host\ to\ fix\ it = host[uuid:{0}] does not have cpu model information, you can reconnect the host to fix it

# at: src/main/java/org/zstack/kvm/KVMRealizeL2NoVlanNetworkBackend.java:69
# args: cmd.getBridgeName(),l2Network.getUuid(),l2Network.getType(),hostUuid,rsp.getError()
failed\ to\ create\ bridge[%s]\ for\ l2Network[uuid\:%s,\ type\:%s]\ on\ kvm\ host[uuid\:%s],\ because\ %s = failed to create bridge[{0}] for l2Network[uuid:{1}, type:{2}] on kvm host[uuid:{3}], because {4}

# at: src/main/java/org/zstack/kvm/KVMRealizeL2NoVlanNetworkBackend.java:119
# args: cmd.getBridgeName(),l2Network.getUuid(),l2Network.getName(),hostUuid,rsp.getError()
failed\ to\ check\ bridge[%s]\ for\ l2NoVlanNetwork[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:\ %s],\ %s = failed to check bridge[{0}] for l2NoVlanNetwork[uuid:{1}, name:{2}] on kvm host[uuid: {3}], {4}

# at: src/main/java/org/zstack/kvm/KVMRealizeL2VlanNetworkBackend.java:66
# args: cmd.getBridgeName(),l2Network.getUuid(),l2Network.getType(),l2vlan.getVlan(),hostUuid,rsp.getError()
failed\ to\ create\ bridge[%s]\ for\ l2Network[uuid\:%s,\ type\:%s,\ vlan\:%s]\ on\ kvm\ host[uuid\:%s],\ because\ %s = failed to create bridge[{0}] for l2Network[uuid:{1}, type:{2}, vlan:{3}] on kvm host[uuid:{4}], because {5}

# at: src/main/java/org/zstack/kvm/KVMRealizeL2VlanNetworkBackend.java:117
# args: cmd.getBridgeName(),l2vlan.getUuid(),l2vlan.getName(),hostUuid,rsp.getError()
failed\ to\ check\ bridge[%s]\ for\ l2VlanNetwork[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:%s],\ %s = failed to check bridge[{0}] for l2VlanNetwork[uuid:{1}, name:{2}] on kvm host[uuid:{3}], {4}

# at: src/main/java/org/zstack/kvm/KVMSecurityGroupBackend.java:111
# args: hto.getHostUuid(),rsp.getError()
failed\ to\ apply\ rules\ of\ security\ group\ rules\ to\ kvm\ host[uuid\:%s],\ because\ %s = failed to apply rules of security group rules to kvm host[uuid:{0}], because {1}

# at: src/main/java/org/zstack/kvm/KVMSecurityGroupBackend.java:154
# args: hostUuid,rsp.getError()
failed\ to\ check\ default\ rules\ of\ security\ group\ on\ kvm\ host[uuid\:%s],\ because\ %s = failed to check default rules of security group on kvm host[uuid:{0}], because {1}

# at: src/main/java/org/zstack/kvm/KvmVmSyncPingTask.java:162
# args: host.getUuid(),host.getManagementIp(),ret.getError()
unable\ to\ do\ vm\ sync\ on\ host[uuid\:%s,\ ip\:%s]\ because\ %s = unable to do vm sync on host[uuid:{0}, ip:{1}] because {2}

# at: src/main/java/org/zstack/kvm/KvmVmSyncPingTask.java:191
# args: vmUuid
The\ vm[%s]\ state\ is\ in\ shutdown\ for\ a\ long\ time,\ check\ whether\ the\ vm\ is\ normal = The vm[{0}] state is in shutdown for a long time, check whether the vm is normal

# at: src/main/java/org/zstack/ldap/LdapApiInterceptor.java:67
# args: 
unsupported\ LDAP/AD\ server\ scope = unsupported LDAP/AD server scope

# at: src/main/java/org/zstack/ldap/LdapApiInterceptor.java:117
# args: type,LdapConstant.OpenLdap.TYPE,LdapConstant.WindowsAD.TYPE
Wrong\ LdapServerType[%s],\ valid\ values\:\ [%,%s] = Wrong LdapServerType[{0}], valid values: [%,{1}]

# at: src/main/java/org/zstack/ldap/LdapApiInterceptor.java:142
# args: 
Cannot\ connect\ to\ LDAP/AD\ server,\ Invalid\ Credentials,\ please\ checkout\ User\ DN\ and\ password = Cannot connect to LDAP/AD server, Invalid Credentials, please checkout User DN and password

# at: src/main/java/org/zstack/ldap/LdapApiInterceptor.java:145
# args: 
Cannot\ connect\ to\ LDAP/AD\ server,\ communication\ false,\ please\ checkout\ IP,\ port\ and\ Base\ DN = Cannot connect to LDAP/AD server, communication false, please checkout IP, port and Base DN

# at: src/main/java/org/zstack/ldap/LdapApiInterceptor.java:148
# args: e.toString()
Cannot\ connect\ to\ LDAP/AD\ server,\ %s = Cannot connect to LDAP/AD server, {0}

# at: src/main/java/org/zstack/ldap/LdapManagerImpl.java:181
# args: vo.getAccountUuid()
Account[uuid\:%s]\ Not\ Found!!! = Account[uuid:{0}] Not Found!!!

# at: src/main/java/org/zstack/ldap/LdapUtil.java:456
# args: filter,errorMessage
query\ ldap\ entry[filter\:\ %s]\ fail,\ because\ %s = query ldap entry[filter: {0}] fail, because {1}

# at: src/main/java/org/zstack/ldap/externalSearch/AggregateSearch.java:52
# args: e.toString()
query\ ldap\ entry\ fail,\ %s = query ldap entry fail, {0}

# at: src/main/java/org/zstack/license/LicenseChecker.java:129
# args: 
Parse\ license\ error,\n1.\ check\ your\ private\ key\ and\ application\ code\ is\ correct\n2.\ check\ your\ license\ is\ not\ corrupted\n3.\ use\ zstack-ctl\ clear_license\ to\ clear\ your\ licenses\ and\ try\ to\ reinstall\n = Parse license error,\n1. check your private key and application code is correct\n2. check your license is not corrupted\n3. use zstack-ctl clear_license to clear your licenses and try to reinstall\n

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:220
# args: e.getMessage()
Decode\ fail\ because\ %s = Decode fail because {0}

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:217
# args: bytes.length
Unexpected\ decoded\ license\ file\ length\:\ %d = Unexpected decoded license file length: {0}

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:846
# args: 
Licensed\ VM\ number\ overrun = Licensed VM number overrun

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:1144
# args: addonLicBy.first(),addonLicBy.second()
unexpected\ license\ policy\:\ %d\ %s. = unexpected license policy: {0} {1}.

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:1195
# args: info.getProdInfo(),addonLicBy.first(),addonLicBy.second()
Addon[%s]\ licensed\ %d\ %s,\ but\ platform\ is\ licensed\ with\ VM\ number = Addon[{0}] licensed {1} {2}, but platform is licensed with VM number

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:1191
# args: info.getProdInfo(),addonLicBy.first(),addonLicBy.second()
Addon[%s]\ licensed\ %d\ %s,\ but\ platform\ is\ licensed\ with\ host = Addon[{0}] licensed {1} {2}, but platform is licensed with host

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:1187
# args: info.getProdInfo(),addonLicBy.first(),addonLicBy.second()
Addon[%s]\ licensed\ %d\ %s,\ but\ platform\ is\ licensed\ with\ CPU\ socket = Addon[{0}] licensed {1} {2}, but platform is licensed with CPU socket

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:1318
# args: AddOnLicenseModule
issue\ date\ of\ addon\ license\ is\ earlier\ than\ the\ existing\ license\ issue\ date = issue date of addon license is earlier than the existing license issue date

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:1323
# args: 
issue\ date\ of\ platform\ license\ is\ earlier\ than\ the\ existing\ license\ issue\ date = issue date of platform license is earlier than the existing license issue date

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:1360
# args: 
Add-on\ license\ is\ not\ supported\ when\ license\ type\ is\ Community = Add-on license is not supported when license type is Community

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:1368
# args: 
Add-on\ license\ is\ not\ supported\ when\ license\ type\ is\ Basic\ or\ Standard = Add-on license is not supported when license type is Basic or Standard

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:1682
# args: 
License\ expired = License expired

# at: src/main/java/org/zstack/log/LogConfigurationManagerImpl.java:249
# args: struct.getType()
No\ factory\ found\ for\ type\:%s = No factory found for type:{0}

# at: src/main/java/org/zstack/log/LogConfigurationManagerImpl.java:464
# args: msg.getType()
Unknown\ log\ configuration\ type\ %s = Unknown log configuration type {0}

# at: src/main/java/org/zstack/log4j2/Log4j2LogConfigurationFactory.java:60
# args: lstruct.getAppenderType()
No\ factory\ found\ for\ log4j2\ appender\ type\:%s. = No factory found for log4j2 appender type:{0}.

# at: src/main/java/org/zstack/log4j2/Log4j2LogConfigurationFactory.java:134
# args: lstruct.getAppenderType()
Unknown\ log4j2\ appender\ type\ %s = Unknown log4j2 appender type {0}

# at: src/main/java/org/zstack/log4j2/appender/syslog/SyslogAppenderProxyFactory.java:44
# args: 
facility\ can\ not\ be\ null = facility can not be null

# at: src/main/java/org/zstack/log4j2/appender/syslog/SyslogAppenderProxyFactory.java:48
# args: configuration.facility
invalid\ facility\ %s = invalid facility {0}

# at: src/main/java/org/zstack/log4j2/appender/syslog/SyslogAppenderProxyFactory.java:52
# args: 
hostname\ can\ not\ be\ null = hostname can not be null

# at: src/main/java/org/zstack/log4j2/appender/syslog/SyslogAppenderProxyFactory.java:56
# args: 
port\ can\ not\ be\ null = port can not be null

# at: src/main/java/org/zstack/log4j2/appender/syslog/SyslogAppenderProxyFactory.java:60
# args: 
protocol\ can\ not\ be\ null = protocol can not be null

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:1456
# args: Platform.getManagementServerIp()
MN\ HA\ environment,\ but\ only\ updated\ license\ for\ %s = MN HA environment, but only updated license for {0}

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:1454
# args: Platform.getManagementServerIp()
Multiple\ MN\ exists\ but\ only\ supplied\ licenses\ for\ %s = Multiple MN exists but only supplied licenses for {0}

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:1569
# args: 
unexpected\ license\ file = unexpected license file

# at: src/main/java/org/zstack/log4j2/appender/syslog/SyslogAppenderProxyFactory.java:66
# args: configuration.protocol
unsupported\ protocol\ %s = unsupported protocol {0}

# at: src/main/java/org/zstack/log4j2/appender/syslog/SyslogAppenderProxyFactory.java:80
# args: configuration.hostname,configuration.port
syslog\ server[address\:\ %s\:%s]\ is\ not\ available = syslog server[address: {0}:{1}] is not available

# at: src/main/java/org/zstack/log4j2/appender/syslog/SyslogAppenderProxyFactory.java:72
# args: configuration.hostname
syslog\ server[address\:\ %s]\ is\ not\ available = syslog server[address: {0}] is not available

# at: src/main/java/org/zstack/login/LdapLoginInterceptor.java:45
# args: 
There\ is\ no\ LDAP/AD\ server\ in\ the\ system,\ Please\ add\ a\ LDAP/AD\ server\ first. = There is no LDAP/AD server in the system, Please add a LDAP/AD server first.

# at: src/main/java/org/zstack/login/LdapLoginInterceptor.java:39
# args: msg.getLdapUid(),msg.getVirtualIDUuid()
Can\ not\ bind\ this\ ldap\ uid\ %s\ to\ virtual\ id\ [uuid\:%s] = Can not bind this ldap uid {0} to virtual id [uuid:{1}]

# at: src/main/java/org/zstack/login/LdapLoginInterceptor.java:53
# args: 
This\ uid\ is\ already\ used = This uid is already used

# at: src/main/java/org/zstack/login/LdapLoginManagerImpl.java:230
# args: 
ZStack\ is\ loading\ ldap\ organizations\ from\ DB\ now,\ can\ not\ execute\ sync\ operation = ZStack is loading ldap organizations from DB now, can not execute sync operation

# at: src/main/java/org/zstack/login/LdapLoginManagerImpl.java:352
# args: e.getMessage()
Failed\ to\ sync\ ldap\ entry[],\ because\ %s = Failed to sync ldap entry[], because {0}

# at: src/main/java/org/zstack/login/LdapLoginManagerImpl.java:975
# args: reply.getError().getReadableDetails()
Failed\ to\ sync\ organizations,\ because\ %s = Failed to sync organizations, because {0}

# at: src/main/java/org/zstack/login/LdapLoginManagerImpl.java:923
# args: 
Failed\ to\ transform\ ldap\ entry\ to\ organization\ ndoe = Failed to transform ldap entry to organization ndoe

# at: src/main/java/org/zstack/login/LdapLoginManagerImpl.java:912
# args: 
failed\ to\ sync\ ldap\ organization = failed to sync ldap organization

# at: src/main/java/org/zstack/login/LdapLoginManagerImpl.java:1380
# args: scope.toString()
Can\ not\ sync\ LDAP/AD\ server\ whose\ scope\ is\ not\ %s = Can not sync LDAP/AD server whose scope is not {0}

# at: src/main/java/org/zstack/login/LdapLoginManagerImpl.java:1503
# args: uid
Failed\ to\ validate\ uid[%s],\ maybe\ it\ has\ been\ deleted = Failed to validate uid[{0}], maybe it has been deleted

# at: src/main/java/org/zstack/login/LdapLoginManagerImpl.java:1544
# args: uid,reply.getError().getReadableDetails()
Failed\ to\ create\ iam2\ virtual\ id\ for\ uid[%s],\ because\ %s = Failed to create iam2 virtual id for uid[{0}], because {1}

# at: src/main/java/org/zstack/login/LdapLoginManagerImpl.java:1679
# args: ldapUid
Failed\ to\ validate\ dn\ [%s],\ maybe\ it\ has\ been\ deleted = Failed to validate dn [{0}], maybe it has been deleted

# at: src/main/java/org/zstack/login/LdapLoginManagerImpl.java:2097
# args: 
invalid\ json\ format = invalid json format

# at: src/main/java/org/zstack/login/LdapLoginManagerImpl.java:2108
# args: 
name\ is\ mandatory\ field\ % = name is mandatory field %

# at: src/main/java/org/zstack/login/LdapLoginManagerImpl.java:2112
# args: 
attribute\ is\ mandatory\ field\ % = attribute is mandatory field %

# at: src/main/java/org/zstack/login/LdapLoginManagerImpl.java:2116
# args: 
type\ is\ mandatory\ field\ % = type is mandatory field %

# at: src/main/java/org/zstack/login/LdapLoginManagerImpl.java:2120
# args: 
optional\ is\ mandatory\ field\ % = optional is mandatory field %

# at: src/main/java/org/zstack/login/LdapLoginManagerImpl.java:2124
# args: fieldNames
name\ should\ use\ values\ in\ %s = name should use values in {0}

# at: src/main/java/org/zstack/login/LdapLoginManagerImpl.java:2150
# args: rule.getAttribute()
Invalid\ attribute.\ Attribute[%s]\ is\ required,\ but\ found\ there\ are\ some\ record\ not\ matched = Invalid attribute. Attribute[{0}] is required, but found there are some record not matched

# at: src/main/java/org/zstack/login/LdapLoginManagerImpl.java:2101
# args: 
strategy\ is\ mandatory\ field\ % = strategy is mandatory field %

# at: src/main/java/org/zstack/loginControl/LoginControlApiInterceptor.java:40
# args: e.getMessage()
Invalid\ rule\ expression,\ add\ access\ control\ rule\ fail\ because\:\ %s = Invalid rule expression, add access control rule fail because: {0}

# at: src/main/java/org/zstack/loginControl/LoginControlManagerImpl.java:154
# args: 
wrong\ format\ of\ password\ strength\ config = wrong format of password strength config

# at: src/main/java/org/zstack/loginControl/LoginControlManagerImpl.java:143
# args: key
unrecognized\ key\:\ %s = unrecognized key: {0}

# at: src/main/java/org/zstack/loginControl/LoginControlManagerImpl.java:149
# args: opt.get()
missing\ key\:value\ of\ %s = missing key:value of {0}

# at: src/main/java/org/zstack/loginControl/LoginControlManagerImpl.java:158
# args: 
minimum\ can\ not\ be\ larger\ than\ maximum = minimum can not be larger than maximum

# at: src/main/java/org/zstack/loginControl/LoginControlManagerImpl.java:321
# args: results.size()
Consult\ result\ expect\ to\ be\ 1,\ but\ actually\ %s = Consult result expect to be 1, but actually {0}

# at: src/main/java/org/zstack/loginControl/LoginControlManagerImpl.java:505
# args: msg.getResourceName()
No\ available\ processor\ for\ %s = No available processor for {0}

# at: src/main/java/org/zstack/loginControl/LoginControlManagerImpl.java:529
# args: msg.getCaptchaUuid(),msg.getResourceName()
can\ not\ get\ suitable\ captcha\ with[uuid\:%s],\ related\ to\ resourceName[uuid\:%s] = can not get suitable captcha with[uuid:{0}], related to resourceName[uuid:{1}]

# at: src/main/java/org/zstack/longjob/LongJobApiInterceptor.java:69
# args: msg.getJobName()
%s\ is\ not\ an\ API = {0} is not an API

# at: src/main/java/org/zstack/longjob/LongJobApiInterceptor.java:127
# args: 
cannot\ cancel\ longjob\ that\ is\ succeeded = cannot cancel longjob that is succeeded

# at: src/main/java/org/zstack/longjob/LongJobApiInterceptor.java:130
# args: 
cannot\ cancel\ longjob\ that\ is\ failed = cannot cancel longjob that is failed

# at: src/main/java/org/zstack/longjob/LongJobApiInterceptor.java:141
# args: 
delete\ longjob\ only\ when\ it's\ succeeded,\ canceled,\ or\ failed = delete longjob only when it's succeeded, canceled, or failed

# at: src/main/java/org/zstack/longjob/LongJobApiInterceptor.java:152
# args: 
rerun\ longjob\ only\ when\ it's\ succeeded,\ canceled,\ or\ failed = rerun longjob only when it's succeeded, canceled, or failed

# at: src/main/java/org/zstack/longjob/LongJobFactoryImpl.java:31
# args: jobName
%s\ has\ no\ corresponding\ longjob = {0} has no corresponding longjob

# at: src/main/java/org/zstack/mediator/ApiValidator.java:109
# args: l3NetworkUuid,vmNicVO.getL3NetworkUuid()
unable\ to\ attach\ a\ L3\ network.\ The\ cidr\ of\ l3[%s]\ to\ attach\ overlapped\ with\ l3[%s]\ already\ attached\ to\ vm = unable to attach a L3 network. The cidr of l3[{0}] to attach overlapped with l3[{1}] already attached to vm

# at: src/main/java/org/zstack/mediator/ApiValidator.java:141
# args: vm.getName(),vm.getUuid(),StringUtils.join(pfStr, ",")
the\ vm[name\:%s,\ uuid\:%s]\ already\ has\ some\ port\ forwarding\ rules%s\ attached = the vm[name:{0}, uuid:{1}] already has some port forwarding rules{2} attached

# at: src/main/java/org/zstack/mediator/ApiValidator.java:162
# args: vm.getName(),vm.getUuid(),StringUtils.join(eipStr, ",")
the\ vm[name\:%s,\ uuid\:%s]\ already\ has\ some\ EIPs%s\ attached = the vm[name:{0}, uuid:{1}] already has some EIPs{2} attached

# at: src/main/java/org/zstack/mediator/ApiValidator.java:177
# args: msg.getVipUuid(),useForList.toString()
the\ vip[uuid\:%s]\ already\ has\ bound\ to\ other\ service[%s] = the vip[uuid:{0}] already has bound to other service[{1}]

# at: src/main/java/org/zstack/mediator/ApiValidator.java:213
# args: Long.toString(range.getStart()),Long.toString(range.getEnd()),Long.toString(cur.getStart()),Long.toString(cur.getEnd()),vipUuid,protocol
Current\ port\ range[%s,\ %s]\ is\ conflicted\ with\ used\ port\ range\ [%s,\ %s]\ with\ vip[uuid\:\ %s]\ protocol\:\ %s\  = Current port range[{0}, {1}] is conflicted with used port range [{2}, {3}] with vip[uuid: {4}] protocol: {5} 

# at: src/main/java/org/zstack/mediator/ApiValidator.java:240
# args: Long.toString(range.getStart()),Long.toString(range.getEnd()),Long.toString(cur.getStart()),Long.toString(cur.getEnd()),vipUuid,protocol
Current\ port\ range[%s,\ %s]\ is\ conflicted\ with\ system\ service\ port\ range\ [%s,\ %s]\ with\ vip[uuid\:\ %s]\ protocol\:\ %s\  = Current port range[{0}, {1}] is conflicted with system service port range [{2}, {3}] with vip[uuid: {4}] protocol: {5} 

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:772
# args: l3Uuid,systemTag
L3\ network[uuid\:%s]\ not\ found.\ Please\ correct\ your\ system\ tag[%s]\ of\ static\ IP = L3 network[uuid:{0}] not found. Please correct your system tag[{1}] of static IP

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:304
# args: supportSharedVolumePrimaryStorage,psType
for\ shareable\ volume,\ the\ only\ supported\ primary\ storage\ type\ is\ %s,\ current\ is\ %s = for shareable volume, the only supported primary storage type is {0}, current is {1}

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:734
# args: bandwidth,Long.MAX_VALUE
invalid\ volume\ bandwidth[%s]\ is\ larger\ than\ %d = invalid volume bandwidth[{0}] is larger than {1}

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:732
# args: bandwidth
invalid\ volume\ bandwidth[%s]\ is\ not\ a\ number = invalid volume bandwidth[{0}] is not a number

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:729
# args: bandwidth
invalid\ volume\ bandwidth[%s],\ it\ must\ be\ greater\ than\ 1024\ (include\ 1024) = invalid volume bandwidth[{0}], it must be greater than 1024 (include 1024)

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:753
# args: bandwidth
invalid\ volume\ IOPS[%s]\ is\ not\ a\ number = invalid volume IOPS[{0}] is not a number

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:755
# args: bandwidth,Long.MAX_VALUE
invalid\ volume\ IOPS[%s]\ is\ larger\ than\ %d = invalid volume IOPS[{0}] is larger than {1}

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:750
# args: bandwidth
invalid\ volume\ IOPS[%s],\ it\ must\ be\ greater\ than\ 0 = invalid volume IOPS[{0}], it must be greater than 0

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:810
# args: level
Unknown\ code[%s]\ of\ Security\ Level = Unknown code[{0}] of Security Level

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:832
# args: cidr
[%s]\ is\ not\ a\ standard\ cidr = [{0}] is not a standard cidr

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:849
# args: hostUuid,distro,version
the\ host[uuid\:%s]'s\ operating\ system\ %s\ %s\ is\ too\ old,\ the\ QEMU\ doesn't\ support\ QoS\ of\ network\ or\ disk\ IO.\ Please\ choose\ another\ instance\ offering\ with\ no\ QoS\ configuration = the host[uuid:{0}]'s operating system {1} {2} is too old, the QEMU doesn't support QoS of network or disk IO. Please choose another instance offering with no QoS configuration

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1082
# args: newValue
invalid\ value[%s],\ it's\ not\ a\ double = invalid value[{0}], it's not a double

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1050
# args: newValue
invalid\ value[%s],\ it\ must\ be\ a\ double\ greater\ than\ 0 = invalid value[{0}], it must be a double greater than 0

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1079
# args: newValue
invalid\ value[%s],\ it\ must\ be\ a\ double\ between\ (0,\ 1] = invalid value[{0}], it must be a double between (0, 1]

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1093
# args: newValue
invalid\ value[%s],\ ZStack\ doesn't\ have\ such\ host\ allocator\ type = invalid value[{0}], ZStack doesn't have such host allocator type

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1115
# args: MevocoGlobalConfig.AIO_NATIVE.getCanonicalName(),MevocoGlobalConfig.AIO_NATIVE.value(),KVMGlobalConfig.LIBVIRT_CACHE_MODE.getCanonicalName(),KVMGlobalConfig.LIBVIRT_CACHE_MODE.value()
%s\ value\ is[%s],\ which\ is\ conflict\ with\ %s\ value\ [%s] = {0} value is[{1}], which is conflict with {2} value [{3}]

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1371
# args: 
obj\ is\ not\ instanceof\ NicQos! = obj is not instanceof NicQos!

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1732
# args: String.join(",", ips)
unexpected\ host\ management\ IPs\:\ [%s] = unexpected host management IPs: [{0}]

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1864
# args: 
can\ not\ set\ local\ and\ configure\ at\ same\ time = can not set local and configure at same time

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1916
# args: 
can\ not\ find\ node\ A\ config\ info = can not find node A config info

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1926
# args: 
can\ not\ find\ node\ A\ address\ info\ from\ bootstrap\ agent = can not find node A address info from bootstrap agent

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1987
# args: s.getJobUuid()
can\ not\ get\ bootstrap\ job\ %s\ result\ after\ 900s = can not get bootstrap job {0} result after 900s

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1995
# args: ret.getRetCode(),ret.getStdout(),ret.getStderr()
curl\ bootstrap\ agent\ finished,\ return\ code\:\ %s,\ stdout\:\ %s,\ stderr\:\ %s = curl bootstrap agent finished, return code: {0}, stdout: {1}, stderr: {2}

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:2459
# args: errorOfNodeA.getCauses().get(0)
node\ A\ update\ factory\ mode\ failed,\ details\:\ %s = node A update factory mode failed, details: {0}

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:2457
# args: errorCodeList.getCauses().get(0)
all\ management\ node\ update\ factory\ mode\ failed,\ details\:\ %s = all management node update factory mode failed, details: {0}

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:2566
# args: ManagementNodeState.RUNNING
management\ node\ status\ is\ not\ %s = management node status is not {0}

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:2493
# args: r.getStdout()
some\ node\ on\ factory\ mode\ exists,\ detail\ of\ arping\:\ %s = some node on factory mode exists, detail of arping: {0}

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:2514
# args: 
set\ address\ on\ node\ A\ failed = set address on node A failed

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:2511
# args: 
this\ node\ is\ not\ node\ A = this node is not node A

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:2651
# args: bandwidth
networkInboundBandwidth\ format\ error\ %s = networkInboundBandwidth format error {0}

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:2663
# args: bandwidth
networkOutboundBandwidth\ format\ error\ %s = networkOutboundBandwidth format error {0}

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:2660
# args: 
networkOutboundBandwidth\ execeds\ the\ max\ value\ 32G\ bps = networkOutboundBandwidth execeds the max value 32G bps

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:2855
# args: volume.getUuid(),vm.getUuid()
Shareable\ Volume[uuid\:%s]\ has\ already\ been\ attached\ to\ VM[uuid\:%s] = Shareable Volume[uuid:{0}] has already been attached to VM[uuid:{1}]

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:2873
# args: 
shareable\ disk\ only\ support\ virtio-scsi\ type\ for\ now = shareable disk only support virtio-scsi type for now

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:3279
# args: sharedVolUuids
shareable\ volume(s)[uuid\:\ %s]\ attached,\ not\ support\ to\ group\ snapshot. = shareable volume(s)[uuid: {0}] attached, not support to group snapshot.

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:331
# args: vmInstanceVO.getUuid()
How\ can\ a\ Running\ VM[uuid\:%s]\ has\ no\ hostUuid? = How can a Running VM[uuid:{0}] has no hostUuid?

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:329
# args: vmInstanceVO.getUuid()
Unexpectedly,\ VM[uuid\:%s]\ is\ not\ running\ any\ more,\ please\ try\ again\ later = Unexpectedly, VM[uuid:{0}] is not running any more, please try again later

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:719
# args: msg.getVolumeSnapshotJobs().stream().map(CreateVolumesSnapshotsJobStruct::getVolumeUuid).collect(Collectors.toList()),job.getVolumeUuid()
can\ not\ take\ snapshot\ for\ volumes[%s]\ while\ volume[uuid\:\ %s]\ not\ attached = can not take snapshot for volumes[{0}] while volume[uuid: {1}] not attached

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:725
# args: msg.getVolumeSnapshotJobs().stream().map(CreateVolumesSnapshotsJobStruct::getVolumeUuid).collect(Collectors.toList()),job.getVolumeUuid()
can\ not\ take\ snapshot\ for\ volumes[%s]\ while\ volume[uuid\:\ %s]\ appears\ twice = can not take snapshot for volumes[{0}] while volume[uuid: {1}] appears twice

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:732
# args: msg.getVolumeSnapshotJobs().stream().map(CreateVolumesSnapshotsJobStruct::getVolumeUuid).collect(Collectors.toList()),job.getVolumeUuid(),volumeVOS.get(0).getVmInstanceUuid()
can\ not\ take\ snapshot\ for\ volumes[%s]\ attached\ multiple\ vms[%s,\ %s] = can not take snapshot for volumes[{0}] attached multiple vms[{1}, {2}]

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:739
# args: 
no\ volumes\ found = no volumes found

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:971
# args: SizeUnit.BYTE.toGigaByte((double) resize)
this\ snapshot\ recording\ the\ volume\ state\ before\ resize\ to\ %fG\ is\ created\ automatically = this snapshot recording the volume state before resize to {0}G is created automatically

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:1238
# args: msg.getUuid()
DeleteVolumeQos\ [%s]\ ingor\ because\ of\ account\ privilege. = DeleteVolumeQos [{0}] ingor because of account privilege.

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:1270
# args: ivo.getHostUuid(),ivo.getState(),VmInstanceState.Running.toString(),VmInstanceState.Stopped.toString()
Cannot\ delete\ vm's\ volume\ qos\ on\ host\ %s,\ because\ the\ current\ vm\ is\ in\ state\ of\ %s,\ but\ support\ expect\ states\ are\ [%s,\ %s] = Cannot delete vm's volume qos on host {0}, because the current vm is in state of {1}, but support expect states are [{2}, {3}]

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:1428
# args: VolumeQos.getVolumeQosByMode(self.getVolumeQos(), msg.getMode())
non\ admin\ account\ cannot\ set\ bandwidth\ more\ than\ %s = non admin account cannot set bandwidth more than {0}

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:1469
# args: self.getUuid()
volume\ [%s]\ isn't\ attached\ to\ any\ vm,\ cannot\ get\ qos\ by\ forceSync = volume [{0}] isn't attached to any vm, cannot get qos by forceSync

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:1475
# args: self.getUuid()
volume\ [%s]\ isn't\ attached\ to\ any\ vm\ (or\ vm\ is\ not\ existed\ now),\ cannot\ sync\ volume\ qos = volume [{0}] isn't attached to any vm (or vm is not existed now), cannot sync volume qos

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:1480
# args: vm.getUuid()
vm\ [%s]'\ state\ must\ be\ Running\ or\ Paused\ to\ sync\ volume\ qos = vm [{0}]' state must be Running or Paused to sync volume qos

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:1485
# args: 
vm\ [%s]'s\ HostUuid\ is\ null,\ cannot\ sync\ volume\ qos = vm [{0}]'s HostUuid is null, cannot sync volume qos

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:1595
# args: msg.getVolume().getUuid(),msg.getVmInstanceUuid()
failed\ to\ detach\ shareable\ volume[uuid\:%s]\ from\ VmInstance[uuid\:%s] = failed to detach shareable volume[uuid:{0}] from VmInstance[uuid:{1}]

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:1607
# args: StringUtils.join(errors, "\n\n")
failed\ to\ detach\ shareable\ volume\ from\ VmInstance\:[\n%s] = failed to detach shareable volume from VmInstance:[\n{0}]

# at: src/main/java/org/zstack/mevoco/PremiumGlobalConfig.java:27
# args: getName()
the\ current\ version\ of\ license\ does\ not\ support\ modifying\ this\ global\ config\ [name\:%s] = the current version of license does not support modifying this global config [name:{0}]

# at: src/main/java/org/zstack/mevoco/PremiumResourceConfig.java:22
# args: globalConfig.getName()
the\ current\ version\ of\ license\ does\ not\ support\ modifying\ this\ resource\ config\ [name\:%s] = the current version of license does not support modifying this resource config [name:{0}]

# at: src/main/java/org/zstack/mevoco/VolumeQos.java:229
# args: mode
invalid\ volume\ qos\ mode\:\ %s = invalid volume qos mode: {0}

# at: src/main/java/org/zstack/mevoco/VolumeQos.java:199
# args: 
cannot\ find\ mode\ from\ null\ VolumeQos = cannot find mode from null VolumeQos

# at: src/main/java/org/zstack/monitoring/MonitorManagerImpl.java:190
# args: msg.getMonitorTriggerUuid()
cannot\ find\ monitor\ trigger[uuid\:%s],\ it\ may\ have\ been\ deleted = cannot find monitor trigger[uuid:{0}], it may have been deleted

# at: src/main/java/org/zstack/monitoring/MonitorManagerImpl.java:199
# args: msg.getMonitorTriggerActionUuid()
cannot\ find\ monitor\ trigger\ action[uuid\:%s],\ it\ may\ have\ been\ deleted = cannot find monitor trigger action[uuid:{0}], it may have been deleted

# at: src/main/java/org/zstack/monitoring/MonitorManagerImpl.java:243
# args: msg.getResourceType()
the\ resource[type\:%s]\ doesn't\ have\ any\ monitoring\ items = the resource[type:{0}] doesn't have any monitoring items

# at: src/main/java/org/zstack/monitoring/MonitorManagerImpl.java:335
# args: msg.getTargetResourceUuid(),msg.getSession().getAccountUuid()
the\ resource[uuid\:%s]\ doesn't\ belong\ to\ the\ account[uuid\:%s] = the resource[uuid:{0}] doesn't belong to the account[uuid:{1}]

# at: src/main/java/org/zstack/monitoring/MonitorManagerImpl.java:386
# args: resourceUuid
cannot\ find\ type\ for\ the\ resource[uuid\:%s] = cannot find type for the resource[uuid:{0}]

# at: src/main/java/org/zstack/monitoring/MonitorManagerImpl.java:391
# args: resourceType,triggerExpression.getItem()
no\ monitoring\ item\ found\ for\ the\ resourceType[%s]\ and\ item[%s] = no monitoring item found for the resourceType[{0}] and item[{1}]

# at: src/main/java/org/zstack/monitoring/items/AlertText.java:50
# args: args
A\ resource[name\:{resourceName},\ uuid\:{resourceUuid},\ type\:{resourceType}]'s\ monitoring\ trigger[uuid\:{triggerUuid}]\ changes\ status\ to\ {triggerStatus} = A resource[name:'{resourceName}', uuid:'{resourceUuid}', type:'{resourceType}']'s monitoring trigger[uuid:'{triggerUuid}'] changes status to '{triggerStatus}'

# at: src/main/java/org/zstack/monitoring/items/AlertText.java:55
# args: 
\n\=\=\=\ BELOW\ ARE\ DETAILS\ OF\ THE\ PREVIOUS\ ALERT\ \=\=\= = \n=== BELOW ARE DETAILS OF THE PREVIOUS ALERT ===

# at: src/main/java/org/zstack/monitoring/items/AlertText.java:58
# args: 
\nalert\ details\: = \nalert details:

# at: src/main/java/org/zstack/monitoring/items/AlertText.java:59
# args: args
\ncondition\:\ {itemName}\ {operator}\ {threshold} = \ncondition: '{itemName}' '{operator}' '{threshold}'

# at: src/main/java/org/zstack/monitoring/items/AlertText.java:60
# args: args
\ncurrent\ value\:\ {value} = \ncurrent value: '{value}'

# at: src/main/java/org/zstack/monitoring/items/host/HostCpuUtilItem.java:31
# args: 
Host\ CPU\ utilization = Host CPU utilization

# at: src/main/java/org/zstack/monitoring/items/vm/VmCpuUtilItem.java:29
# args: 
VM\ CPU\ utilization = VM CPU utilization

# at: src/main/java/org/zstack/monitoring/prometheus/AlertRuleWriter.java:141
# args: rb.name,r
conflict\ alert\ rule[%s],\ there\ has\ been\ a\ rule[%s]\ with\ the\ same\ name = conflict alert rule[{0}], there has been a rule[{1}] with the same name

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusAlert.java:79
# args: resourceName,resourceUuid,toI18nString(resourceType),itemName,toI18nString(expression.getOperator()),expression.getConstant(),value,tvo.getDuration()
ALERT\:\n\ resource[name\:\ %s,\ uuid\:\ %s,\ type\:\ %s]\nevent\:\ %s\ %s\ %s\ncurrent\ value\:\ %s\nduration\:\ %s\ seconds\n = ALERT:\n resource[name: {0}, uuid: {1}, type: {2}]\nevent: {3} {4} {5}\ncurrent value: {6}\nduration: {7} seconds\n

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusApiInterceptor.java:40
# args: msg.getRelativeTime()
the\ relativeTime[%s]\ is\ invalid,\ it\ must\ be\ in\ format\ of,\ for\ example,\ 10s,\ 1h = the relativeTime[{0}] is invalid, it must be in format of, for example, 10s, 1h

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusApiInterceptor.java:44
# args: msg.getRelativeTime()
the\ relativeTime[%s]\ is\ invalid,\ it's\ too\ big = the relativeTime[{0}] is invalid, it's too big

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostCpuUtilAlertWriter.java:95
# args: 
CPU\ number = CPU number

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostCpuUtilItem.java:70
# args: cpu,trigger.getTargetResourceUuid(),cpuNum
invalid\ cpu[%s],\ the\ host[uuid\:%s]\ doesn't\ have\ a\ CPU\ numbered\ by\ %s = invalid cpu[{0}], the host[uuid:{1}] doesn't have a CPU numbered by {2}

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostDiskCapacityAlertWriter.java:92
# args: 
Host\ Disk\ Capacity = Host Disk Capacity

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostDiskCapacityAlertWriter.java:98
# args: 
Host\ Disk\ Capacity\ type = Host Disk Capacity type

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostDiskCapacityAlertWriter.java:100
# args: 
Host\ devices = Host devices

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostDiskCapacityItem.java:22
# args: type,ALLOWED_TYPES
invalid\ type[%s],\ only\ %s\ are\ allowed = invalid type[{0}], only {1} are allowed

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostNetworkIOAlertWriter.java:77
# args: 
Host = Host

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusMonitorProviderFactory.java:124
# args: ret.get("errorType"),ret.get("error")
query\ failure,\ errorType\:%s,\ error\:\ %s = query failure, errorType:{0}, error: {1}

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusVmCpuUtilAlertWriter.java:81
# args: 
CPU\ Utilization = CPU Utilization

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusVmCpuUtilAlertWriter.java:84
# args: 
CPU\ utilization\ type = CPU utilization type

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusVmDiskIOAlertWriter.java:86
# args: 
Disk\ IO = Disk IO

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusVmDiskIOAlertWriter.java:92
# args: 
Disk\ IO\ direction = Disk IO direction

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusVmDiskIOAlertWriter.java:93
# args: 
Disk\ IO\ type = Disk IO type

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusVmMemUtilAlertWriter.java:77
# args: 
Memory\ Utilization = Memory Utilization

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusVmMemUtilItem.java:57
# args: expression.getConstant()
invalid\ right\ value[%s],\ it\ must\ be\ a\ float\ or\ double\ number = invalid right value[{0}], it must be a float or double number

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusVmMemUtilItem.java:53
# args: expression.getConstant()
invalid\ right\ value[%s],\ it\ must\ be\ float\ or\ double\ number\ greater\ than\ zero\ and\ lesser\ than\ one = invalid right value[{0}], it must be float or double number greater than zero and lesser than one

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusVmMemUtilItem.java:47
# args: expression.getArguments().keySet()
invalid\ arguments\ %s,\ no\ argument\ is\ allowed = invalid arguments {0}, no argument is allowed

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusVmNetworkIOAlertWriter.java:84
# args: 
Network\ IO = Network IO

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusVmNetworkIOAlertWriter.java:89
# args: 
Network\ IO\ direction = Network IO direction

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusVmNetworkIOAlertWriter.java:77
# args: 
Virtual\ Machine = Virtual Machine

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusVmNetworkIOItem.java:22
# args: expression.getConstant()
invalid\ right\ value[%s],\ it\ must\ be\ a\ number(int,\ long,\ float,\ double) = invalid right value[{0}], it must be a number(int, long, float, double)

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusVmNetworkIOItem.java:18
# args: dir,ALLOWED_DIRECTION
invalid\ direction[%s],\ only\ %s\ are\ allowed = invalid direction[{0}], only {1} are allowed

# at: src/main/java/org/zstack/monitoring/trigger/expression/TriggerExpression.java:106
# args: expr,e.getMessage()
invalid\ expression\:\ %s,\ %s = invalid expression: {0}, {1}

# at: src/main/java/org/zstack/monitoring/trigger/expression/TriggerExpression.java:110
# args: expr
invalid\ expression\:\ %s,\ no\ expression\ found = invalid expression: {0}, no expression found

# at: src/main/java/org/zstack/monitoring/trigger/expression/TriggerExpression.java:127
# args: key
missing\ parameter\ '%s'\ in\ the\ expression = missing parameter '{0}' in the expression

# at: src/main/java/org/zstack/monitoring/trigger/expression/TriggerExpression.java:131
# args: key,clz,value.getClass()
wrong\ type\ of\ parameter\ '%s'\ in\ the\ expression,\ it\ must\ be\ type\ of\ %s,\ but\ got\ %s = wrong type of parameter '{0}' in the expression, it must be type of {1}, but got {2}

# at: src/main/java/org/zstack/multicast/router/MulticastRouterApiInterceptor.java:59
# args: rpAddress
Rendezvous\ Point\ [%s]\ is\ not\ a\ unicast\ address = Rendezvous Point [{0}] is not a unicast address

# at: src/main/java/org/zstack/multicast/router/MulticastRouterApiInterceptor.java:63
# args: multicastGroup
group\ address\ [%s]\ is\ not\ a\ multicast\ address = group address [{0}] is not a multicast address

# at: src/main/java/org/zstack/multicast/router/MulticastRouterApiInterceptor.java:75
# args: msg.getRpAddress(),msg.getGroupAddress(),msg.getUuid()
rp\ address\ pair\ [%s\:\ %s]\ already\ existed\ for\ multicast\ router\ [uuid\:%s] = rp address pair [{0}: {1}] already existed for multicast router [uuid:{2}]

# at: src/main/java/org/zstack/multicast/router/MulticastRouterApiInterceptor.java:89
# args: msg.getRpAddress(),msg.getGroupAddress(),msg.getUuid()
rp\ address\ tuple\ [%s\ \:\ %s]\ is\ not\ existed\ for\ multicast\ router\ [uuid\:%s] = rp address tuple [{0} : {1}] is not existed for multicast router [uuid:{2}]

# at: src/main/java/org/zstack/multicast/router/MulticastRouterManagerImpl.java:98
# args: msg.getUuid()
multicastRouter[uuid\:%s]\ has\ not\ been\ attached\ to\ vpc\ router = multicastRouter[uuid:{0}] has not been attached to vpc router

# at: src/main/java/org/zstack/multicast/router/MulticastRouterManagerImpl.java:124
# args: msg.getVpcRouterVmUuid()
multicast\ already\ enabled\ on\ vpc\ router\ uuid[\:%s] = multicast already enabled on vpc router uuid[:{0}]

# at: src/main/java/org/zstack/multicast/router/MulticastRouterManagerImpl.java:316
# args: msg.getUuid()
vpc\ router\ for\ multicast\ router\ [uuid\:%s]\ has\ been\ deleted = vpc router for multicast router [uuid:{0}] has been deleted

# at: src/main/java/org/zstack/multicast/router/MulticastRouterManagerImpl.java:759
# args: msg.getUuid()
multicast\ router\ [uuid\:%s]\ is\ not\ attached\ to\ Vpc\ Router = multicast router [uuid:{0}] is not attached to Vpc Router

# at: src/main/java/org/zstack/multicast/router/backend/MulticastRouterVyosBackendImpl.java:86
# args: vrUuid
multicast\ router\ [uuid\:%s]\ has\ been\ delete\ during\ enable\ multilcast\ on\ backend = multicast router [uuid:{0}] has been delete during enable multilcast on backend

# at: src/main/java/org/zstack/nas/NasFileSystemManagerImpl.java:91
# args: msg.getNasFileSystemUuid()
nas\ file\ system\ [%s]\ is\ not\ existed\ yet = nas file system [{0}] is not existed yet

# at: src/main/java/org/zstack/nas/NasFileSystemManagerImpl.java:139
# args: type
cannot\ find\ nas\ factory\ for\ type\:\ %s = cannot find nas factory for type: {0}

# at: src/main/java/org/zstack/nas/NasFileSystemManagerImpl.java:164
# args: f.getClass().getSimpleName(),old.getClass().getSimpleName(),f.getNasFileSystemType()
duplicate\ NasFileSystemFactory[%s,\ %s]\ for\ type[%s] = duplicate NasFileSystemFactory[{0}, {1}] for type[{2}]

# at: src/main/java/org/zstack/network/l2/L2NetworkApiInterceptor.java:66
# args: msg.getL2NetworkUuid(),msg.getClusterUuid()
l2Network[uuid\:%s]\ has\ attached\ to\ cluster[uuid\:%s],\ can't\ attach\ again = l2Network[uuid:{0}] has attached to cluster[uuid:{1}], can't attach again

# at: src/main/java/org/zstack/network/l2/L2NetworkApiInterceptor.java:75
# args: msg.getL2NetworkUuid(),msg.getClusterUuid()
l2Network[uuid\:%s]\ has\ not\ attached\ to\ cluster[uuid\:%s] = l2Network[uuid:{0}] has not attached to cluster[uuid:{1}]

# at: src/main/java/org/zstack/network/l2/L2NetworkApiInterceptor.java:89
# args: msg.getType()
unsupported\ l2Network\ type[%s] = unsupported l2Network type[{0}]

# at: src/main/java/org/zstack/network/l2/L2NoVlanNetwork.java:558
# args: vl2.getUuid(),vl2.getName(),msg.getClusterUuid(),vl2.getPhysicalInterface(),vl2.getVlan(),tl2.getUuid()
There\ has\ been\ a\ L2VlanNetwork[uuid\:%s,\ name\:%s]\ attached\ to\ cluster[uuid\:%s]\ that\ has\ physical\ interface[%s],\ vlan[%s].\ Failed\ to\ attach\ L2VlanNetwork[uuid\:%s] = There has been a L2VlanNetwork[uuid:{0}, name:{1}] attached to cluster[uuid:{2}] that has physical interface[{3}], vlan[{4}]. Failed to attach L2VlanNetwork[uuid:{5}]

# at: src/main/java/org/zstack/network/l2/L2NoVlanNetwork.java:540
# args: l2.getUuid(),l2.getName(),msg.getClusterUuid(),l2.getPhysicalInterface(),tl2.getUuid()
There\ has\ been\ a\ l2Network[uuid\:%s,\ name\:%s]\ attached\ to\ cluster[uuid\:%s]\ that\ has\ physical\ interface[%s].\ Failed\ to\ attach\ l2Network[uuid\:%s] = There has been a l2Network[uuid:{0}, name:{1}] attached to cluster[uuid:{2}] that has physical interface[{3}]. Failed to attach l2Network[uuid:{4}]

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetwork/VxlanNetworkFactory.java:218
# args: inv.getUuid(),destHostUuid
cannot\ configure\ vxlan\ network\ for\ vm[uuid\:%s]\ on\ the\ destination\ host[uuid\:%s] = cannot configure vxlan network for vm[uuid:{0}] on the destination host[uuid:{1}]

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetworkPool/KVMRealizeL2VxlanNetworkBackend.java:79
# args: vtepIps,hostUuid
find\ multiple\ vtep\ ips[%s]\ for\ one\ host[uuid\:%s],\ need\ to\ delete\ host\ and\ add\ again = find multiple vtep ips[{0}] for one host[uuid:{1}], need to delete host and add again

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetworkPool/KVMRealizeL2VxlanNetworkBackend.java:119
# args: cmd.getBridgeName(),l2Network.getUuid(),l2Network.getType(),l2vxlan.getVni(),hostUuid,rsp.getError()
failed\ to\ create\ bridge[%s]\ for\ l2Network[uuid\:%s,\ type\:%s,\ vni\:%s]\ on\ kvm\ host[uuid\:%s],\ because\ %s = failed to create bridge[{0}] for l2Network[uuid:{1}, type:{2}, vni:{3}] on kvm host[uuid:{4}], because {5}

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetworkPool/KVMRealizeL2VxlanNetworkBackend.java:183
# args: cmd.getCidr(),l2vxlan.getUuid(),l2vxlan.getName(),hostUuid,rsp.getError()
failed\ to\ check\ cidr[%s]\ for\ l2VxlanNetwork[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:%s],\ %s = failed to check cidr[{0}] for l2VxlanNetwork[uuid:{1}, name:{2}] on kvm host[uuid:{3}], {4}

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetworkPool/KVMRealizeL2VxlanNetworkPoolBackend.java:251
# args: l2Network.getUuid(),l2Network.getType(),l2networks,hostUuid,rsp.getError()
failed\ to\ realize\ vxlan\ network\ pool[uuid\:%s,\ type\:%s,\ vnis\:%s]\ on\ kvm\ host[uuid\:%s],\ because\ %s = failed to realize vxlan network pool[uuid:{0}, type:{1}, vnis:{2}] on kvm host[uuid:{3}], because {4}

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetworkPool/KVMRealizeL2VxlanNetworkPoolBackend.java:110
# args: cmd.getCidr(),vxlanPool.getUuid(),vxlanPool.getName(),hostUuid,rsp.getError()
failed\ to\ check\ cidr[%s]\ for\ l2VxlanNetworkPool[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:%s],\ %s = failed to check cidr[{0}] for l2VxlanNetworkPool[uuid:{1}, name:{2}] on kvm host[uuid:{3}], {4}

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetworkPool/VxlanPoolApiInterceptor.java:55
# args: msg.getHostUuid(),msg.getPoolUuid()
vxlan\ vtep\ address\ for\ host\ [uuid\ \:\ %s]\ and\ pool\ [uuid\ \:\ %s]\ pair\ already\ existed = vxlan vtep address for host [uuid : {0}] and pool [uuid : {1}] pair already existed

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetworkPool/VxlanNetworkCheckerImpl.java:36
# args: VxlanSystemTags.VXLAN_POOL_CLUSTER_VTEP_CIDR.getTagFormat()
need\ to\ input\ one\ system\ tag\ like\ \:\ [%s] = need to input one system tag like : [{0}]

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetworkPool/VxlanNetworkCheckerImpl.java:48
# args: tag,VxlanSystemTags.VXLAN_POOL_CLUSTER_VTEP_CIDR.getTagFormat()
wrong\ system\ tag\ [%s],\ should\ be\ like\ \:\ [%s] = wrong system tag [{0}], should be like : [{1}]

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetworkPool/VxlanNetworkCheckerImpl.java:53
# args: tag
wrong\ cidr\ format\ in\ system\ tag\ [%s] = wrong cidr format in system tag [{0}]

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetworkPool/VxlanNetworkCheckerImpl.java:62
# args: inv.getType(),overlappedPool
overlap\ vni\ range\ with\ %s\ [%s] = overlap vni range with {0} [{1}]

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetworkPool/VxlanNetworkCheckerImpl.java:97
# args:
vxlan\ network\ pool\ doesn't\ support\ create\ l3\ network = vxlan network pool doesn't support create l3 network

# at: src/main/java/org/zstack/network/l3/IpNotAvailabilityReason.java:27
# args: 
it\ is\ used = it is used

# at: src/main/java/org/zstack/network/l3/IpNotAvailabilityReason.java:25
# args: 
it\ is\ not\ in\ this\ range = it is not in this range

# at: src/main/java/org/zstack/network/l3/IpNotAvailabilityReason.java:23
# args: 
it\ is\ gateway = it is gateway

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:116
# args: 
you\ must\ update\ system\ and\ category\ both = you must update system and category both

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:355
# args: L3NetworkCategory.validCombination
not\ valid\ combination\ of\ system\ and\ category,only\ %s\ are\ valid = not valid combination of system and category,only {0} are valid

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:161
# args: msg.getIp()
invalid\ IP[%s] = invalid IP[{0}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:145
# args: msg.getL3NetworkUuid()
no\ ip\ range\ in\ l3[%s] = no ip range in l3[{0}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:149
# args: msg.getRouterInterfaceIp(),ipRangeVO.getUuid(),ipRangeVO.getNetworkCidr(),msg.getL3NetworkUuid()
ip[%s]\ is\ not\ in\ the\ cidr\ of\ ip\ range[uuid\:%s,\ cidr\:%s]\ which\ l3\ network[%s]\ attached = ip[{0}] is not in the cidr of ip range[uuid:{1}, cidr:{2}] which l3 network[{3}] attached

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:153
# args: msg.getRouterInterfaceIp(),ipRangeVO.getUuid(),ipRangeVO.getStartIp(),ipRangeVO.getEndIp(),msg.getL3NetworkUuid()
ip[%s]\ in\ ip\ range[uuid\:%s,\ startIp\:%s,\ endIp\:%s]\ which\ l3\ network[%s]\ attached,\ this\ is\ not\ allowed = ip[{0}] in ip range[uuid:{1}, startIp:{2}, endIp:{3}] which l3 network[{4}] attached, this is not allowed

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:167
# args: 
ipRangeUuid\ and\ l3NetworkUuid\ cannot\ both\ be\ null;\ you\ must\ set\ either\ one. = ipRangeUuid and l3NetworkUuid cannot both be null; you must set either one.

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:293
# args: msg.getNetworkCidr()
%s\ is\ not\ a\ valid\ network\ cidr = {0} is not a valid network cidr

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:214
# args: msg.getGateway()
%s\ is\ not\ a\ valid\ ipv6\ address = {0} is not a valid ipv6 address

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:218
# args: msg.getStartIp(),msg.getEndIp(),msg.getPrefixLen(),msg.getGateway()
[startIp\ %s,\ endIp\ %s,\ prefixLen\ %d,\ gateway\ %s]\ is\ not\ a\ valid\ ipv6\ range = [startIp {0}, endIp {1}, prefixLen {2}, gateway {3}] is not a valid ipv6 range

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:228
# args: IPv6Constants.IPV6_PREFIX_LEN_MIN,IPv6Constants.IPV6_PREFIX_LEN_MAX
ip\ range\ prefix\ length\ is\ out\ of\ range\ [%d\ -\ %d]\  = ip range prefix length is out of range [{0} - {1}] 

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:234
# args: l3Vo.getUuid(),l3Vo.getName()
l3\ network\ [uuid\ %s\:\ name\ %s]\ is\ not\ a\ ipv6\ network = l3 network [uuid {0}: name {1}] is not a ipv6 network

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:240
# args: ipr.getAddressMode(),rangeVOS.get(0).getAddressMode()
addressMode[%s]\ is\ different\ from\ L3Netowork\ address\ mode[%s] = addressMode[{0}] is different from L3Netowork address mode[{1}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:246
# args: IPv6Constants.IPV6_STATELESS_PREFIX_LEN
ipv6\ prefix\ length\ must\ be\ %d\ for\ Stateless-DHCP\ or\ SLAAC = ipv6 prefix length must be {0} for Stateless-DHCP or SLAAC

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:256
# args: ipr.getStartIp(),ipr.getEndIp(),r.getStartIp(),r.getEndIp()
new\ ip\ range\ [startip\ \:%s,\ endip\ \:%s]\ is\ overlaped\ with\ old\ ip\ range[startip\ \:%s,\ endip\ \:%s] = new ip range [startip :{0}, endip :{1}] is overlaped with old ip range[startip :{2}, endip :{3}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:266
# args: r.getNetworkCidr(),ipr.getNetworkCidr()
new\ network\ CIDR\ [%s]\ is\ different\ from\ old\ network\ cidr\ [%s] = new network CIDR [{0}] is different from old network cidr [{1}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:468
# args: ipr.getGateway(),r.getGateway()
new\ add\ ip\ range\ gateway\ %s\ is\ different\ from\ old\ gateway\ %s = new add ip range gateway {0} is different from old gateway {1}

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:286
# args: msg.getNetworkCidr()
%s\ is\ not\ an\ allowed\ network\ cidr,\ because\ it\ doesn't\ have\ usable\ ip\ range = {0} is not an allowed network cidr, because it doesn't have usable ip range

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:290
# args: msg.getGateway(),msg.getNetworkCidr()
%s\ is\ not\ the\ first\ or\ last\ address\ of\ the\ cidr\ %s = {0} is not the first or last address of the cidr {1}

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:313
# args: 
ipRangeUuids,\ L3NetworkUuids,\ zoneUuids\ must\ have\ at\ least\ one\ be\ none-empty\ list,\ or\ all\ is\ set\ to\ true = ipRangeUuids, L3NetworkUuids, zoneUuids must have at least one be none-empty list, or all is set to true

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:334
# args: msg.getType()
unsupported\ l3network\ type[%s] = unsupported l3network type[{0}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:340
# args: msg.getDnsDomain()
%s\ is\ not\ a\ valid\ domain\ name = {0} is not a valid domain name

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:382
# args: l3Vo.getUuid(),l3Vo.getName()
l3\ network\ [uuid\ %s\:\ name\ %s]\ is\ not\ a\ ipv4\ network = l3 network [uuid {0}: name {1}] is not a ipv4 network

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:386
# args: ipr.getStartIp(),ipr.getEndIp()
the\ IP\ range[%s\ ~\ %s]\ contains\ D\ class\ addresses\ which\ are\ for\ multicast = the IP range[{0} ~ {1}] contains D class addresses which are for multicast

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:390
# args: ipr.getStartIp(),ipr.getEndIp()
the\ IP\ range[%s\ ~\ %s]\ contains\ E\ class\ addresses\ which\ are\ reserved = the IP range[{0} ~ {1}] contains E class addresses which are reserved

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:394
# args: ipr.getStartIp(),ipr.getEndIp()
the\ IP\ range[%s\ ~\ %s]\ contains\ link\ local\ addresses\ which\ are\ reserved = the IP range[{0} ~ {1}] contains link local addresses which are reserved

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:400
# args: ipr.getGateway(),ipr.getStartIp(),ipr.getNetmask()
the\ gateway[%s]\ is\ not\ in\ the\ subnet\ %s/%s = the gateway[{0}] is not in the subnet {1}/{2}

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:404
# args: ipr.getEndIp(),ipr.getStartIp(),ipr.getNetmask()
the\ endip[%s]\ is\ not\ in\ the\ subnet\ %s/%s = the endip[{0}] is not in the subnet {1}/{2}

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:408
# args: ipr.getStartIp()
start\ ip[%s]\ is\ not\ a\ IPv4\ address = start ip[{0}] is not a IPv4 address

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:412
# args: ipr.getEndIp()
end\ ip[%s]\ is\ not\ a\ IPv4\ address = end ip[{0}] is not a IPv4 address

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:416
# args: ipr.getGateway()
gateway[%s]\ is\ not\ a\ IPv4\ address = gateway[{0}] is not a IPv4 address

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:420
# args: ipr.getNetmask()
netmask[%s]\ is\ not\ a\ netmask,\ and\ the\ IP\ range\ netmask\ cannot\ be\ 0.0.0.0 = netmask[{0}] is not a netmask, and the IP range netmask cannot be 0.0.0.0

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:424
# args: 
ip\ allocation\ can\ not\ contain\ network\ address\ or\ broadcast\ address = ip allocation can not contain network address or broadcast address

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:432
# args: ipr.getStartIp(),ipr.getEndIp()
start\ ip[%s]\ is\ behind\ end\ ip[%s] = start ip[{0}] is behind end ip[{1}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:437
# args: ipr.getGateway(),ipr.getStartIp(),ipr.getEndIp()
gateway[%s]\ can\ not\ be\ part\ of\ range[%s,\ %s] = gateway[{0}] can not be part of range[{1}, {2}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:448
# args: r.getUuid(),r.getStartIp(),r.getEndIp()
overlap\ with\ ip\ range[uuid\:%s,\ start\ ip\:%s,\ end\ ip\:\ %s] = overlap with ip range[uuid:{0}, start ip:{1}, end ip: {2}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:458
# args: r.getUuid(),rcidr,cidr
multiple\ CIDR\ on\ the\ same\ L3\ network\ is\ not\ allowed.\ There\ has\ been\ a\ IP\ range[uuid\:%s,\ CIDR\:%s],\ the\ new\ IP\ range[CIDR\:%s]\ is\ not\ in\ the\ CIDR\ with\ the\ existing\ one = multiple CIDR on the same L3 network is not allowed. There has been a IP range[uuid:{0}, CIDR:{1}], the new IP range[CIDR:{2}] is not in the CIDR with the existing one

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:490
# args: manner,ip
%s[%s]\ is\ not\ a\ IPv6\ address = {0}[{1}] is not a IPv6 address

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:486
# args: manner,ip
%s[%s]\ is\ not\ a\ IPv4\ address = {0}[{1}] is not a IPv4 address

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:502
# args: msg.getDns(),msg.getL3NetworkUuid()
there\ has\ been\ a\ DNS[%s]\ on\ L3\ network[uuid\:%s] = there has been a DNS[{0}] on L3 network[uuid:{1}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:525
# args: msg.getL3NetworkUuid()
prefix\ [%s]\ is\ not\ a\ IPv4\ network\ cidr = prefix [{0}] is not a IPv4 network cidr

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:512
# args: msg.getNexthop()
nexthop[%s]\ is\ not\ a\ IPv4\ address = nexthop[{0}] is not a IPv4 address

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:519
# args: msg.getPrefix(),msg.getL3NetworkUuid()
there\ has\ been\ a\ hostroute\ for\ prefix[%s]\ on\ L3\ network[uuid\:%s] = there has been a hostroute for prefix[{0}] on L3 network[uuid:{1}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:532
# args: msg.getPrefix(),msg.getL3NetworkUuid()
there\ is\ no\ hostroute\ for\ prefix[%s]\ on\ L3\ network[uuid\:%s] = there is no hostroute for prefix[{0}] on L3 network[uuid:{1}]

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:171
# args: wrongUuids,securityGroupUuid
VM\ nics[uuids\:%s]\ are\ not\ on\ L3\ networks\ that\ have\ been\ attached\ to\ the\ security\ group[uuid\:%s] = VM nics[uuids:{0}] are not on L3 networks that have been attached to the security group[uuid:{1}]

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:69
# args: msg.getSecurityGroupUuid(),msg.getL3NetworkUuid()
security\ group[uuid\:%s]\ has\ not\ attached\ to\ l3Network[uuid\:%s],\ can't\ detach = security group[uuid:{0}] has not attached to l3Network[uuid:{1}], can't detach

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:117
# args: msg.getSecurityGroupUuid(),msg.getL3NetworkUuid()
security\ group[uuid\:%s]\ has\ attached\ to\ l3Network[uuid\:%s],\ can't\ attach\ again = security group[uuid:{0}] has attached to l3Network[uuid:{1}], can't attach again

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:125
# args: msg.getL3NetworkUuid(),SecurityGroupConstant.SECURITY_GROUP_NETWORK_SERVICE_TYPE
the\ L3\ network[uuid\:%s]\ doesn't\ have\ the\ network\ service\ type[%s]\ enabled = the L3 network[uuid:{0}] doesn't have the network service type[{1}] enabled

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:131
# args: msg.getL3NetworkUuid(),l3Vo.getIpVersion(),msg.getSecurityGroupUuid(),sgVo.getIpVersion()
the\ L3\ network[uuid\:%s]\ ipVersion\ [%d]\ is\ different\ from\ securityGroup\ [uuid\:%s]\ ipVersion\ [%d] = the L3 network[uuid:{0}] ipVersion [{1}] is different from securityGroup [uuid:{2}] ipVersion [{3}]

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:214
# args: JSONObjectUtil.toJsonString(ao)
rule\ type\ can\ not\ be\ null.\ rule\ dump\:\ %s = rule type can not be null. rule dump: {0}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:219
# args: ao.getType(),JSONObjectUtil.toJsonString(ao)
unknown\ rule\ type[%s],\ rule\ can\ only\ be\ Ingress/Egress.\ rule\ dump\:\ %s = unknown rule type[{0}], rule can only be Ingress/Egress. rule dump: {1}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:225
# args: JSONObjectUtil.toJsonString(ao)
protocol\ can\ not\ be\ null.\ rule\ dump\:\ %s = protocol can not be null. rule dump: {0}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:231
# args: ao.getProtocol(),JSONObjectUtil.toJsonString(ao)
invalid\ protocol[%s].\ Valid\ protocols\ are\ [TCP,\ UDP,\ ICMP,\ ALL].\ rule\ dump\:\ %s = invalid protocol[{0}]. Valid protocols are [TCP, UDP, ICMP, ALL]. rule dump: {1}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:238
# args: JSONObjectUtil.toJsonString(ao)
can\ not\ set\ port\ for\ protocol\ [type\:ALL].\ rule\ dump\:\ %s = can not set port for protocol [type:ALL]. rule dump: {0}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:236
# args: JSONObjectUtil.toJsonString(ao)
startPort\ can\ not\ be\ null.\ rule\ dump\:\ %s = startPort can not be null. rule dump: {0}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:250
# args: ao.getStartPort(),JSONObjectUtil.toJsonString(ao)
invalid\ startPort[%s].\ Valid\ range\ is\ [0,\ 65535].\ rule\ dump\:\ %s = invalid startPort[{0}]. Valid range is [0, 65535]. rule dump: {1}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:243
# args: ao.getStartPort(),JSONObjectUtil.toJsonString(ao)
invalid\ ICMP\ type[%s].\ Valid\ type\ is\ [-1,\ 255].\ rule\ dump\:\ %s = invalid ICMP type[{0}]. Valid type is [-1, 255]. rule dump: {1}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:269
# args: ao.getEndPort(),JSONObjectUtil.toJsonString(ao)
invalid\ endPort[%s].\ Valid\ range\ is\ [0,\ 65535].\ rule\ dump\:\ %s = invalid endPort[{0}]. Valid range is [0, 65535]. rule dump: {1}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:262
# args: ao.getEndPort(),JSONObjectUtil.toJsonString(ao)
invalid\ ICMP\ code[%s].\ Valid\ range\ is\ [-1,\ 3].\ rule\ dump\:\ %s = invalid ICMP code[{0}]. Valid range is [-1, 3]. rule dump: {1}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:279
# args: ao.getAllowedCidr(),JSONObjectUtil.toJsonString(ao)
invalid\ CIDR[%s].\ rule\ dump\:\ %s = invalid CIDR[{0}]. rule dump: {1}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:283
# args: sgVo.getIpVersion(),ao.getIpVersion()
security\ group\ rule\ ipVersion\ [%d]\ is\ different\ from\ security\ group\ version\ [%d] = security group rule ipVersion [{0}] is different from security group version [{1}]

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:292
# args: JSONObjectUtil.toJsonString(msg.getRules().get(j))
rule\ should\ not\ be\ duplicated.\ rule\ dump\:\ %s = rule should not be duplicated. rule dump: {0}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:318
# args: JSONObjectUtil.toJsonString(sao),svo.getRemoteSecurityGroupUuid()
rule\ exist.\ rule\ dump\:\ %s,\ remoteSecurityGroupUuid\:[%s] = rule exist. rule dump: {0}, remoteSecurityGroupUuid:[{1}]

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:345
# args: rsgVo.getIpVersion(),sgVo.getIpVersion()
remote\ security\ group\ ipVersion\ [%d]\ is\ different\ from\ security\ group\ version\ [%d] = remote security group ipVersion [{0}] is different from security group version [{1}]

# at: src/main/java/org/zstack/network/service/HostRouteExtension.java:88
# args: msg.getL3NetworkUuid()
L3Network\ [uuid\:\ %s]\ provide\ type\ null = L3Network [uuid: {0}] provide type null

# at: src/main/java/org/zstack/network/service/HostRouteExtension.java:113
# args: msg.getL3NetworkUuid()
L3Network\ [uuid\:\ %s]\ does\ not\ have\ host\ route\ service = L3Network [uuid: {0}] does not have host route service

# at: src/main/java/org/zstack/network/service/NetworkServiceApiInterceptor.java:41
# args: 
networkServices\ cannot\ be\ empty = networkServices cannot be empty

# at: src/main/java/org/zstack/network/service/NetworkServiceApiInterceptor.java:62
# args: puuid
network\ service\ for\ provider[uuid\:%s]\ must\ be\ specified = network service for provider[uuid:{0}] must be specified

# at: src/main/java/org/zstack/network/service/NetworkServiceApiInterceptor.java:67
# args: puuid
cannot\ find\ network\ service\ provider[uuid\:%s]\ or\ it\ provides\ no\ services = cannot find network service provider[uuid:{0}] or it provides no services

# at: src/main/java/org/zstack/network/service/NetworkServiceApiInterceptor.java:81
# args: puuid,notSupported
network\ service\ provider[uuid\:%s]\ doesn't\ provide\ services%s = network service provider[uuid:{0}] doesn't provide services{1}

# at: src/main/java/org/zstack/network/service/NetworkServiceApiInterceptor.java:93
# args: type,msg.getL3NetworkUuid()
there\ has\ been\ a\ network\ service[%s]\ attached\ to\ L3\ network[uuid\:%s] = there has been a network service[{0}] attached to L3 network[uuid:{1}]

# at: src/main/java/org/zstack/network/service/NetworkServiceManagerImpl.java:342
# args: l3NetworkUuid,serviceType
L3Network[uuid\:%s]\ doesn't\ have\ network\ service[type\:%s]\ enabled\ or\ no\ provider\ provides\ this\ network\ service = L3Network[uuid:{0}] doesn't have network service[type:{1}] enabled or no provider provides this network service

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:82
# args: 
either\ eipUuid\ or\ vipUuid\ must\ be\ set = either eipUuid or vipUuid must be set

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:88
# args: msg.getEipUuid()
eip[uuid\:%s]\ is\ not\ in\ state\ of\ Enabled,\ cannot\ get\ attachable\ vm\ nic = eip[uuid:{0}] is not in state of Enabled, cannot get attachable vm nic

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:103
# args: guestIpUuid,vmNicUuid
ip\ [uuid\:%s]\ is\ attached\ to\ vm\ nic\ [%s] = ip [uuid:{0}] is attached to vm nic [{1}]

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:114
# args: msg.getEipUuid(),vmNicUuid
eip[uuid\:%s]\ has\ attached\ to\ another\ vm\ nic[uuid\:%s],\ can't\ attach\ again = eip[uuid:{0}] has attached to another vm nic[uuid:{1}], can't attach again

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:120
# args: msg.getEipUuid(),EipState.Enabled,state
eip[uuid\:\ %s]\ can\ only\ be\ attached\ when\ state\ is\ %s,\ current\ state\ is\ %s = eip[uuid: {0}] can only be attached when state is {1}, current state is {2}

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:150
# args: msg.getVmNicUuid(),msg.getEipUuid()
guest\ l3Network\ of\ vm\ nic[uuid\:%s]\ and\ vip\ l3Network\ of\ EIP[uuid\:%s]\ are\ the\ same\ network = guest l3Network of vm nic[uuid:{0}] and vip l3Network of EIP[uuid:{1}] are the same network

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:167
# args: msg.getEipUuid(),msg.getVmNicUuid()
Ip\ address\ [uuid\:%s]\ is\ not\ belonged\ to\ nic\ [uuid\:%s] = Ip address [uuid:{0}] is not belonged to nic [uuid:{1}]

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:180
# args: msg.getUuid()
eip[uuid\:%s]\ has\ not\ attached\ to\ any\ vm\ nic = eip[uuid:{0}] has not attached to any vm nic

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:203
# args: vipIp.getIpVersion(),guestIp.getIpVersion()
vip\ ipVersion\ [%d]\ is\ different\ from\ guestIp\ ipVersion\ [%d]. = vip ipVersion [{0}] is different from guestIp ipVersion [{1}].

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:210
# args: vipIp.getIp(),guestRange.getStartIp(),guestRange.getEndIp()
Vip[%s]\ is\ in\ the\ guest\ ip\ range\ [%s,\ %s] = Vip[{0}] is in the guest ip range [{1}, {2}]

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:230
# args: vmUuid,vip.getL3NetworkUuid(),vip.getUuid(),vip.getName(),vip.getIp()
the\ vm[uuid\:%s]\ that\ the\ EIP\ is\ about\ to\ attach\ is\ already\ on\ the\ public\ network[uuid\:%s]\ from\ which\ the\ vip[uuid\:%s,\ name\:%s,\ ip\:%s]\ comes = the vm[uuid:{0}] that the EIP is about to attach is already on the public network[uuid:{1}] from which the vip[uuid:{2}, name:{3}, ip:{4}] comes

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:241
# args: msg.getVipUuid(),useForList.toString()
vip[uuid\:%s]\ has\ been\ occupied\ other\ network\ service\ entity[%s] = vip[uuid:{0}] has been occupied other network service entity[{1}]

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:246
# args: msg.getVipUuid(),VipState.Enabled,vip.getState()
vip[uuid\:%s]\ is\ not\ in\ state[%s],\ current\ state\ is\ %s = vip[uuid:{0}] is not in state[{1}], current state is {2}

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:281
# args: state.toString()
vm\ state[%s]\ is\ not\ allowed\ to\ operate\ eip,\ maybe\ you\ should\ wait\ the\ vm\ process\ complete = vm state[{0}] is not allowed to operate eip, maybe you should wait the vm process complete

# at: src/main/java/org/zstack/network/service/eip/EipManagerImpl.java:944
# args: eip.getGuestIp(),nicIps
cannot\ find\ Eip\ guest\ ip\:\ %s\ in\ vmNic\ ips\ \:%s = cannot find Eip guest ip: {0} in vmNic ips :{1}

# at: src/main/java/org/zstack/network/service/eip/EipManagerImpl.java:1305
# args: l3.getUuid(),l3.getName(),vm.getUuid(),vm.getName()
unable\ to\ attach\ the\ L3\ network[uuid\:%s,\ name\:%s]\ to\ the\ vm[uuid\:%s,\ name\:%s],\ because\ the\ L3\ network\ is\ providing\ EIP\ to\ one\ of\ the\ vm's\ nic = unable to attach the L3 network[uuid:{0}, name:{1}] to the vm[uuid:{2}, name:{3}], because the L3 network is providing EIP to one of the vm's nic

# at: src/main/java/org/zstack/network/service/flat/FlatApiInterceptor.java:39
# args: 
Session/account\ uuid\ is\ not\ valid. = Session/account uuid is not valid.

# at: src/main/java/org/zstack/network/service/flat/FlatApiInterceptor.java:43
# args: accountUuid,msg.getL3NetworkUuid()
the\ account[uuid\:%s]\ has\ no\ access\ to\ the\ resource[uuid\:%s,\ type\:L3NetworkVO] = the account[uuid:{0}] has no access to the resource[uuid:{1}, type:L3NetworkVO]

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:712
# args: 
l3\ network\ uuid\ cannot\ be\ null = l3 network uuid cannot be null

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:728
# args: msg.getL3NetworkUuid()
Cannot\ find\ DhcpIp\ for\ l3\ network[uuid\:%s] = Cannot find DhcpIp for l3 network[uuid:{0}]

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:823
# args: msg.getL3NetworkUuid()
L3\ network[uuid\:%s]\ does\ not\ have\ any\ iprange = L3 network[uuid:{0}] does not have any iprange

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:1089
# args: inv.getUuid(),destHostUuid
cannot\ configure\ DHCP\ for\ vm[uuid\:%s]\ on\ the\ destination\ host[uuid\:%s] = cannot configure DHCP for vm[uuid:{0}] on the destination host[uuid:{1}]

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:1959
# args: dhcpServerIp
DHCP\ server\ ip\ [%s]\ is\ not\ a\ IPv6\ address = DHCP server ip [{0}] is not a IPv6 address

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:1955
# args: dhcpServerIp,inv.getNetworkCidr()
DHCP\ server\ ip\ [%s]\ is\ not\ in\ the\ cidr\ [%s] = DHCP server ip [{0}] is not in the cidr [{1}]

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:1951
# args: dhcpServerIp
DHCP\ server\ ip\ [%s]\ is\ not\ a\ IPv4\ address = DHCP server ip [{0}] is not a IPv4 address

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:1970
# args: IPv6NetworkUtils.ipv6TagValueToAddress(oldDhcpServer),inv.getL3NetworkUuid()
DHCP\ server\ ip\ [%s]\ is\ already\ existed\ in\ l3\ network\ [%s] = DHCP server ip [{0}] is already existed in l3 network [{1}]

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:1975
# args: dhcpServerIp
DHCP\ server\ ip\ [%s]\ can\ not\ be\ equaled\ to\ gateway\ ip = DHCP server ip [{0}] can not be equaled to gateway ip

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:1981
# args: dhcpServerIp
DHCP\ server\ ip\ [%s]\ can\ not\ be\ configured\ to\ system\ l3 = DHCP server ip [{0}] can not be configured to system l3

# at: src/main/java/org/zstack/network/service/flat/FlatEipApiInterceptor.java:99
# args: vmNicUuid
L2Network\ where\ vip's\ L3Network\ based\ hasn't\ attached\ the\ cluster\ where\ vmNic[uuid\:%s]\ located = L2Network where vip's L3Network based hasn't attached the cluster where vmNic[uuid:{0}] located

# at: src/main/java/org/zstack/network/service/flat/FlatEipBackend.java:573
# args: vmUuid,vm.getState()
unable\ to\ apply\ the\ EIP\ operation\ for\ the\ the\ vm[uuid\:%s,\ state\:%s],\ because\ cannot\ find\ the\ VM's\ hostUUid = unable to apply the EIP operation for the the vm[uuid:{0}, state:{1}], because cannot find the VM's hostUUid

# at: src/main/java/org/zstack/network/service/flat/FlatUserdataBackend.java:353
# args: struct.getHostUuid()
host[uuid\:%s]\ is\ not\ connected = host[uuid:{0}] is not connected

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:672
# args: target
invalid\ health\ target[%s],\ the\ format\ is\ targetCheckProtocol\:port,\ for\ example,\ tcp\:default = invalid health target[{0}], the format is targetCheckProtocol:port, for example, tcp:default

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:121
# args: msg.getUuid(),refs
the\ access\ control\ list\ group[%s]\ is\ being\ used\ by\ the\ load\ balancer\ listeners[%s] = the access control list group[{0}] is being used by the load balancer listeners[{1}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:203
# args: ipVer
operation\ failure,\ not\ support\ the\ ip\ version\ %d = operation failure, not support the ip version {0}

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:209
# args: ips,acl.getUuid()
operation\ failure,\ duplicate/overlap\ ip\ entry\ in\ %s\ of\ accesscontrol\ list\ group\:%s = operation failure, duplicate/overlap ip entry in {0} of accesscontrol list group:{1}

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:216
# args: ips
operation\ failure,\ ip\ format\ only\ supports\ ip/iprange/cidr,\ but\ find\ %s = operation failure, ip format only supports ip/iprange/cidr, but find {0}

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:220
# args: startIp,endIp,NetworkUtils.longToIpv4String(r.lowerEndpoint()),NetworkUtils.longToIpv4String(r.upperEndpoint()),acl.getUuid()
ip\ range[%s,\ %s]\ is\ overlap\ with\ start\ ip\:%s,\ end\ ip\:\ %s\ of\ access-control-list\ group\:%s = ip range[{0}, {1}] is overlap with start ip:{2}, end ip: {3} of access-control-list group:{4}

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:242
# args: aclUuids,lbUuid
Can't\ attach\ the\ type\ access-control-list\ group[%s]\ whose\ ip\ version\ is\ different\ with\ LoadBalancer[%s] = Can't attach the type access-control-list group[{0}] whose ip version is different with LoadBalancer[{1}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:302
# args: existingAcls,msg.getListenerUuid()
the\ access-control-list\ groups[uuid\:%s]\ are\ already\ on\ the\ load\ balancer\ listener[uuid\:%s] = the access-control-list groups[uuid:{0}] are already on the load balancer listener[uuid:{1}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:308
# args: msg.getListenerUuid(),type.toString()
the\ load\ balancer\ listener[uuid\:%s]\ just\ only\ attach\ the\ %s\ type\ access-control-list\ group = the load balancer listener[uuid:{0}] just only attach the {1} type access-control-list group

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:313
# args: msg.getListenerUuid(),LoadBalancerGlobalConfig.ACL_MAX_COUNT.value(Long.class)
the\ load\ balancer\ listener[uuid\:%s]\ can't\ \ attach\ more\ than\ %d\ access-control-list\ groups = the load balancer listener[uuid:{0}] can't  attach more than {1} access-control-list groups

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:339
# args: l3Uuids,LoadBalancerConstants.LB_NETWORK_SERVICE_TYPE_STRING
L3\ networks[uuids\:%s]\ of\ the\ vm\ nics\ has\ no\ network\ service[%s]\ enabled = L3 networks[uuids:{0}] of the vm nics has no network service[{1}] enabled

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:349
# args: existingNics,msg.getListenerUuid()
the\ vm\ nics[uuid\:%s]\ are\ already\ on\ the\ load\ balancer\ listener[uuid\:%s] = the vm nics[uuid:{0}] are already on the load balancer listener[uuid:{1}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:678
# args: listenerVO.getProtocol(),msg.getHealthCheckProtocol()
the\ listener\ with\ protocol\ [%s]\ doesn't\ support\ this\ health\ check\:[%s] = the listener with protocol [{0}] doesn't support this health check:[{1}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:652
# args: 
the\ http\ health\ check\ protocol\ must\ be\ specified\ its\ healthy\ checking\ parameter\ healthCheckURI = the http health check protocol must be specified its healthy checking parameter healthCheckURI

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:659
# args: msg.getHealthCheckHttpCode()
the\ http\ health\ check\ protocol's\ expecting\ code\ [%s]\ is\ invalidate = the http health check protocol's expecting code [{0}] is invalidate

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:457
# args: LoadBalancerGlobalConfig.ACL_MAX_COUNT.value(Long.class)
Can't\ attach\ more\ than\ %d\ access-control-list\ groups\ to\ a\ listener = Can't attach more than {0} access-control-list groups to a listener

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:537
# args: tag,s,LoadBalancerConstants.MAX_CONNECTION_LIMIT
invalid\ max\ connection[%s],\ %s\ is\ larger\ than\ upper\ threshold\ %d = invalid max connection[{0}], {1} is larger than upper threshold {2}

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:559
# args: msg.getLoadBalancerPort(),luuid
conflict\ loadBalancerPort[%s],\ a\ listener[uuid\:%s]\ has\ used\ that\ port = conflict loadBalancerPort[{0}], a listener[uuid:{1}] has used that port

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:564
# args: 
udp\ port\ 53\ is\ used\ by\ dns\ daemon = udp port 53 is used by dns daemon

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:577
# args: 
tcp\ port\ 22,\ 7272\ is\ used\ by\ vrouter = tcp port 22, 7272 is used by vrouter

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:604
# args: vo.getProtocol()
loadbalancer\ listener\ with\ type\ %s\ does\ not\ need\ certificate = loadbalancer listener with type {0} does not need certificate

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:608
# args: msg.getListenerUuid(),msg.getCertificateUuid()
loadbalancer\ listener\ [uuid\:%s]\ already\ had\ certificate[uuid\:%s] = loadbalancer listener [uuid:{0}] already had certificate[uuid:{1}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:618
# args: msg.getCertificateUuid(),msg.getListenerUuid()
certificate\ [uuid\:%s]\ is\ not\ added\ to\ loadbalancer\ listener\ [uuid\:%s] = certificate [uuid:{0}] is not added to loadbalancer listener [uuid:{1}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:633
# args: target
healthCheck\ target\ [%s]\ error,\ it\ must\ be\ 'default'\ or\ number\ between[1~65535]\  = healthCheck target [{0}] error, it must be 'default' or number between[1~65535] 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:683
# args: 
the\ http\ health\ check\ protocol\ must\ be\ specified\ its\ healthy\ checking\ parameters\ including\ healthCheckMethod\ and\ healthCheckURI = the http health check protocol must be specified its healthy checking parameters including healthCheckMethod and healthCheckURI

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerBase.java:1113
# args: msg.getVmNicUuids().get(0)
the\ L3\ network\ of\ vm\ nic[uuid\:%s]\ doesn't\ have\ load\ balancer\ service\ enabled = the L3 network of vm nic[uuid:{0}] doesn't have load balancer service enabled

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerBase.java:1140
# args: self.getUuid(),self.getProviderType(),msg.getVmNicUuids().get(0),providerType
service\ provider\ type\ mismatching.\ The\ load\ balancer[uuid\:%s]\ is\ provided\ by\ the\ service\ provider[type\:%s],\ but\ the\ L3\ network\ of\ vm\ nic[uuid\:%s]\ is\ enabled\ with\ the\ service\ provider[type\:\ %s] = service provider type mismatching. The load balancer[uuid:{0}] is provided by the service provider[type:{1}], but the L3 network of vm nic[uuid:{2}] is enabled with the service provider[type: {3}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerBase.java:1670
# args: param
invalid\ health\ checking\ parameters[%s],\ the\ format\ is\ method\:URI\:code,\ for\ example,\ GET\:/index.html\:http_2xx = invalid health checking parameters[{0}], the format is method:URI:code, for example, GET:/index.html:http_2xx

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:99
# args: msg.getLoadBalancerUuid()
cannot\ find\ the\ load\ balancer[uuid\:%s] = cannot find the load balancer[uuid:{0}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:381
# args: tag.getTag()
cannot\ delete\ the\ system\ tag[%s].\ The\ load\ balancer\ plugin\ relies\ on\ it,\ you\ can\ only\ update\ it = cannot delete the system tag[{0}]. The load balancer plugin relies on it, you can only update it

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:399
# args: nicUuid,systemTag
nic[uuid\:%s]\ not\ found.\ Please\ correct\ your\ system\ tag[%s]\ of\ loadbalancer = nic[uuid:{0}] not found. Please correct your system tag[{1}] of loadbalancer

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:411
# args: systemTag,s
invalid\ balancer\ weight[%s],\ %s\ is\ not\ a\ number = invalid balancer weight[{0}], {1} is not a number

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:407
# args: systemTag,s,LoadBalancerConstants.BALANCER_WEIGHT_MIN,LoadBalancerConstants.BALANCER_WEIGHT_MAX
invalid\ balancer\ weight[%s],\ %s\ is\ not\ in\ the\ range\ [%d,\ %d] = invalid balancer weight[{0}], {1} is not in the range [{2}, {3}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:423
# args: algorithm,LoadBalancerConstants.BALANCE_ALGORITHMS
invalid\ balance\ algorithm[%s],\ valid\ algorithms\ are\ %s = invalid balance algorithm[{0}], valid algorithms are {1}

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:497
# args: systemTag,s
invalid\ unhealthy\ threshold[%s],\ %s\ is\ not\ a\ number = invalid unhealthy threshold[{0}], {1} is not a number

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:511
# args: systemTag,s
invalid\ healthy\ threshold[%s],\ %s\ is\ not\ a\ number = invalid healthy threshold[{0}], {1} is not a number

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:525
# args: systemTag,s
invalid\ healthy\ timeout[%s],\ %s\ is\ not\ a\ number = invalid healthy timeout[{0}], {1} is not a number

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:539
# args: systemTag,s
invalid\ connection\ idle\ timeout[%s],\ %s\ is\ not\ a\ number = invalid connection idle timeout[{0}], {1} is not a number

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:553
# args: systemTag,s
invalid\ health\ check\ interval[%s],\ %s\ is\ not\ a\ number = invalid health check interval[{0}], {1} is not a number

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:567
# args: systemTag,s
invalid\ max\ connection[%s],\ %s\ is\ not\ a\ number = invalid max connection[{0}], {1} is not a number

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:585
# args: systemTag,protocol,LoadBalancerConstants.HEALTH_CHECK_TARGET_PROTOCOLS
invalid\ health\ target[%s],\ the\ target\ checking\ protocol[%s]\ is\ invalid,\ valid\ protocols\ are\ %s = invalid health target[{0}], the target checking protocol[{1}] is invalid, valid protocols are {2}

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:597
# args: systemTag,port
invalid\ invalid\ health\ target[%s],\ port[%s]\ is\ not\ a\ number = invalid invalid health target[{0}], port[{1}] is not a number

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:594
# args: systemTag,port
invalid\ invalid\ health\ target[%s],\ port[%s]\ is\ not\ in\ the\ range\ of\ [1,\ 65535] = invalid invalid health target[{0}], port[{1}] is not in the range of [1, 65535]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerWeightOperator.java:74
# args: nicUuid,weight,LoadBalancerConstants.BALANCER_WEIGHT_MIN,LoadBalancerConstants.BALANCER_WEIGHT_MAX
invalid\ balancer\ weight\ for\ nic\:%s,\ %d\ is\ not\ in\ the\ range\ [%d,\ %d] = invalid balancer weight for nic:{0}, {1} is not in the range [{2}, {3}]

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:206
# args: msg.getVmNicUuid(),msg.getVipUuid()
guest\ l3Network\ of\ vm\ nic[uuid\:%s]\ and\ vip\ l3Network\ of\ vip[uuid\:\ %s]\ are\ the\ same\ network = guest l3Network of vm nic[uuid:{0}] and vip l3Network of vip[uuid: {1}] are the same network

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:181
# args: msg.getVipUuid(),useForList.toString()
the\ vip[uuid\:%s]\ has\ been\ occupied\ other\ network\ service\ entity[%s] = the vip[uuid:{0}] has been occupied other network service entity[{1}]

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:66
# args: msg.getRuleUuid(),state
Port\ forwarding\ rule[uuid\:%s]\ is\ not\ in\ state\ of\ Enabled,\ current\ state\ is\ %s = Port forwarding rule[uuid:{0}] is not in state of Enabled, current state is {1}

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:81
# args: msg.getUuid()
port\ forwarding\ rule\ rule[uuid\:%s]\ has\ not\ been\ attached\ to\ any\ vm\ nic,\ can't\ detach = port forwarding rule rule[uuid:{0}] has not been attached to any vm nic, can't detach

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:95
# args: msg.getRuleUuid(),vmNicUuid
port\ forwarding\ rule[uuid\:%s]\ has\ been\ attached\ to\ vm\ nic[uuid\:%s],\ can't\ attach\ again = port forwarding rule[uuid:{0}] has been attached to vm nic[uuid:{1}], can't attach again

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:100
# args: msg.getRuleUuid(),state
port\ forwarding\ rule[uuid\:%s]\ is\ not\ in\ state\ of\ Enabled,\ \ current\ state\ is\ %s.\ A\ rule\ can\ only\ be\ attached\ when\ its\ state\ is\ Enabled = port forwarding rule[uuid:{0}] is not in state of Enabled,  current state is {1}. A rule can only be attached when its state is Enabled

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:119
# args: msg.getVmNicUuid(),msg.getRuleUuid()
guest\ l3Network\ of\ vm\ nic[uuid\:%s]\ and\ vip\ l3Network\ of\ port\ forwarding\ rule[uuid\:%s]\ are\ the\ same\ network = guest l3Network of vm nic[uuid:{0}] and vip l3Network of port forwarding rule[uuid:{1}] are the same network

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:166
# args: msg.getVipPortStart(),msg.getVipPortEnd(),msg.getPrivatePortStart(),msg.getPrivatePortEnd()
for\ range\ port\ forwarding,\ the\ port\ range\ size\ must\ match;\ vip\ range[%s,\ %s]'s\ size\ doesn't\ match\ range[%s,\ %s]'s\ size = for range port forwarding, the port range size must match; vip range[{0}, {1}]'s size doesn't match range[{2}, {3}]'s size

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:191
# args: msg.getAllowedCidr()
invalid\ CIDR[%s] = invalid CIDR[{0}]

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:193
# args: msg.getAllowedCidr()
invalid\ CIDR[%s],\ only\ ipv4\ is\ supported = invalid CIDR[{0}], only ipv4 is supported

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:191
# args: vipStart,vipEnd,vo.getUuid(),vo.getVipPortStart(),vo.getVipPortEnd()
vip\ port\ range[vipStartPort\:%s,\ vipEndPort\:%s]\ overlaps\ with\ rule[uuid\:%s,\ vipStartPort\:%s,\ vipEndPort\:%s] = vip port range[vipStartPort:{0}, vipEndPort:{1}] overlaps with rule[uuid:{2}, vipStartPort:{3}, vipEndPort:{4}]

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:243
# args: vm.getName(),vm.getUuid(),vipUuid
the\ VM[name\:%s\ uuid\:%s]\ already\ has\ port\ forwarding\ rules\ that\ have\ different\ VIPs\ than\ the\ one[uuid\:%s] = the VM[name:{0} uuid:{1}] already has port forwarding rules that have different VIPs than the one[uuid:{2}]

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:304
# args: vmNicUuid,privatePortStart,privatePortEnd,protocolType
could\ not\ attach\ port\ forwarding\ rule\ with\ allowedCidr,\ because\ vmNic[uuid\:%s]\ already\ has\ rules\ that\ overlap\ the\ target\ private\ port\ ranges[%s,\ %s]\ and\ have\ the\ same\ protocol\ type[%s] = could not attach port forwarding rule with allowedCidr, because vmNic[uuid:{0}] already has rules that overlap the target private port range[{1}, {2}] and have the same protocol type[{3}]

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:314
# args: vmNicUuid,privatePortStart,privatePortEnd,protocolType
could\ not\ attach\ port\ forwarding\ rule,\ because\ vmNic[uuid\:%s]\ already\ has\ a\ rule\ that\ overlaps\ the\ target\ private\ port\ ranges[%s,\ %s],\ has\ the\ same\ protocol\ type[%s]\ and\ has\ AllowedCidr = could not attach port forwarding rule, because vmNic[uuid:{0}] already has a rule that overlaps the target private port range[{1}, {2}], has the same protocol type[{3}] and has AllowedCidr

# at: src/main/java/org/zstack/network/service/vip/VipApiInterceptor.java:49
# args: msg.getAllocatorStrategy()
unsupported\ ip\ allocation\ strategy[%s] = unsupported ip allocation strategy[{0}]

# at: src/main/java/org/zstack/network/service/vip/VipApiInterceptor.java:61
# args: msg.getRequiredIp()
requiredIp[%s]\ is\ not\ in\ valid\ IPv6\ mediaType = requiredIp[{0}] is not in valid IPv6 mediaType

# at: src/main/java/org/zstack/network/service/vip/VipApiInterceptor.java:56
# args: msg.getRequiredIp()
requiredIp[%s]\ is\ not\ in\ valid\ IPv4\ mediaType = requiredIp[{0}] is not in valid IPv4 mediaType

# at: src/main/java/org/zstack/network/service/vip/VipApiInterceptor.java:70
# args: msg.getRequiredIp(),msg.getL3NetworkUuid()
there\ is\ already\ a\ vip[%s]\ on\ l3Network[uuid\:%s] = there is already a vip[{0}] on l3Network[uuid:{1}]

# at: src/main/java/org/zstack/network/service/vip/VipBase.java:152
# args: self.getUuid(),self.getName(),self.getIp(),self.getServiceProvider()
service\ provider\ of\ the\ vip[uuid\:%s,\ name\:%s,\ ip\:\ %s]\ has\ been\ set\ to\ %s = service provider of the vip[uuid:{0}, name:{1}, ip: {2}] has been set to {3}

# at: src/main/java/org/zstack/network/service/vip/VipBase.java:712
# args: self.getUuid(),self.getIp()
Vip\ [uuid\ %s,\ ip\ %s]\ of\ router\ public\ interface\ can\ not\ be\ deleted = Vip [uuid {0}, ip {1}] of router public interface can not be deleted

# at: src/main/java/org/zstack/network/service/vipQos/VipQosApiInterceptor.java:43
# args: 
VipQos\ for\ ipv6\ wil\ be\ added\ soon = VipQos for ipv6 wil be added soon

# at: src/main/java/org/zstack/network/service/vipQos/VipQosApiInterceptor.java:53
# args: msg.getVipUuid()
VipQos\ for\ Vip\ [uuid\:\ %s]\ already\ existed = VipQos for Vip [uuid: {0}] already existed

# at: src/main/java/org/zstack/network/service/vipQos/VipQosApiInterceptor.java:48
# args: msg.getVipUuid(),Integer.toString(msg.getPort())
VipQos\ for\ Vip\ [uuid\:\ %s]\ port\ %s\ already\ existed = VipQos for Vip [uuid: {0}] port {1} already existed

# at: src/main/java/org/zstack/network/service/vipQos/VipQosApiInterceptor.java:59
# args: 
SetVipQos\ MUST\ set\ InboundBandwidth\ or\ OutboundBandwidth = SetVipQos MUST set InboundBandwidth or OutboundBandwidth

# at: src/main/java/org/zstack/network/service/vipQos/VipQosApiInterceptor.java:67
# args: 
Cannot\ set\ Qos\ for\ this\ Vip.\ Not\ all\ peer\ l3networks\ provide\ VipQos\ service. = Cannot set Qos for this Vip. Not all peer l3networks provide VipQos service.

# at: src/main/java/org/zstack/network/service/vipQos/VipQosApiInterceptor.java:80
# args: msg.getUuid()
VipQos\ for\ Vip\ [uuid\:\ %s]\ does\ not\ exist = VipQos for Vip [uuid: {0}] does not exist

# at: src/main/java/org/zstack/network/service/vipQos/VipQosApiInterceptor.java:75
# args: msg.getUuid(),Integer.toString(msg.getPort())
VipQos\ for\ Vip\ [uuid\:\ %s]\ port\ %s\ does\ not\ exist = VipQos for Vip [uuid: {0}] port {1} does not exist

# at: src/main/java/org/zstack/network/service/vipQos/VipQosManagerImpl.java:129
# args: vipUuid
Can\ not\ find\ VipQos\ backend\ for\ Vip\ [uuid\:%s] = Can not find VipQos backend for Vip [uuid:{0}]

# at: src/main/java/org/zstack/network/service/vipQos/flat/FlatVipQosBackend.java:197
# args: hostUuid
operation\ error,\ vip\ %s\ has\ not\ bind\ to\ vm = operation error, vip {0} has not bind to vm

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouter.java:277
# args: self.getName(),self.getUuid(),self.getState()
the\ virtual\ router[name\:%s,\ uuid\:%s,\ current\ state\:%s]\ is\ not\ running,and\ cannot\ perform\ required\ operation.\ Please\ retry\ your\ operation\ later\ once\ it\ is\ running = the virtual router[name:{0}, uuid:{1}, current state:{2}] is not running,and cannot perform required operation. Please retry your operation later once it is running

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouter.java:282
# args: self.getUuid(),getSelf().getStatus(),msg.getPath()
virtual\ router[uuid\:%s]\ is\ in\ status\ of\ %s\ that\ cannot\ make\ http\ call\ to\ %s = virtual router[uuid:{0}] is in status of {1} that cannot make http call to {2}

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouter.java:287
# args: self.getUuid(),msg.getPath()
virtual\ router[uuid\:%s]\ has\ no\ management\ nic\ that\ cannot\ make\ http\ call\ to\ %s = virtual router[uuid:{0}] has no management nic that cannot make http call to {1}

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouter.java:397
# args: getSelf().getUuid()
appliance\ vm\ %s\ reconnect\ failed = appliance vm {0} reconnect failed

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouter.java:473
# args: info.getIp(),info.getMac(),vr.getUuid(),vr.getManagementNic().getIp(),rsp.getError()
unable\ to\ add\ nic[ip\:%s,\ mac\:%s]\ to\ virtual\ router\ vm[uuid\:%s\ ip\:%s],\ because\ %s = unable to add nic[ip:{0}, mac:{1}] to virtual router vm[uuid:{2} ip:{3}], because {4}

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouter.java:750
# args: info,vr.getUuid(),vr.getManagementNic().getIp(),rsp.getError()
unable\ to\ detach\ nic[%s]\ from\ virtual\ router\ vm[uuid\:%s\ ip\:%s],\ because\ %s = unable to detach nic[{0}] from virtual router vm[uuid:{1} ip:{2}], because {3}

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:106
# args: msg.getDefaultRouteL3NetworkUuid()
could\ not\ set\ the\ default\ network,\ because\ l3\ uuid[\:%s]\ is\ management\ network = could not set the default network, because l3 uuid[:{0}] is management network

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:108
# args: msg.getDefaultRouteL3NetworkUuid()
could\ not\ set\ the\ default\ network,\ because\ l3\ uuid[\:%s]\ is\ not\ public\ network = could not set the default network, because l3 uuid[:{0}] is not public network

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:149
# args: msg.getImageUuid(),type,ImageMediaType.RootVolumeTemplate
image[uuid\:%s]'s\ mediaType\ is\ %s,\ the\ mediaType\ of\ a\ virtual\ router\ image\ must\ be\ %s = image[uuid:{0}]'s mediaType is {1}, the mediaType of a virtual router image must be {2}

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:155
# args: msg.getImageUuid(),format
image[uuid\:%s]\ is\ of\ format\ %s,\ cannot\ be\ used\ for\ virtual\ router = image[uuid:{0}] is of format {1}, cannot be used for virtual router

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:125
# args: msg.getManagementNetworkUuid(),msg.getZoneUuid()
management\ network[uuid\:%s]\ is\ not\ in\ the\ same\ zone[uuid\:%s]\ this\ offering\ is\ going\ to\ create = management network[uuid:{0}] is not in the same zone[uuid:{1}] this offering is going to create

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:138
# args: msg.getManagementNetworkUuid(),msg.getZoneUuid()
public\ network[uuid\:%s]\ is\ not\ in\ the\ same\ zone[uuid\:%s]\ this\ offering\ is\ going\ to\ create = public network[uuid:{0}] is not in the same zone[uuid:{1}] this offering is going to create

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:166
# args: msg.getPublicNetworkUuid()
the\ L3\ network[uuid\:\ %s]\ has\ the\ SNAT\ service\ enabled,\ it\ cannot\ be\ used\ as\ a\ public\ network = the L3 network[uuid: {0}] has the SNAT service enabled, it cannot be used as a public network

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:164
# args: msg.getManagementNetworkUuid()
the\ L3\ network[uuid\:\ %s]\ has\ the\ SNAT\ service\ enabled,\ it\ cannot\ be\ used\ as\ a\ management\ network = the L3 network[uuid: {0}] has the SNAT service enabled, it cannot be used as a management network

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:173
# args: msg.getManagementNetworkUuid(),msg.getPublicNetworkUuid()
the\ L3\ network[uuid\:\ %s]\ is\ same\ network\ address\ with\ [uuid\:\ %s],\ it\ cannot\ be\ used\ for\ virtual\ router = the L3 network[uuid: {0}] is same network address with [uuid: {1}], it cannot be used for virtual router

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:183
# args: managementNetworkUuid
the\ management\ network[uuid\:%s]\ doesn't\ have\ any\ IP\ range = the management network[uuid:{0}] doesn't have any IP range

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:200
# args: managementNetworkUuid,gateway
the\ management\ network[uuid\:%s,\ gateway\:%s]\ is\ not\ reachable = the management network[uuid:{0}, gateway:{1}] is not reachable

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterKvmBackend.java:107
# args: iso.getIsoPath(),vrSpec.getDestHost().getUuid(),vrSpec.getDestHost().getManagementIp(),iso.getVirtualRouterUuid(),rsp.getError()
failed\ to\ create\ VirtualRouterBootstrapIso[%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s]\ for\ virtual\ router[uuid\:%s],\ because\ %s = failed to create VirtualRouterBootstrapIso[{0}] on kvm host[uuid:{1}, ip:{2}] for virtual router[uuid:{3}], because {4}

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterKvmBackend.java:140
# args: iso.getIsoPath(),hostUuid,iso.getVirtualRouterUuid(),rsp.getError()
failed\ to\ delete\ VirtualRouterBootstrapIso[%s]\ on\ kvm\ host[uuid\:%s]\ for\ virtual\ router[uuid\:%s],\ because\ %s = failed to delete VirtualRouterBootstrapIso[{0}] on kvm host[uuid:{1}] for virtual router[uuid:{2}], because {3}

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterManagerImpl.java:280
# args: 
cannot\ create\ virtual\ Router\ vm\ while\ virtual\ router\ network\ overlaps\ with\ private\ network\ in\ ip\  = cannot create virtual Router vm while virtual router network overlaps with private network in ip 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterManagerImpl.java:585
# args: offeringUuid
No\ virtual\ router\ instance\ offering\ with\ uuid\:%s\ is\ found = No virtual router instance offering with uuid:{0} is found

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterManagerImpl.java:1182
# args: msg.getL3NetworkUuid()
failed\ tot\ attach\ virtual\ router\ network\ services\ to\ l3Network[uuid\:%s].\ When\ eip\ is\ selected,\ snat\ must\ be\ selected\ too = failed tot attach virtual router network services to l3Network[uuid:{0}]. When eip is selected, snat must be selected too

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterManagerImpl.java:1186
# args: msg.getL3NetworkUuid()
failed\ tot\ attach\ virtual\ router\ network\ services\ to\ l3Network[uuid\:%s].\ When\ port\ forwarding\ is\ selected,\ snat\ must\ be\ selected\ too = failed tot attach virtual router network services to l3Network[uuid:{0}]. When port forwarding is selected, snat must be selected too

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterManagerImpl.java:1698
# args: toDeleteNics.stream().map( n -> n.getUuid()).collect(Collectors.toList())
can\ not\ detach\ nic\ [uuid\:%s] = can not detach nic [uuid:{0}]

# at: src/main/java/org/zstack/network/service/virtualrouter/dhcp/VirtualRouterDhcpBackend.java:126
# args: vr.getUuid(),vr.getManagementNic().getIp(),rsp.getError(),struct
unable\ to\ add\ dhcp\ entries\ to\ virtual\ router\ vm[uuid\:%s\ ip\:%s],\ because\ %s,\ dhcp\ entry[%s] = unable to add dhcp entries to virtual router vm[uuid:{0} ip:{1}], because {2}, dhcp entry[{3}]

# at: src/main/java/org/zstack/network/service/virtualrouter/dhcp/VirtualRouterSyncDHCPOnStartFlow.java:208
# args: vr.getUuid(),vr.getManagementNic().getIp(),ret.getError()
unable\ to\ program\ dhcp\ entries\ served\ by\ virtual\ router[uuid\:%s,\ ip\:%s],\ %s = unable to program dhcp entries served by virtual router[uuid:{0}, ip:{1}], {2}

# at: src/main/java/org/zstack/network/service/virtualrouter/dns/VirtualRouterDnsBackend.java:210
# args: vr.getUuid(),vr.getManagementNic().getIp(),struct,l3.getUuid(),l3.getName(),ret.getError()
virtual\ router[uuid\:%s,\ ip\:%s]\ failed\ to\ configure\ dns%s\ for\ L3Network[uuid\:%s,\ name\:%s],\ %s = virtual router[uuid:{0}, ip:{1}] failed to configure dns{2} for L3Network[uuid:{3}, name:{4}], {5}

# at: src/main/java/org/zstack/network/service/virtualrouter/dns/VirtualRouterSyncDnsOnStartFlow.java:124
# args: vr.getName(),vr.getUuid(),JSONObjectUtil.toJsonString(dns),ret.getError()
virtual\ router[name\:\ %s,\ uuid\:\ %s]\ failed\ to\ configure\ dns%s,\ %s\  = virtual router[name: {0}, uuid: {1}] failed to configure dns{2}, {3} 

# at: src/main/java/org/zstack/network/service/virtualrouter/eip/VirtualRouterEipBackend.java:496
# args: vr.getUuid(),ret.getError()
failed\ to\ sync\ eip\ on\ virtual\ router[uuid\:%s],\ %s = failed to sync eip on virtual router[uuid:{0}], {1}

# at: src/main/java/org/zstack/network/service/virtualrouter/eip/VirtualRouterEipBackend.java:165
# args: struct.getEip().getUuid(),struct.getEip().getName(),struct.getVip().getIp(),struct.getNic().getUuid(),vr.getUuid(),ret.getError()
failed\ to\ create\ eip[uuid\:%s,\ name\:%s,\ ip\:%s]\ for\ vm\ nic[uuid\:%s]\ on\ virtual\ router[uuid\:%s],\ %s = failed to create eip[uuid:{0}, name:{1}, ip:{2}] for vm nic[uuid:{3}] on virtual router[uuid:{4}], {5}

# at: src/main/java/org/zstack/network/service/virtualrouter/eip/VirtualRouterEipBackend.java:246
# args: offering.getUuid(),l3inv.getUuid(),l3inv.getZoneUuid(),struct.getVip().getL3NetworkUuid(),struct.getEip().getUuid()
found\ a\ virtual\ router\ offering[uuid\:%s]\ for\ L3Network[uuid\:%s]\ in\ zone[uuid\:%s];\ however,\ the\ network's\ public\ network[uuid\:%s]\ is\ not\ the\ same\ to\ EIP[uuid\:%s]'s;\ you\ may\ need\ to\ use\ system\ tag\ guestL3Network\:\:l3NetworkUuid\ to\ specify\ a\ particular\ virtual\ router\ offering\ for\ the\ L3Network = found a virtual router offering[uuid:{0}] for L3Network[uuid:{1}] in zone[uuid:{2}]; however, the network's public network[uuid:{3}] is not the same to EIP[uuid:{4}]'s; you may need to use system tag guestL3Network::l3NetworkUuid to specify a particular virtual router offering for the L3Network

# at: src/main/java/org/zstack/network/service/virtualrouter/eip/VirtualRouterEipBackend.java:336
# args: struct.getEip().getUuid(),struct.getEip().getName(),struct.getVip().getIp(),struct.getNic().getUuid(),vr.getUuid(),ret.getError()
failed\ to\ remove\ eip[uuid\:%s,\ name\:%s,\ ip\:%s]\ for\ vm\ nic[uuid\:%s]\ on\ virtual\ router[uuid\:%s],\ %s = failed to remove eip[uuid:{0}, name:{1}, ip:{2}] for vm nic[uuid:{3}] on virtual router[uuid:{4}], {5}

# at: src/main/java/org/zstack/network/service/virtualrouter/lb/VirtualRouterLoadBalancerBackend.java:152
# args: msg.getVmNicUuids(),vrUuids
new\ add\ vm\ nics[uuids\:%s]\ and\ attached\ vmnics\ are\ not\ on\ the\ same\ vrouter,\ they\ are\ on\ vrouters[uuids\:%s] = new add vm nics[uuids:{0}] and attached vmnics are not on the same vrouter, they are on vrouters[uuids:{1}]

# at: src/main/java/org/zstack/network/service/virtualrouter/lb/VirtualRouterLoadBalancerBackend.java:182
# args: msg.getVmNicUuids(),peerL3NetworkUuids,msg.getLoadBalancerUuid(),vrUuids
new\ add\ vm\ nics[uuids\:%s]\ and\ peer\ l3s[uuids\:%s]\ of\ loadbalancer[uuid\:\ %s]'s\ vip\ are\ not\ on\ the\ same\ vrouter,\ they\ are\ on\ vrouters[uuids\:%s] = new add vm nics[uuids:{0}] and peer l3s[uuids:{1}] of loadbalancer[uuid: {2}]'s vip are not on the same vrouter, they are on vrouters[uuids:{3}]

# at: src/main/java/org/zstack/network/service/virtualrouter/lb/VirtualRouterLoadBalancerBackend.java:1318
# args: struct.getLb().getUuid()
cannot\ find\ virtual\ router\ for\ load\ balancer\ [uuid\:%s] = cannot find virtual router for load balancer [uuid:{0}]

# at: src/main/java/org/zstack/network/service/virtualrouter/nat/VirtualRouterSnatBackend.java:331
# args: vr.getName(),vr.getUuid(),JSONObjectUtil.toJsonString(snatInfo),ret.getError()
virtual\ router[name\:\ %s,\ uuid\:\ %s]\ failed\ to\ sync\ snat%s,\ %s = virtual router[name: {0}, uuid: {1}] failed to sync snat{2}, {3}

# at: src/main/java/org/zstack/network/service/virtualrouter/nat/VirtualRouterSnatBackend.java:92
# args: guestL3.getUuid(),guestL3.getName(),offering.getPublicNetworkUuid(),offering.getUuid(),offering.getName()
guest\ l3Network[uuid\:%s,\ name\:%s]\ needs\ SNAT\ service\ provided\ by\ virtual\ router,\ but\ public\ l3Network[uuid\:%s]\ of\ virtual\ router\ offering[uuid\:\ %s,\ name\:%s]\ is\ the\ same\ to\ this\ guest\ l3Network = guest l3Network[uuid:{0}, name:{1}] needs SNAT service provided by virtual router, but public l3Network[uuid:{2}] of virtual router offering[uuid: {3}, name:{4}] is the same to this guest l3Network

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/ApplyPortforwardingRuleOnVirtualRouterVmFlow.java:80
# args: to.getVipIp(),to.getPrivateIp(),to.getVipPortStart(),to.getVipPortEnd(),to.getPrivatePortStart(),to.getPrivatePortEnd(),ret.getError()
failed\ to\ create\ port\ forwarding\ rule[vip\ ip\:\ %s,\ private\ ip\:\ %s,\ vip\ start\ port\:\ %s,\ vip\ end\ port\:\ %s,\ private\ start\ port\:\ %s,\ private\ end\ port\:\ %s],\ because\ %s = failed to create port forwarding rule[vip ip: {0}, private ip: {1}, vip start port: {2}, vip end port: {3}, private start port: {4}, private end port: {5}], because {6}

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/ReleasePortForwardingRuleOnVirtualRouterVmFlow.java:74
# args: JSONObjectUtil.toJsonString(to),ret.getError()
failed\ to\ revoke\ port\ forwarding\ rules\ %s,\ because\ %s = failed to revoke port forwarding rules {0}, because {1}

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/VirtualRouterPortForwardingBackend.java:184
# args: offering.getUuid(),struct.getGuestL3Network().getUuid(),struct.getGuestL3Network().getZoneUuid(),struct.getVip().getL3NetworkUuid(),struct.getRule().getUuid()
found\ a\ virtual\ router\ offering[uuid\:%s]\ for\ L3Network[uuid\:%s]\ in\ zone[uuid\:%s];\ however,\ the\ network's\ public\ network[uuid\:%s]\ is\ not\ the\ same\ to\ PortForwarding\ rule[uuid\:%s]'s;\ you\ may\ need\ to\ use\ system\ tag\ guestL3Network\:\:l3NetworkUuid\ to\ specify\ a\ particular\ virtual\ router\ offering\ for\ the\ L3Network = found a virtual router offering[uuid:{0}] for L3Network[uuid:{1}] in zone[uuid:{2}]; however, the network's public network[uuid:{3}] is not the same to PortForwarding rule[uuid:{4}]'s; you may need to use system tag guestL3Network::l3NetworkUuid to specify a particular virtual router offering for the L3Network

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/VirtualRouterPortForwardingBackend.java:249
# args: rule.getVipPortStart(),rule.getVipPortEnd(),rule.getPrivatePortStart(),rule.getPrivatePortEnd()
virtual\ router\ doesn't\ support\ port\ forwarding\ range\ redirection,\ the\ vipPortStart\ must\ be\ equals\ to\ privatePortStart\ and\ vipPortEnd\ must\ be\ equals\ to\ privatePortEnd;but\ this\ rule\ rule\ has\ a\ mismatching\ range\:\ vip\ port[%s,\ %s],\ private\ port[%s,\ %s] = virtual router doesn't support port forwarding range redirection, the vipPortStart must be equals to privatePortStart and vipPortEnd must be equals to privatePortEnd;but this rule rule has a mismatching range: vip port[{0}, {1}], private port[{2}, {3}]

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/VirtualRouterPortForwardingBackend.java:402
# args: vrVO.getUuid(),ret.getError()
failed\ to\ add\ portforwardings\ on\ virtual\ router[uuid\:%s],\ %s = failed to add portforwardings on virtual router[uuid:{0}], {1}

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/VirtualRouterPortForwardingBackend.java:471
# args: vrVO.getUuid(),ret.getError()
failed\ to\ revoke\ port\ forwardings\ on\ virtual\ router[uuid\:%s],\ %s = failed to revoke port forwardings on virtual router[uuid:{0}], {1}

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/VirtualRouterSyncPortForwardingRulesOnStartFlow.java:197
# args: vr.getName(),vr.getUuid(),ret.getError()
failed\ to\ sync\ port\ forwarding\ rules\ served\ by\ virtual\ router[name\:\ %s,\ uuid\:\ %s],\ because\ %s = failed to sync port forwarding rules served by virtual router[name: {0}, uuid: {1}], because {2}

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterCreateVipForPublicIpFlow.java:66
# args: vr.getName(),vr.getUuid(),nic.getIp(),nic.getL3NetworkUuid()
virtual\ router[name\:\ %s,\ uuid\:\ %s]\ failed\ to\ create\ vip\ for\ public\ ip\ %s\ because\ no\ ip\ range\ for\ l3NetworkUuid\ %s = virtual router[name: {0}, uuid: {1}] failed to create vip for public ip {2} because no ip range for l3NetworkUuid {3}

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBackend.java:136
# args: tos,ret.getError()
failed\ to\ remove\ vip%s,\ because\ %s = failed to remove vip{0}, because {1}

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBackend.java:92
# args: tos,vr.getUuid(),ret.getError()
failed\ to\ create\ vip%s\ on\ virtual\ router[uuid\:%s],\ because\ %s = failed to create vip{0} on virtual router[uuid:{1}], because {2}

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBackend.java:201
# args: vips.stream().map( v -> v.getIp()).collect(Collectors.toList()),nic.getVmInstanceUuid(),nic.getUuid(),nic.getIp(),ret.getError()
failed\ to\ sync\ vips[ips\:\ %s]\ on\ virtual\ router[uuid\:%s]\ for\ attaching\ nic[uuid\:\ %s,\ ip\:\ %s],\ because\ %s = failed to sync vips[ips: {0}] on virtual router[uuid:{1}] for attaching nic[uuid: {2}, ip: {3}], because {4}

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBaseBackend.java:262
# args: vrUuid,vrState
virtual\ router[uuid\:%s,\ state\:%s]\ is\ not\ running = virtual router[uuid:{0}, state:{1}] is not running

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBaseBackend.java:303
# args: offering.getUuid(),s.getL3Network().getUuid(),s.getL3Network().getZoneUuid(),self.getL3NetworkUuid(),self.getUuid()
found\ a\ virtual\ router\ offering[uuid\:%s]\ for\ L3Network[uuid\:%s]\ in\ zone[uuid\:%s];\ however,\ the\ network's\ public\ network[uuid\:%s]\ is\ not\ the\ same\ to\ VIP[uuid\:%s]'s;\ you\ may\ need\ to\ use\ system\ tag\ guestL3Network\:\:l3NetworkUuid\ to\ specify\ a\ particular\ virtual\ router\ offering\ for\ the\ L3Network = found a virtual router offering[uuid:{0}] for L3Network[uuid:{1}] in zone[uuid:{2}]; however, the network's public network[uuid:{3}] is not the same to VIP[uuid:{4}]'s; you may need to use system tag guestL3Network::l3NetworkUuid to specify a particular virtual router offering for the L3Network

# at: src/main/java/org/zstack/network/service/virtualrouter/vyos/VyosChangePrivateL3FirewallDefaultActionExtensionPoint.java:67
# args: nic.getIp(),nic.getMac(),nic.getVmInstanceUuid(),rsp.getError()
failed\ to\ change\ nic[ip\:%s,\ mac\:%s]\ firewall\ default\ action\ of\ virtual\ router\ vm[uuid\:%s],\ because\ %s = failed to change nic[ip:{0}, mac:{1}] firewall default action of virtual router vm[uuid:{2}], because {3}

# at: src/main/java/org/zstack/network/service/virtualrouter/vyos/VyosVersionVersionManagerImpl.java:56
# args: vrUuid,ret.getError()
virtual\ router[uuid\:\ %s]\ failed\ to\ get\ version\ because\ %s\  = virtual router[uuid: {0}] failed to get version because {1} 

# at: src/main/java/org/zstack/network/service/virtualrouter/vyos/VyosVersionVersionManagerImpl.java:63
# args: vrUuid
virtual\ router[uuid\:\ %s]\ doesn't\ have\ version = virtual router[uuid: {0}] doesn't have version

# at: src/main/java/org/zstack/network/service/virtualrouter/vyos/VyosVersionVersionManagerImpl.java:69
# args: vrUuid,ret.getVersion()
virtual\ router[uuid\:\ %s]\ version\ [%s]\ format\ error = virtual router[uuid: {0}] version [{1}] format error

# at: src/main/java/org/zstack/network/service/virtualrouter/vyos/VyosVersionVersionManagerImpl.java:75
# args: vrUuid,ret.getVersion(),managementVersion
virtual\ router[uuid\:\ %s]\ version\ [%s]\ is\ older\ than\ management\ node\ version\ [%s] = virtual router[uuid: {0}] version [{1}] is older than management node version [{2}]

# at: src/main/java/org/zstack/pciDevice/HostDeviceAllocatorFlow.java:79
# args: vmUuid,specMap.keySet()
failed\ to\ start\ vm[uuid\:%s]\ because\ not\ all\ pci\ specs[uuids\:%s]\ exist = failed to start vm[uuid:{0}] because not all pci specs[uuids:{1}] exist

# at: src/main/java/org/zstack/pciDevice/HostDeviceAllocatorFlow.java:132
# args: vmUuid
no\ candidate\ host\ with\ enough\ spec\ related\ pci\ devices\ for\ vm[uuid\:%s] = no candidate host with enough spec related pci devices for vm[uuid:{0}]

# at: src/main/java/org/zstack/pciDevice/HostDeviceAllocatorFlow.java:154
# args: vmUuid,specMap.keySet()
failed\ to\ start\ vm[uuid\:%s]\ because\ not\ all\ mdev\ specs[uuids\:%s]\ exist = failed to start vm[uuid:{0}] because not all mdev specs[uuids:{1}] exist

# at: src/main/java/org/zstack/pciDevice/HostDeviceAllocatorFlow.java:205
# args: vmUuid
no\ candidate\ host\ with\ enough\ spec\ related\ mdev\ devices\ for\ vm[uuid\:%s] = no candidate host with enough spec related mdev devices for vm[uuid:{0}]

# at: src/main/java/org/zstack/pciDevice/HostDeviceAllocatorFlow.java:260
# args: specUuid,hostUuid,vmUuid
failed\ to\ find\ enough\ pci\ device\ of\ spec[uuid\:%s]\ in\ dest\ host[uuid\:%s]\ for\ vm[uuid\:%s] = failed to find enough pci device of spec[uuid:{0}] in dest host[uuid:{1}] for vm[uuid:{2}]

# at: src/main/java/org/zstack/pciDevice/HostDeviceAllocatorFlow.java:337
# args: specUuid,hostUuid,vmUuid
failed\ to\ find\ enough\ mdev\ device\ of\ spec[uuid\:%s]\ in\ dest\ host[uuid\:%s]\ for\ vm[uuid\:%s] = failed to find enough mdev device of spec[uuid:{0}] in dest host[uuid:{1}] for vm[uuid:{2}]

# at: src/main/java/org/zstack/pciDevice/HostDeviceAllocatorFlow.java:411
# args: vmUuid,errorCode
failed\ to\ sort\ host\ candidates\ for\ vm\ [uuid\:%s]\ in\ HostDeviceAllocatorFlow\:\ %s = failed to sort host candidates for vm [uuid:{0}] in HostDeviceAllocatorFlow: {1}

# at: src/main/java/org/zstack/pciDevice/PciDeviceAllocatorFactory.java:87
# args: vo.getUuid(),vo.getHostUuid(),attachedPciUuid,dstHostUuid
specified\ pci\ devices\ not\ on\ same\ host\:\ pci\ device[uuid\:\ %s]\ on\ host[uuid\:\ %s]\ while\ pci\ device[uuid\:\ %s]\ on\ host[uuid\:\ %s] = specified pci devices not on same host: pci device[uuid: {0}] on host[uuid: {1}] while pci device[uuid: {2}] on host[uuid: {3}]

# at: src/main/java/org/zstack/pciDevice/PciDeviceAllocatorFactory.java:140
# args: 
cannot\ find\ required\ pci\ device\ on\ hosts = cannot find required pci device on hosts

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:416
# args: msg.getPciDeviceUuid()
pci\ device[uuid\:%s]\ doesn't\ exist = pci device[uuid:{0}] doesn't exist

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:426
# args: pci.getHostUuid()
pci\ devices\ in\ host[uuid\:%s]\ already\ sriov\ virtualized = pci devices in host[uuid:{0}] already sriov virtualized

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:437
# args: pci.getHostUuid()
cannot\ sr-iov\ virtualize\ pci\ devices\ in\ host[uuid\:%s]\ that\ are\ attached\ to\ vm = cannot sr-iov virtualize pci devices in host[uuid:{0}] that are attached to vm

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:457
# args: minIns,pci.getType(),pci.getHostUuid()
only\ %d\ virtual\ pci\ devices\ can\ be\ generated\ by\ %ss\ in\ host[uuid\:%s] = only {0} virtual pci devices can be generated by {1}s in host[uuid:{2}]

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:569
# args: pci.getHostUuid(),pci.getUuid()
the\ host[uuid\:%s]\ that\ pci\ device[uuid\:%s]\ in\ is\ not\ Connected = the host[uuid:{0}] that pci device[uuid:{1}] in is not Connected

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:477
# args: msg.getPciDeviceUuid()
pci\ device[uuid\:%s]\ doesn't\ exist\ or\ is\ not\ sriov\ virtualized = pci device[uuid:{0}] doesn't exist or is not sriov virtualized

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:488
# args: pci.getHostUuid()
virtual\ pci\ devices\ generated\ from\ pci\ devices\ in\ host[uuid\:%s]\ still\ attached\ to\ vm = virtual pci devices generated from pci devices in host[uuid:{0}] still attached to vm

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:510
# args: msg.getPciDeviceUuid()
pci\ device[uuid\:%s]\ cannot\ be\ virtualized\ into\ mdevs,\ make\ sure\ it's\ enabled\ and\ un-attached = pci device[uuid:{0}] cannot be virtualized into mdevs, make sure it's enabled and un-attached

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:521
# args: msg.getPciDeviceUuid(),msg.getMdevSpecUuid()
pci\ device[uuid\:%s]\ cannot\ be\ virtualized\ by\ mdev\ spec[uuid\:%s] = pci device[uuid:{0}] cannot be virtualized by mdev spec[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:543
# args: msg.getPciDeviceUuid()
pci\ device[uuid\:%s]\ is\ not\ virtualized\ into\ mdevs = pci device[uuid:{0}] is not virtualized into mdevs

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:560
# args: msg.getPciDeviceUuid()
mdev\ devices\ generated\ from\ pci\ device[uuid\:%s]\ still\ attached\ to\ vm = mdev devices generated from pci device[uuid:{0}] still attached to vm

# at: src/main/java/org/zstack/pciDevice/PciDeviceManager.java:989
# args: spec.getType(),PciDeviceType.leagalPciDeviceCandidateTypes
illegal\ type[%s]\ for\ pci\ device\ spec,\ only\ %s\ are\ legal = illegal type[{0}] for pci device spec, only {1} are legal

# at: src/main/java/org/zstack/pciDevice/PciDeviceManager.java:978
# args: vo.getType(),PciDeviceType.leagalPciDeviceCandidateTypes
illegal\ type[%s]\ for\ pci\ device,\ only\ %s\ are\ legal = illegal type[{0}] for pci device, only {1} are legal

# at: src/main/java/org/zstack/pciDevice/PciDeviceManager.java:637
# args: msg.getPciDeviceUuid(),msg.getVmInstanceUuid()
can\ not\ attach\ this\ pci\ device[uuid\:%s]\ to\ vm[uuid\:%s]\ due\ to\ host\ allocation = can not attach this pci device[uuid:{0}] to vm[uuid:{1}] due to host allocation

# at: src/main/java/org/zstack/pciDevice/PciDeviceManager.java:910
# args: msg.getVmInstanceUuid()
can\ not\ migrate\ vm[uuid\:%s]\ since\ pci\ device\ attached = can not migrate vm[uuid:{0}] since pci device attached

# at: src/main/java/org/zstack/pciDevice/PciDeviceManager.java:941
# args: msg.getVolumeUuid()
cannot\ migrate\ root\ volume[uuid\:%s]\ because\ there\ are\ pci\ devices\ attached = cannot migrate root volume[uuid:{0}] because there are pci devices attached

# at: src/main/java/org/zstack/pciDevice/PciDeviceManager.java:1167
# args: pciUuid,vmUuid
pci\ device[uuid\:%s]\ doesn't\ exist\ or\ is\ disabled\ for\ vm[uuid\:%s] = pci device[uuid:{0}] doesn't exist or is disabled for vm[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/PciDeviceManager.java:1176
# args: pciUuid,vo.getVmInstanceUuid(),vmUuid
pci\ device[uuid\:%s]\ already\ attached\ to\ vm[uuid\:%s],\ cannot\ attach\ to\ vm[uuid\:%s] = pci device[uuid:{0}] already attached to vm[uuid:{1}], cannot attach to vm[uuid:{2}]

# at: src/main/java/org/zstack/pciDevice/PciDeviceReserveFlow.java:732
# args: pciDeviceUuid, vmInstanceUuid
pci\ device[uuid\:%s]\ can\ not\ attach\ to\ vm[uuid\:%s]\ due\ to\ wrong\ status = pci device[uuid:{0}] can not attach to vm[uuid:{1}] due to wrong status

# at: src/main/java/org/zstack/pciDevice/PciHostChangeStateExtension.java:58
# args: inventory.getUuid(),hasPciVmUuids.toString()
The\ host\ [%s]\ has\ failed\ to\ enter\ the\ maintenance,\ The\ vm\ [%s]\ cannot\ migrate\ automatically\ because\ it\ contains\ the\ PCI\ device = The host [{0}] has failed to enter the maintenance, The vm [{1}] cannot migrate automatically because it contains the PCI device

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:258
# args: vmUuid,state
vm\ instance[uuid\:%s,\ state\:%s]\ needs\ to\ be\ stopped\ to\ set\ pci\ device\ spec = vm instance[uuid:{0}, state:{1}] needs to be stopped to set pci device spec

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:169
# args: msg.getVmInstanceUuid(),msg.getPciSpecUuid()
vm[uuid\:%s]\ already\ has\ pci\ device\ spec[uuid\:%s] = vm[uuid:{0}] already has pci device spec[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:197
# args: msg.getVmInstanceUuid(),msg.getPciSpecUuid()
vm[uuid\:%s]\ doesn't\ have\ pci\ device\ spec[uuid\:%s] = vm[uuid:{0}] doesn't have pci device spec[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:204
# args: vm.getUuid(),vm.getState(),msg.getPciSpecUuid()
vm\ instance[uuid\:%s,\ state\:%s]\ needs\ to\ be\ stopped\ to\ remove\ pci\ device\ spec[uuid\:%s] = vm instance[uuid:{0}, state:{1}] needs to be stopped to remove pci device spec[uuid:{2}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:285
# args: msg.getVmInstanceUuid(),msg.getMdevSpecUuid()
vm[uuid\:%s]\ already\ has\ mdev\ device\ spec[uuid\:%s] = vm[uuid:{0}] already has mdev device spec[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:293
# args: vm.getUuid(),vm.getState()
vm\ instance[uuid\:%s,\ state\:%s]\ needs\ to\ be\ stopped\ to\ set\ mdev\ device\ spec = vm instance[uuid:{0}, state:{1}] needs to be stopped to set mdev device spec

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:306
# args: msg.getVmInstanceUuid(),msg.getMdevSpecUuid()
vm[uuid\:%s]\ doesn't\ have\ mdev\ device\ spec[uuid\:%s] = vm[uuid:{0}] doesn't have mdev device spec[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:313
# args: vm.getUuid(),vm.getState(),msg.getMdevSpecUuid()
vm\ instance[uuid\:%s,\ state\:%s]\ needs\ to\ be\ stopped\ to\ remove\ mdev\ device\ spec[uuid\:%s] = vm instance[uuid:{0}, state:{1}] needs to be stopped to remove mdev device spec[uuid:{2}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationManagerImpl.java:373
# args: msg.getPciSpecUuid(),msg.getVmInstanceUuid()
pci\ device\ spec[uuid\:%s]\ is\ not\ available\ for\ vm[uuid\:%s] = pci device spec[uuid:{0}] is not available for vm[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationManagerImpl.java:371
# args: msg.getVmInstanceUuid()
no\ pci\ device\ spec\ available\ for\ vm[uuid\:%s] = no pci device spec available for vm[uuid:{0}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationManagerImpl.java:366
# args: msg.getVmInstanceUuid(),rly.getError()
failed\ to\ get\ pci\ device\ spec\ available\ for\ vm[uuid\:%s]\:\ %s = failed to get pci device spec available for vm[uuid:{0}]: {1}

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationManagerImpl.java:454
# args: pciUuidsNotMatch,msg.getVmInstanceUuid(),vmUuidsPciAttached
pci\ devices[uuid\:%s]\ should\ have\ been\ attached\ to\ vm[uuid\:%s]\ but\ it\ is\ attached\ to\ vm[uuid\:%s] = pci devices[uuid:{0}] should have been attached to vm[uuid:{1}] but it is attached to vm[uuid:{2}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationManagerImpl.java:565
# args: msg.getMdevSpecUuid(),msg.getVmInstanceUuid()
mdev\ device\ spec[uuid\:%s]\ is\ not\ available\ for\ vm[uuid\:%s] = mdev device spec[uuid:{0}] is not available for vm[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationManagerImpl.java:558
# args: msg.getVmInstanceUuid()
no\ mdev\ device\ spec\ available\ for\ vm[uuid\:%s] = no mdev device spec available for vm[uuid:{0}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationManagerImpl.java:779
# args: specUuid,systemTag
pci\ device\ spec[uuid\:%s]\ doesn't\ exist = pci device spec[uuid:{0}] doesn't exist

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationManagerImpl.java:792
# args: specUuid,systemTag
mdev\ device\ spec[uuid\:%s]\ doesn't\ exist = mdev device spec[uuid:{0}] doesn't exist

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:153
# args: 
cluster\ uuids\ or\ host\ uuid\ or\ vm\ uuid\ can\ not\ be\ set\ at\ same\ time = cluster uuids or host uuid or vm uuid can not be set at same time

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:160
# args: 
clusters\ not\ exist\ or\ disabled = clusters not exist or disabled

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:194
# args: type,legalTypes
illegal\ mdev\ device\ type\ [%s],\ only\ %s\ are\ legal = illegal mdev device type [{0}], only {1} are legal

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:67
# args: 
cannot\ change\ the\ state\ of\ mdev\ device\ that's\ in\ attached\ status = cannot change the state of mdev device that's in attached status

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:75
# args: msg.getMdevDeviceUuid()
cannot\ attach\ mdev\ device[uuid\:%s]\ to\ vm,\ make\ sure\ it's\ enabled\ and\ un-attached = cannot attach mdev device[uuid:{0}] to vm, make sure it's enabled and un-attached

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:182
# args: 
cannot\ attach\ mdev\ device\ to\ vm\ instance\ that's\ not\ stopped = cannot attach mdev device to vm instance that's not stopped

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:95
# args: msg.getVmInstanceUuid(),msg.getMdevDeviceUuid()
vm[uuid\:%s]\ has\ pci\ devices\ attached\ that\ are\ in\ different\ host\ with\ mdev\ device[uuid\:%s] = vm[uuid:{0}] has pci devices attached that are in different host with mdev device[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:105
# args: msg.getVmInstanceUuid(),msg.getMdevDeviceUuid()
vm[uuid\:%s]\ has\ mdev\ devices\ attached\ that\ are\ in\ different\ host\ with\ mdev\ device[uuid\:%s] = vm[uuid:{0}] has mdev devices attached that are in different host with mdev device[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:112
# args: mdev.getHostUuid(),mdev.getUuid(),HostState.Enabled,HostStatus.Connected
the\ host[uuid\:%s]\ that\ holds\ mdev\ device[uuid\:%s]\ is\ not\ [%s]\ and\ [%s] = the host[uuid:{0}] that holds mdev device[uuid:{1}] is not [{2}] and [{3}]

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:121
# args: mdev.getHostUuid(),mdev.getUuid(),HostState.Enabled,HostStatus.Connected
IOMMU\ of\ the\ host[uuid\:%s]\ that\ hosts\ pci\ device[uuid\:%s]\ is\ not\ [%s]\ and\ [%s] = IOMMU of the host[uuid:{0}] that hosts pci device[uuid:{1}] is not [{2}] and [{3}]

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:134
# args: msg.getMdevDeviceUuid(),msg.getVmInstanceUuid()
mdev\ device\ [uuid\:%s]\ is\ not\ attached\ to\ vm[uuid\:%s] = mdev device [uuid:{0}] is not attached to vm[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:143
# args: 
cannot\ detach\ mdev\ device\ from\ vm\ instance\ when\ it's\ not\ stopped = cannot detach mdev device from vm instance when it's not stopped

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceBase.java:111
# args: msg.getVmInstanceUuid(),msg.getMdevDeviceUuid()
vm[uuid\:%s]\ cannot\ start\ in\ host\ that\ hold\ mdev\ device[uuid\:%s] = vm[uuid:{0}] cannot start in host that hold mdev device[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceFactory.java:68
# args: pciDevice.getUuid(),PciDeviceVirtStatus.VFIO_MDEV_VIRTUALIZED
pci\ device[uuid\:%s]\ is\ known\ as\ %s,\ but\ cannot\ find\ it's\ mdev\ spec,\ so\ abort. = pci device[uuid:{0}] is known as {1}, but cannot find it's mdev spec, so abort.

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceHostChangeStateExtension.java:55
# args: inventory.getUuid(),hasMdevVmUuids.toString()
The\ host\ [%s]\ has\ failed\ to\ enter\ the\ maintenance,\ because\ vm[%s]\ has\ mdev\ devices\ attached\ and\ cannot\ migrate\ automatically = The host [{0}] has failed to enter the maintenance, because vm[{1}] has mdev devices attached and cannot migrate automatically

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceManagerImpl.java:133
# args: msg.getVmInstanceUuid(),rly.getError()
failed\ to\ get\ candidate\ hosts\ to\ start\ vm[uuid\:%s],\ %s = failed to get candidate hosts to start vm[uuid:{0}], {1}

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceManagerImpl.java:231
# args: msg.getMdevDeviceUuid()
cannot\ find\ mdev\ device[uuid\:%s],\ it\ may\ have\ been\ deleted = cannot find mdev device[uuid:{0}], it may have been deleted

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceManagerImpl.java:403
# args: mdevUuid,vmUuid
mdev\ device[uuid\:%s]\ doesn't\ exist\ or\ is\ disabled\ for\ vm[uuid\:%s] = mdev device[uuid:{0}] doesn't exist or is disabled for vm[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceManagerImpl.java:412
# args: mdevUuid,vo.getVmInstanceUuid(),vmUuid
mdev\ device[uuid\:%s]\ already\ attached\ to\ vm[uuid\:%s],\ cannot\ attach\ to\ vm\ [uuid\:%s] = mdev device[uuid:{0}] already attached to vm[uuid:{1}], cannot attach to vm [uuid:{2}]

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceManagerImpl.java:509
# args: msg.getVmInstanceUuid()
can\ not\ migrate\ vm[uuid\:%s]\ since\ mdev\ device\ attached = can not migrate vm[uuid:{0}] since mdev device attached

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceManagerImpl.java:538
# args: msg.getVolumeUuid()
cannot\ migrate\ root\ volume[uuid\:%s]\ because\ there\ are\ mdev\ devices\ attached = cannot migrate root volume[uuid:{0}] because there are mdev devices attached

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceManagerImpl.java:553
# args: msg.getVmInstanceUuid()
cannot\ migrate\ vm[uuid\:%s]\ because\ there\ are\ mdev\ devices\ attached = cannot migrate vm[uuid:{0}] because there are mdev devices attached

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceManagerImpl.java:796
# args: mdev.getUuid(),mdev.getHostUuid(),attachedMdevUuid,dstHostUuid
specified\ mdev\ devices\ not\ on\ same\ host\:\ mdev\ device[uuid\:\ %s]\ on\ host[uuid\:\ %s]\ while\ mdev\ device[uuid\:\ %s]\ on\ host[uuid\:\ %s] = specified mdev devices not on same host: mdev device[uuid: {0}] on host[uuid: {1}] while mdev device[uuid: {2}] on host[uuid: {3}]

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceManagerImpl.java:829
# args: 
no\ candidate\ host\ with\ enough\ mdev\ devices = no candidate host with enough mdev devices

# at: src/main/java/org/zstack/pluginpremium/compute/allocator/MaxInstancePerHostAllocatorFlow.java:70
# args: maxInstancePerHost
No\ host\ with\ fewer\ than\ %s\ vms\ found = No host with fewer than {0} vms found

# at: src/main/java/org/zstack/pluginpremium/compute/allocator/MaxInstancePerHostHostAllocatorStrategyFactory.java:58
# args: HostAllocatorConstant.MAX_INSTANCE_PER_HOST_HOST_ALLOCATOR_STRATEGY_TYPE,HostAllocatorSystemTags.MAX_INSTANCE_PER_HOST_TOKEN
Select\ %s\ strategy,\ you\ must\ set\ %s = Select {0} strategy, you must set {1}

# at: src/main/java/org/zstack/pluginpremium/compute/allocator/MinimumMemoryUsageHostAllocatorStrategyFactory.java:58
# args: HostAllocatorSystemTags.MINIMUM_MEMORY_USAGE_HOST_ALLOCATOR_STRATEGY_MODE_TOKEN,modes
Incorrect\ %s\ settings,\ valid\ value\ is\ %s = Incorrect {0} settings, valid value is {1}

# at: src/main/java/org/zstack/policyRoute/PolicyRouteApiInterceptor.java:326
# args: 
can\ not\ find\ related\ virtual\ router = can not find related virtual router

# at: src/main/java/org/zstack/policyRoute/PolicyRouteApiInterceptor.java:117
# args: msg.getL3Uuid()
l3[%s]\ already\ attached\ a\ policy\ route\ ruleSet = l3[{0}] already attached a policy route ruleSet

# at: src/main/java/org/zstack/policyRoute/PolicyRouteApiInterceptor.java:168
# args: msg.getvRouterUuid(),msg.getName()
VRouter[%s]\ already\ has\ a\ ruleSet\ named\ %s = VRouter[{0}] already has a ruleSet named {1}

# at: src/main/java/org/zstack/policyRoute/PolicyRouteApiInterceptor.java:174
# args: msg.getDestinationCidr()
DestinationCidr\ must\ be\ in\ cidr\ format\ but\ found\ [%s] = DestinationCidr must be in cidr format but found [{0}]

# at: src/main/java/org/zstack/policyRoute/PolicyRouteApiInterceptor.java:178
# args: msg.getNextHopIp()
NextHopIp\ must\ be\ in\ ipv4\ format\ but\ found\ [%s] = NextHopIp must be in ipv4 format but found [{0}]

# at: src/main/java/org/zstack/policyRoute/PolicyRouteApiInterceptor.java:249
# args: 
can\ not\ find\ related\ vRouter = can not find related vRouter

# at: src/main/java/org/zstack/policyRoute/PolicyRouteApiInterceptor.java:271
# args: msg.getvRouterUuid(),msg.getNumber()
VRouter[%s]\ already\ has\ a\ policy\ route\ table\ [%s] = VRouter[{0}] already has a policy route table [{1}]

# at: src/main/java/org/zstack/policyRoute/PolicyRouteApiInterceptor.java:309
# args: msg.getUuid()
ruleSet[%s]\ is\ still\ attached\ to\ nic = ruleSet[{0}] is still attached to nic

# at: src/main/java/org/zstack/policyRoute/PolicyRouteManagerImpl.java:743
# args: vrouterVmUuid
virtual\ router[uuid\:%s]\ can\ not\ find = virtual router[uuid:{0}] can not find

# at: src/main/java/org/zstack/policyRoute/PolicyRouteManagerImpl.java:748
# args: vo.getApplianceVmType()
can\ not\ find\ service\ factory\ for\ virtual\ router\ type[%s] = can not find service factory for virtual router type[{0}]

# at: src/main/java/org/zstack/portMirror/PortMirrorApiInterceptor.java:47
# args: msg.getMirrorNetworkUuid()
Invalid\ parameter\ [%s],\ make\ sure\ it's\ PortMirror\ Network = Invalid parameter [{0}], make sure it's PortMirror Network

# at: src/main/java/org/zstack/portMirror/PortMirrorApiInterceptor.java:55
# args: msg.getMirrorNetworkUuid()
The\ network[%s]\ has\ been\ attached\ with\ a\ PortMirror\ service = The network[{0}] has been attached with a PortMirror service

# at: src/main/java/org/zstack/portMirror/PortMirrorApiInterceptor.java:63
# args: msg.getUuid()
The\ PortMirror\ service[%s]\ has\ not\ been\ created = The PortMirror service[{0}] has not been created

# at: src/main/java/org/zstack/portMirror/PortMirrorApiInterceptor.java:99
# args: msg.getSrcEndPoint(),msg.getDstEndPoint(),mirror.getUuid()
The\ nic[%s,\ %s]\ has\ been\ mirrored\ by\ service[%s] = The nic[{0}, {1}] has been mirrored by service[{2}]

# at: src/main/java/org/zstack/portMirror/PortMirrorApiInterceptor.java:105
# args: msg.getSrcEndPoint(),mirror.getUuid()
The\ nic[%s]\ can't\ been\ mirrored\ for\ service[%s]\ using = The nic[{0}] can't been mirrored for service[{1}] using

# at: src/main/java/org/zstack/portMirror/PortMirrorApiInterceptor.java:122
# args: msg.getSrcEndPoint()
The\ PortMirror\ service\ doesn't\ support\ to\ mirror\ the\ nic[%s] = The PortMirror service doesn't support to mirror the nic[{0}]

# at: src/main/java/org/zstack/portMirror/PortMirrorApiInterceptor.java:127
# args: msg.getDstEndPoint()
The\ PortMirror\ service\ doesn't\ support\ the\ nic[%s]\ because\ of\ its\ hypervisor\ type = The PortMirror service doesn't support the nic[{0}] because of its hypervisor type

# at: src/main/java/org/zstack/portMirror/PortMirrorApiInterceptor.java:134
# args: msg.getDstEndPoint()
The\ PortMirror\ service\ can't\ mirror\ to\ the\ nic[%s]\ that\ is\ not\ a\ non-default\ interface\ of\ a\ vm = The PortMirror service can't mirror to the nic[{0}] that is not a non-default interface of a vm

# at: src/main/java/org/zstack/portMirror/PortMirrorApiInterceptor.java:141
# args: msg.getSrcEndPoint()
The\ PortMirror\ service\ can't\ mirror\ the\ nic[%s]\ that\ is\ not\ an\ interface\ of\ any\ vm = The PortMirror service can't mirror the nic[{0}] that is not an interface of any vm

# at: src/main/java/org/zstack/portMirror/PortMirrorApiInterceptor.java:151
# args: msg.getSrcEndPoint(),msg.getDstEndPoint(),vo.getMirrorNetworkUuid()
The\ PortMirror\ service\ can't\ mirror\ the\ nic[%s]\ \ to\ nic[%s]\ because\ the\ mirror\ network[%s]\ can't\ setup\ the\ mirror\ tunnel = The PortMirror service can't mirror the nic[{0}]  to nic[{1}] because the mirror network[{2}] can't setup the mirror tunnel

# at: src/main/java/org/zstack/portMirror/PortMirrorApiInterceptor.java:157
# args: msg.getSrcEndPoint()
The\ PortMirror\ service\ can't\ mirror\ the\ nic[%s]\ to\ itself = The PortMirror service can't mirror the nic[{0}] to itself

# at: src/main/java/org/zstack/portMirror/PortMirrorApiInterceptor.java:163
# args: 
The\ PortMirror\ service\ can't\ work\ at\ the\ nic\ with\ configured\ Qos = The PortMirror service can't work at the nic with configured Qos

# at: src/main/java/org/zstack/portMirror/PortMirrorManagerImpl.java:750
# args: sessionVO.getUuid(),errorCode.getDetails()
failed\ to\ delete\ portMirror\ session[%s]\ from\ hypervisor,\ detail\:\ %s = failed to delete portMirror session[{0}] from hypervisor, detail: {1}

# at: src/main/java/org/zstack/portMirror/PortMirrorManagerImpl.java:783
# args: sessionVO.getUuid(),errorCode.getDetails()
failed\ to\ release\ portMirror\ session[%s]\ from\ hypervisor,\ detail\:\ %s = failed to release portMirror session[{0}] from hypervisor, detail: {1}

# at: src/main/java/org/zstack/portMirror/PortMirrorManagerImpl.java:901
# args: vo.getUuid()
cannot\ find\ internal\ id\ of\ the\ session[uuid\:%s],\ are\ there\ too\ many\ sessions\ in\ a\ host??? = cannot find internal id of the session[uuid:{0}], are there too many sessions in a host???

# at: src/main/java/org/zstack/portal/apimediator/ApiMediatorImpl.java:246
# args: cmsg.getResourceUuid()
resourceUuid[%s]\ is\ not\ a\ valid\ uuid.\ A\ valid\ uuid\ is\ a\ UUID(v4\ recommended)\ with\ '-'\ stripped.\ see\ http\://en.wikipedia.org/wiki/Universally_unique_identifier\ for\ format\ of\ UUID,\ the\ regular\ expression\ ZStack\ uses\ to\ validate\ a\ UUID\ is\ '[0-9a-f]{8}[0-9a-f]{4}[1-5][0-9a-f]{3}[89ab][0-9a-f]{3}[0-9a-f]{12}' = resourceUuid[{0}] is not a valid uuid. A valid uuid is a UUID(v4 recommended) with '-' stripped. see http://en.wikipedia.org/wiki/Universally_unique_identifier for format of UUID, the regular expression ZStack uses to validate a UUID is '[0-9a-f]{8}[0-9a-f]{4}[1-5][0-9a-f]{3}[89ab][0-9a-f]{3}[0-9a-f]{12}'

# at: src/main/java/org/zstack/premium/externalservice/grafana/api/GrafanaAPI.java:122
# args: method
non\ support\ method\:\ %s = non support method: {0}

# at: src/main/java/org/zstack/premium/externalservice/grafana/api/GrafanaAPI.java:135
# args: statusCode,response.getStatusLine().getReasonPhrase()
http\ request\ error!\ status_code\:\ %s,\ error\:\ %s = http request error! status_code: {0}, error: {1}

# at: src/main/java/org/zstack/premium/externalservice/grafana/api/GrafanaDB.java:24
# args: r.getStderr()
sqlite3\ execute\ failed,\ because\:\ %s = sqlite3 execute failed, because: {0}

# at: src/main/java/org/zstack/premium/externalservice/grafana/api/GrafanaDashboard.java:34
# args: GrafanaDB.folderTitle
cannot\ find\ folder\:\ %s\ in\ dashboard = cannot find folder: {0} in dashboard

# at: src/main/java/org/zstack/premium/externalservice/loki/LokiFactory.java:84
# args: src.getAbsolutePath(),dst.getAbsolutePath(),rst.getStderr()
cannot\ copy\ %s\ to\ %s,\ caused\:\ %s = cannot copy {0} to {1}, caused: {2}

# at: src/main/java/org/zstack/premium/externalservice/loki/PromtailFactory.java:103
# args: 
ssh\ failed = ssh failed

# at: src/main/java/org/zstack/premium/externalservice/prometheus/MultiNodePrometheus.java:106
# args: v.getClass().getSimpleName(),k
unknown\ value\ type\ %s,\ key\ \=\ %s = unknown value type {0}, key = {1}

# at: src/main/java/org/zstack/premium/externalservice/prometheus/MultiNodePrometheus.java:132
# args: 
failed\ to\ HTTP\ call\ all\ prometheus\ instances = failed to HTTP call all prometheus instances

# at: src/main/java/org/zstack/privilege/admin/IAM2PrivilegeAdminAPIRequestChecker.java:48
# args: rbacEntity.getApiMessage().getSession().getUserUuid()
the\ operation\ is\ not\ permitted\ by\ white\ list\ of\ virtual-id[uuid\:%s] = the operation is not permitted by white list of virtual-id[uuid:{0}]

# at: src/main/java/org/zstack/privilege/admin/IAM2PrivilegeAdminAPIRequestChecker.java:60
# args: rbacEntity.getApiMessage().getSession().getUserUuid()
the\ operation\ is\ denied\ by\ black\ list\ of\ virtual-id[uuid\:%s] = the operation is denied by black list of virtual-id[uuid:{0}]

# at: src/main/java/org/zstack/privilege/admin/IAM2PrivilegeAdminPolicyHelper.java:199
# args: unmatchedApis,identity.toString()
action\:\ %s,\ is\ not\ supported\ for\ role\ identity\:\ %s = action: {0}, is not supported for role identity: {1}

# at: src/main/java/org/zstack/privilege/admin/IAM2PrivilegeAdminPolicyHelper.java:341
# args: msg.getName()
%s\ is\ a\ reserved\ name,\ please\ use\ another\ name = {0} is a reserved name, please use another name

# at: src/main/java/org/zstack/privilege/admin/IAM2PrivilegeAdminPolicyHelper.java:339
# args: 
the\ name\ of\ initial\ user\ can\ not\ be\ updated = the name of initial user can not be updated

# at: src/main/java/org/zstack/privilege/admin/IAM2PrivilegeAdminPolicyHelper.java:376
# args: 
cannot\ remove\ builtin\ system\ admin\ role\ from\ builtin\ system\ admin. = cannot remove builtin system admin role from builtin system admin.

# at: src/main/java/org/zstack/privilege/admin/IAM2PrivilegeAdminPolicyHelper.java:374
# args: 
cannot\ remove\ builtin\ security\ admin\ role\ from\ builtin\ security\ admin. = cannot remove builtin security admin role from builtin security admin.

# at: src/main/java/org/zstack/privilege/admin/IAM2PrivilegeAdminPolicyHelper.java:372
# args: 
cannot\ remove\ builtin\ audit\ admin\ role\ from\ builtin\ audit\ admin. = cannot remove builtin audit admin role from builtin audit admin.

# at: src/main/java/org/zstack/privilege/admin/IAM2PrivilegeAdminPolicyHelper.java:386
# args: 
cannot\ delete\ builtin\ system\ admin. = cannot delete builtin system admin.

# at: src/main/java/org/zstack/privilege/admin/IAM2PrivilegeAdminPolicyHelper.java:384
# args: 
cannot\ delete\ builtin\ security\ admin. = cannot delete builtin security admin.

# at: src/main/java/org/zstack/privilege/admin/IAM2PrivilegeAdminPolicyHelper.java:382
# args: 
cannot\ delete\ builtin\ audit\ admin. = cannot delete builtin audit admin.

# at: src/main/java/org/zstack/privilege/admin/IAM2PrivilegeAdminPolicyHelper.java:399
# args: 
Confirm\ the\ roles\ you\ want\ to\ add\ have\ same\ identity = Confirm the roles you want to add have same identity

# at: src/main/java/org/zstack/privilege/admin/IAM2PrivilegeAdminPolicyHelper.java:413
# args: msg.getRoleUuids(),identitySet,msg.getVirtualIDUuid()
Cannot\ add\ role\:\ %s\ with\ identity\:\ %s\ to\ virtualID[uuid\:%s] = Cannot add role: {0} with identity: {1} to virtualID[uuid:{2}]

# at: src/main/java/org/zstack/privilege/admin/IAM2PrivilegeAdminPolicyHelper.java:425
# args: String.join(",", privilegeAdminUuids),msg.getProjectUuid()
can\ not\ add\ privilege\ admin[uuids\:%s]\ to\ project[uuid\:%s] = can not add privilege admin[uuids:{0}] to project[uuid:{1}]

# at: src/main/java/org/zstack/query/MysqlQueryBuilderImpl3.java:432
# args: attr,inventoryClass.getName()
condition\ name[%s]\ is\ invalid,\ no\ such\ field\ on\ inventory\ class[%s] = condition name[{0}] is invalid, no such field on inventory class[{1}]

# at: src/main/java/org/zstack/query/MysqlQueryBuilderImpl3.java:437
# args: attr,attr,inventoryClass.getName()
condition\ name[%s]\ is\ invalid,\ field[%s]\ of\ inventory[%s]\ is\ annotated\ as\ @Unqueryable\ field = condition name[{0}] is invalid, field[{1}] of inventory[{2}] is annotated as @Unqueryable field

# at: src/main/java/org/zstack/query/MysqlQueryBuilderImpl3.java:448
# args: info.jpaMetaClass.getName(),attr
entity\ meta\ class[%s]\ has\ no\ field[%s] = entity meta class[{0}] has no field[{1}]

# at: src/main/java/org/zstack/query/MysqlQueryBuilderImpl3.java:1000
# args: f,info.inventoryClass.getSimpleName(),info.premitiveFieldNames
field[%s]\ is\ not\ a\ primitive\ of\ the\ inventory\ %s;\ you\ cannot\ specify\ it\ in\ the\ parameter\ 'fields';valid\ fields\ are\ %s = field[{0}] is not a primitive of the inventory {1}; you cannot specify it in the parameter 'fields';valid fields are {2}

# at: src/main/java/org/zstack/query/QueryFacadeImpl.java:496
# args: JSONObjectUtil.toJsonString(cond)
'value'\ of\ query\ condition\ %s\ cannot\ be\ null = 'value' of query condition {0} cannot be null

# at: src/main/java/org/zstack/resourceconfig/ResourceConfig.java:326
# args: resourceUuid
cannot\ find\ resource[uuid\:\ %s] = cannot find resource[uuid: {0}]

# at: src/main/java/org/zstack/resourceconfig/ResourceConfig.java:330
# args: globalConfig.getCategory(),globalConfig.getName(),resourceType
ResourceConfig\ [category\:%s,\ name\:%s]\ cannot\ bind\ to\ resourceType\:\ %s = ResourceConfig [category:{0}, name:{1}] cannot bind to resourceType: {2}

# at: src/main/java/org/zstack/resourceconfig/ResourceConfigApiInterceptor.java:60
# args: msg.getResourceUuid()
account\ has\ no\ access\ to\ the\ resource[uuid\:\ %s] = account has no access to the resource[uuid: {0}]

# at: src/main/java/org/zstack/resourceconfig/ResourceConfigApiInterceptor.java:43
# args: msg.getCategory(),msg.getName()
no\ global\ config[category\:%s,\ name\:%s]\ found = no global config[category:{0}, name:{1}] found

# at: src/main/java/org/zstack/resourceconfig/ResourceConfigApiInterceptor.java:49
# args: msg.getCategory(),msg.getName()
global\ config[category\:%s,\ name\:%s]\ cannot\ bind\ resource = global config[category:{0}, name:{1}] cannot bind resource

# at: src/main/java/org/zstack/rest/TypeVerifier.java:22
# args: f.getName(),source
[%s]\ field\ is\ excepted\ an\ int\ or\ long,\ but\ was\ [%s]. = [{0}] field is excepted an int or long, but was [{1}].

# at: src/main/java/org/zstack/rest/TypeVerifier.java:31
# args: f.getName(),source
Invalid\ value\ for\ boolean\ field\ [%s],\ [%s]\ is\ not\ a\ valid\ boolean\ string[true,\ false]. = Invalid value for boolean field [{0}], [{1}] is not a valid boolean string[true, false].

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:69
# args: msg.getAreaId()
[%s]\ is\ not\ formatted\ as\ IPv4\ address = [{0}] is not formatted as IPv4 address

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:108
# args: msg.getAreaAuth()
KeyID\ &\ password\ must\ be\ not\ null\ when\ authentication\ type\ is\ %s = KeyID & password must be not null when authentication type is {0}

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:114
# args: msg.getAreaAuth()
password\ must\ be\ not\ null\ when\ authentication\ type\ is\ %s = password must be not null when authentication type is {0}

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:118
# args: msg.getAreaAuth()
the\ length\ of\ password\ is\ at\ most\ than\ 8Bytes\ when\ authentication\ type\ is\ %s = the length of password is at most than 8Bytes when authentication type is {0}

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:127
# args: vo.getAreaId(),RouterAreaType.Standard.toString()
AreaId[%s]\ type\ must\ be\ %s = AreaId[{0}] type must be {1}

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:97
# args: msg.getAreaId()
AreaId[%s]\ has\ been\ created = AreaId[{0}] has been created

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:158
# args: vo.getL3NetworkUuid(),haUuid
The\ network[%s]\ have\ been\ added\ into\ the\ haGroup[%s] = The network[{0}] have been added into the haGroup[{1}]

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:150
# args: vo.getL3NetworkUuid(),vo.getRouterAreaUuid()
The\ network[%s]\ have\ been\ added\ into\ the\ virtual\ routerArea[%s] = The network[{0}] have been added into the virtual routerArea[{1}]

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:181
# args: msg.getRouterId()
Router\ ID[%s]\ is\ not\ formatted\ as\ IPv4\ address = Router ID[{0}] is not formatted as IPv4 address

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:193
# args: msg.getRouterId()
Router\ ID[%s]\ is\ not\ unique\ in\ this\ system = Router ID[{0}] is not unique in this system

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:188
# args: 
cron\ must\ be\ set\ when\ use\ cron\ scheduler = cron must be set when use cron scheduler

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:194
# args: 
cron\ task\ must\ follow\ format\ like\ this\ \:\ \"0\ 0/3\ 17-23\ *\ *\ ?\"\  = cron task must follow format like this : \"0 0/3 17-23 * * ?\" 

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:197
# args: 
cron\ scheduler\ only\ need\ to\ specify\ cron\ task = cron scheduler only need to specify cron task

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:206
# args: 
startTime\ out\ of\ range = startTime out of range

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:202
# args: 
startTime\ must\ be\ positive\ integer\ or\ 0 = startTime must be positive integer or 0

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:183
# args: 
stopTime\ has\ been\ passed = stopTime has been passed

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:181
# args: 
stopTime\ out\ of\ mysql\ timestamp\ range = stopTime out of mysql timestamp range

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:179
# args: 
duration\ time\ out\ of\ range = duration time out of range

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:98
# args: 
interval\ must\ be\ set\ when\ use\ simple\ scheduler\ when\ repeat\ more\ than\ once = interval must be set when use simple scheduler when repeat more than once

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:133
# args: msg.getSchedulerJobUuid(),msg.getSchedulerTriggerUuid()
Can\ not\ add\ job[uuid\:%s]\ twice\ to\ the\ same\ trigger[uuid\:%s] = Can not add job[uuid:{0}] twice to the same trigger[uuid:{1}]

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:138
# args: msg.getSchedulerJobUuid(),msg.getSchedulerTriggerUuid()
Can\ not\ add\ job[uuid\:%s]\ to\ a\ out\ of\ time\ trigger[uuid\:%s] = Can not add job[uuid:{0}] to a out of time trigger[uuid:{1}]

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:146
# args: count,msg.getSchedulerJobUuid()
There\ are\ [%d]\ triggers\ added\ to\ job[uuid\:%s],\ cannot\ add\ any\ more. = There are [{0}] triggers added to job[uuid:{1}], cannot add any more.

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:161
# args: count,msg.getSchedulerJobGroupUuid()
There\ are\ [%d]\ triggers\ added\ to\ job\ group[uuid\:%s],\ cannot\ add\ any\ more. = There are [{0}] triggers added to job group[uuid:{1}], cannot add any more.

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:191
# args: 
invalid\ cron\ expression = invalid cron expression

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:171
# args: 
startTime\ must\ be\ set\ for\ simple\ scheduler = startTime must be set for simple scheduler

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:175
# args: 
schedulerInterval\ must\ be\ set\ for\ simple\ scheduler = schedulerInterval must be set for simple scheduler

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:239
# args: msg.getParameters().get(SchedulerJobParameters.snapshotMax),e.getMessage()
snapshotMaxNumber\ \:\ %s\ format\ error\ because\ %s = snapshotMaxNumber : {0} format error because {1}

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:265
# args: n
%d\ jobs\ have\ different\ job\ type\ with\ job\ group = {0} jobs have different job type with job group

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:274
# args: count,limit - count
job\ group\ has\ contained\ %d\ job,\ only\ %d\ seats\ left = job group has contained {0} job, only {1} seats left

# at: src/main/java/org/zstack/scheduler/SchedulerFacadeImpl.java:500
# args: jobUuid,e.getMessage()
trigger\ job[uuid\:\ %s]\ failed,\ because\ %s = trigger job[uuid: {0}] failed, because {1}

# at: src/main/java/org/zstack/scheduler/SchedulerFacadeImpl.java:613
# args: jobUuid,jobGroupUuid
Scheduler\ job[uuid\:%s]\ already\ in\ group[uuid\:\ %s] = Scheduler job[uuid:{0}] already in group[uuid: {1}]

# at: src/main/java/org/zstack/scheduler/SchedulerJobParamCascadeUpdater.java:86
# args: field.getName()
field[%s]\ cannot\ be\ empty = field[{0}] cannot be empty

# at: src/main/java/org/zstack/scheduler/vm/StopVmInstanceJob.java:78
# args: getTargetResourceUuid()
vm[uuid\:%s]\ is\ destroyed,\ state\ change\ is\ not\ allowed = vm[uuid:{0}] is destroyed, state change is not allowed

# at: src/main/java/org/zstack/sdnController/SdnControllerApiInterceptor.java:92
# args: msg.getVendorType(),SdnControllerType.getAllTypeNames()
Sdn\ controller\ type\:\ %s\ in\ not\ in\ the\ supported\ list\:\ %s\  = Sdn controller type: {0} in not in the supported list: {1} 

# at: src/main/java/org/zstack/sdnController/SdnControllerApiInterceptor.java:97
# args: 
H3C\ VCFC\ controller\ must\ include\ systemTags\ vdsUuid\:\:{%s} = H3C VCFC controller must include systemTags vdsUuid::'{{0}'}

# at: src/main/java/org/zstack/sdnController/h3c/H3cSdnController.java:117
# args: self.getIp(),e.getLocalizedMessage()
get\ sdn\ controller\ [ip\:%s]\ vni\ range\ failed\ because\ %s = get sdn controller [ip:{0}] vni range failed because {1}

# at: src/main/java/org/zstack/sdnController/h3c/H3cSdnController.java:87
# args: self.getIp()
get\ vni\ range\ on\ sdn\ controller\ [ip\:%s]\ failed = get vni range on sdn controller [ip:{0}] failed

# at: src/main/java/org/zstack/sdnController/h3c/H3cSdnController.java:149
# args: self.getIp()
there\ is\ no\ vni\ range\ on\ sdn\ controller\ [ip\:%s] = there is no vni range on sdn controller [ip:{0}]

# at: src/main/java/org/zstack/sdnController/h3c/H3cSdnController.java:155
# args: self.getIp()
there\ is\ no\ default\ tenant\ on\ sdn\ controller\ [ip\:%s] = there is no default tenant on sdn controller [ip:{0}]

# at: src/main/java/org/zstack/sdnController/h3c/H3cSdnController.java:275
# args: self.getIp(),e.getMessage()
create\ vxlan\ network\ on\ sdn\ controller\ [ip\:%s]\ failed\ because\ %s = create vxlan network on sdn controller [ip:{0}] failed because {1}

# at: src/main/java/org/zstack/sdnController/h3c/H3cSdnController.java:259
# args: self.getIp()
create\ vxlan\ network\ on\ sdn\ controller\ [ip\:%s]\ failed = create vxlan network on sdn controller [ip:{0}] failed

# at: src/main/java/org/zstack/sdnController/h3c/H3cSdnController.java:321
# args: self.getIp(),e.getMessage()
delete\ vxlan\ network\ on\ sdn\ controller\ [ip\:%s]\ failed\ because\ %s = delete vxlan network on sdn controller [ip:{0}] failed because {1}

# at: src/main/java/org/zstack/sdnController/h3c/H3cSdnController.java:315
# args: self.getIp()
delete\ vxlan\ network\ on\ sdn\ controller\ [ip\:%s]\ failed = delete vxlan network on sdn controller [ip:{0}] failed

# at: src/main/java/org/zstack/sdnController/h3c/H3cSdnController.java:381
# args: self.getIp(),e.getMessage()
get\ token\ of\ sdn\ controller\ [ip\:%s]\ failed\ because\ %s = get token of sdn controller [ip:{0}] failed because {1}

# at: src/main/java/org/zstack/sdnController/h3c/H3cSdnController.java:352
# args: self.getIp()
get\ leader\ of\ sdn\ controller\ [ip\:%s]\ failed = get leader of sdn controller [ip:{0}] failed

# at: src/main/java/org/zstack/sdnController/h3c/H3cSdnController.java:373
# args: self.getIp()
get\ token\ of\ sdn\ controller\ [ip\:%s]\ failed = get token of sdn controller [ip:{0}] failed

# at: src/main/java/org/zstack/sdnController/hardwareVxlan/HardwareVxlanNetwork.java:72
# args: vo.getPoolUuid()
there\ is\ no\ sdn\ controller\ for\ vxlan\ pool\ [uuid\:%s] = there is no sdn controller for vxlan pool [uuid:{0}]

# at: src/main/java/org/zstack/sdnController/hardwareVxlan/HardwareVxlanNetworkFactory.java:259
# args: inv.getUuid(),destHostUuid
cannot\ configure\ hardware\ vxlan\ network\ for\ vm[uuid\:%s]\ on\ the\ destination\ host[uuid\:%s] = cannot configure hardware vxlan network for vm[uuid:{0}] on the destination host[uuid:{1}]

# at: src/main/java/org/zstack/sdnController/hardwareVxlan/HardwareVxlanNetworkPoolFactory.java:110
# args: 
hardware\ vxlan\ network\ pool\ doesn't\ support\ create\ l3\ network = hardware vxlan network pool doesn't support create l3 network

# at: src/main/java/org/zstack/sdnController/hardwareVxlan/HardwareVxlanNetworkPoolFactory.java:116
# args: 
hardware\ vxlan\ network\ pool\ must\ configure\ the\ physical\ interface = hardware vxlan network pool must configure the physical interface

# at: src/main/java/org/zstack/sdnController/hardwareVxlan/HardwareVxlanNetworkPoolFactory.java:124
# args: 
ONLY\ hardware\ vxlan\ network\ can\ be\ created\ in\ hardware\ vxlan\ pool = ONLY hardware vxlan network can be created in hardware vxlan pool

# at: src/main/java/org/zstack/sdnController/hardwareVxlan/HardwareVxlanNetworkPoolFactory.java:129
# args: 
hardware\ vxlan\ network\ can\ ONLY\ be\ created\ in\ hardware\ vxlan\ pool = hardware vxlan network can ONLY be created in hardware vxlan pool

# at: src/main/java/org/zstack/sdnController/hardwareVxlan/KVMRealizeHardwareVxlanNetworkBackend.java:75
# args: cmd.getBridgeName(),l2Network.getUuid(),l2Network.getType(),vlanId,hostUuid,rsp.getError()
failed\ to\ create\ bridge[%s]\ for\ hardwareVxlan[uuid\:%s,\ type\:%s,\ vlan\:%s]\ on\ kvm\ host[uuid\:%s],\ because\ %s = failed to create bridge[{0}] for hardwareVxlan[uuid:{1}, type:{2}, vlan:{3}] on kvm host[uuid:{4}], because {5}

# at: src/main/java/org/zstack/sdnController/hardwareVxlan/KVMRealizeHardwareVxlanNetworkBackend.java:129
# args: cmd.getBridgeName(),vxlan.getUuid(),vxlan.getName(),hostUuid,rsp.getError()
failed\ to\ check\ bridge[%s]\ for\ hardwareVxlan[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:%s],\ %s = failed to check bridge[{0}] for hardwareVxlan[uuid:{1}, name:{2}] on kvm host[uuid:{3}], {4}

# at: src/main/java/org/zstack/sdnController/hardwareVxlan/KVMRealizeHardwareVxlanPoolNetworkBackend.java:61
# args: l2Network.getUuid(),l2Network.getName(),hostUuid,rsp.getError()
failed\ to\ check\ physical\ interface\ for\ HardwareVxlanPool[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:\ %s],\ %s = failed to check physical interface for HardwareVxlanPool[uuid:{0}, name:{1}] on kvm host[uuid: {2}], {3}

# at: src/main/java/org/zstack/simulator/SimulatorHost.java:92
# args: 
set\ to\ disconnected = set to disconnected

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:60
# args: msg.getApplicationEndpointUuid()
can\ not\ add\ same\ email\ address\ to\ endpoint[uuid\:%s] = can not add same email address to endpoint[uuid:{0}]

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:171
# args: errorEmails
invalid\ email\ address[%s] = invalid email address[{0}]

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:73
# args: msg.getEmailAddress(),msg.getApplicationEndpointUuid()
cannot\ update\ email\ address\ to\ %s,\ which\ is\ already\ exists\ in\ endpoint[uuid\:%s] = cannot update email address to {0}, which is already exists in endpoint[uuid:{1}]

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:87
# args: msg.getPhoneNumber()
phone\ number\ [%s]\ already\ exists = phone number [{0}] already exists

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:99
# args: 
password\ is\ not\ set\ while\ username\ is\ set = password is not set while username is set

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:112
# args: msg.getPhoneNumber()
phone\ number[%s]\ already\ exists = phone number[{0}] already exists

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:121
# args: url
invalid\ url[%s] = invalid url[{0}]

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:127
# args: host
[%s]\ is\ not\ a\ legal\ ip = [{0}] is not a legal ip

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:133
# args: n
invalid\ phone\ number[%s],\ the\ DingDing\ phone\ number\ is\ like\ +86-12388889999 = invalid phone number[{0}], the DingDing phone number is like +86-12388889999

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:150
# args: 
username\ and\ password\ must\ either\ absent\ at\ all\ or\ present\ with\ each\ other = username and password must either absent at all or present with each other

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:158
# args: 
can\ not\ create\ sns\ email\ endpoint\ without\ any\ email\ address = can not create sns email endpoint without any email address

# at: src/main/java/org/zstack/sns/SNSApplicationPlatformBase.java:118
# args: 
the\ operation\ is\ not\ permitted\ for\ the\ system\ application\ platform = the operation is not permitted for the system application platform

# at: src/main/java/org/zstack/sns/SNSManagerImpl.java:75
# args: msg.getTopicUuid()
cannot\ find\ the\ SNSTopic[uuid\:%s],\ it\ may\ have\ been\ deleted = cannot find the SNSTopic[uuid:{0}], it may have been deleted

# at: src/main/java/org/zstack/sns/SNSManagerImpl.java:93
# args: msg.getApplicationPlatformUuid()
cannot\ find\ SNSApplicationPlatform[uuid\:%s],\ it\ may\ have\ been\ deleted = cannot find SNSApplicationPlatform[uuid:{0}], it may have been deleted

# at: src/main/java/org/zstack/sns/SNSManagerImpl.java:103
# args: msg.getApplicationEndpointUuid()
cannot\ find\ SNSApplicationEndpoint[uuid\:%s],\ it\ may\ have\ been\ deleted = cannot find SNSApplicationEndpoint[uuid:{0}], it may have been deleted

# at: src/main/java/org/zstack/sns/SNSTopicBase.java:125
# args: 
the\ topic\ is\ not\ subscribed\ by\ any\ endpoints = the topic is not subscribed by any endpoints

# at: src/main/java/org/zstack/sns/SNSTopicBase.java:149
# args: 
application\ platform\ is\ disabled = application platform is disabled

# at: src/main/java/org/zstack/sns/SNSTopicBase.java:201
# args: 
application\ endpoint\ is\ disabled = application endpoint is disabled

# at: src/main/java/org/zstack/sns/platform/aliyunsms/SNSAliyunSmsApiInterceptor.java:34
# args: number
invalid\ phone\ number[%s],\ sms\ number\ is\ like\ +86-18654321234 = invalid phone number[{0}], sms number is like +86-18654321234

# at: src/main/java/org/zstack/sns/platform/aliyunsms/SNSAliyunSmsApiInterceptor.java:43
# args: msg.getAccessKeyUuid()
Aliyun\ account[uuid\:%s]\ not\ exists = Aliyun account[uuid:{0}] not exists

# at: src/main/java/org/zstack/sns/platform/aliyunsms/SNSAliyunSmsEndpoint.java:83
# args: SysErrors.RESOURCE_NOT_FOUND
Aliyun\ sms\ event\ text\ template\ not\ found. = Aliyun sms event text template not found.

# at: src/main/java/org/zstack/sns/platform/dingtalk/SNSDingTalkEndpoint.java:118
# args: rsp.getStatusCode(),rsp.getBody()
Sending\ message\ to\ DingTalk\ failure.\ status\:\ %s,\ body\:\ %s = Sending message to DingTalk failure. status: {0}, body: {1}

# at: src/main/java/org/zstack/sns/platform/email/SNSEmailApplicationPlatform.java:72
# args: getSelf().getSmtpServer(),getSelf().getSmtpPort()
cannot\ connect\ SMTP\ server[server\:\ %s,\ port\:\ %s]\ in\ 15\ seconds = cannot connect SMTP server[server: {0}, port: {1}] in 15 seconds

# at: src/main/java/org/zstack/sns/platform/email/SNSEmailApplicationPlatform.java:92
# args: e.getMessage()
SMTP\ server\ validation\ error\:\ %s = SMTP server validation error: {0}

# at: src/main/java/org/zstack/sns/platform/email/SNSEmailApplicationPlatform.java:134
# args: 
the\ endpoint\ is\ disabled = the endpoint is disabled

# at: src/main/java/org/zstack/sns/platform/email/SNSEmailApplicationPlatform.java:162
# args: 
no\ subject = no subject

# at: src/main/java/org/zstack/sns/platform/email/SNSEmailPlatformFactory.java:59
# args: 
The\ problem\ may\ be\ caused\ by\ an\ incorrect\ user\ name\ or\ password\ or\ email\ permission\ denied = The problem may be caused by an incorrect user name or password or email permission denied

# at: src/main/java/org/zstack/sns/platform/email/SNSEmailPlatformFactory.java:61
# args: smtpServer,smtpPort
Couldn't\ connect\ to\ host,\ port\:\ %s,\ %d.\ The\ problem\ may\ be\ caused\ by\ an\ incorrect\ smtpServer\ or\ smtpPort = Couldn't connect to host, port: {0}, {1}. The problem may be caused by an incorrect smtpServer or smtpPort

# at: src/main/java/org/zstack/sns/platform/http/SNSHttpEndpoint.java:67
# args: rsp.getStatusCode(),rsp.getBody()
HTTP\ POST\ failure.\ status\:\ %s,\ body\:\ %s = HTTP POST failure. status: {0}, body: {1}

# at: src/main/java/org/zstack/sns/system/SNSApiTopicManagerImpl.java:172
# args: endpoint.getType()
only\ HTTP\ endpoint\ can\ subscribe\ API\ topic,\ the\ endpoint[type\:%s]\ is\ not\ a\ HTTP\ endpoint = only HTTP endpoint can subscribe API topic, the endpoint[type:{0}] is not a HTTP endpoint

# at: src/main/java/org/zstack/sns/system/SNSApiTopicManagerImpl.java:191
# args: 
API\ topic\ cannot\ be\ deleted = API topic cannot be deleted

# at: src/main/java/org/zstack/sns/system/SNSSystemAlarmTopicManagerImpl.java:76
# args: 
system\ alarm\ topic\ cannot\ be\ deleted = system alarm topic cannot be deleted

# at: src/main/java/org/zstack/storage/backup/BackupStorageApiInterceptor.java:65
# args: name
%s\ should\ not\ be\ null = {0} should not be null

# at: src/main/java/org/zstack/storage/backup/BackupStorageApiInterceptor.java:88
# args: 
zoneUuids,\ backupStorageUuids\ must\ have\ at\ least\ one\ be\ none-empty\ list,\ or\ all\ is\ set\ to\ true = zoneUuids, backupStorageUuids must have at least one be none-empty list, or all is set to true

# at: src/main/java/org/zstack/storage/backup/BackupStorageApiInterceptor.java:118
# args: msg.getBackupStorageUuid(),msg.getZoneUuid()
backup\ storage[uuid\:%s]\ has\ not\ been\ attached\ to\ zone[uuid\:%s] = backup storage[uuid:{0}] has not been attached to zone[uuid:{1}]

# at: src/main/java/org/zstack/storage/backup/BackupStorageApiInterceptor.java:127
# args: msg.getBackupStorageUuid(),msg.getZoneUuid()
backup\ storage[uuid\:%s]\ has\ been\ attached\ to\ zone[uuid\:%s] = backup storage[uuid:{0}] has been attached to zone[uuid:{1}]

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:162
# args: url,e.toString()
failed\ to\ get\ header\ of\ image\ url\ %s\:\ %s = failed to get header of image url {0}: {1}

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:166
# args: url
failed\ to\ get\ header\ of\ image\ url\ %s = failed to get header of image url {0}

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:176
# args: self.getUuid(),self.getName(),url,size,self.getAvailableCapacity()
the\ backup\ storage[uuid\:%s,\ name\:%s]\ has\ not\ enough\ capacity\ to\ download\ the\ image[%s].Required\ size\:%s,\ available\ size\:%s = the backup storage[uuid:{0}, name:{1}] has not enough capacity to download the image[{2}].Required size:{3}, available size:{4}

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:173
# args: url,size
the\ image\ size\ get\ from\ url\ %s\ is\ %d\ bytes,\ it's\ too\ small\ for\ an\ image,\ please\ check\ the\ url\ again. = the image size get from url {0} is {1} bytes, it's too small for an image, please check the url again.

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:191
# args: msg.getClass().getName(),self.getStatus()
backup\ storage\ cannot\ proceed\ message[%s]\ because\ its\ status\ is\ %s = backup storage cannot proceed message[{0}] because its status is {1}

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:197
# args: msg.getClass().getName(),self.getState()
backup\ storage\ cannot\ proceed\ message[%s]\ because\ its\ state\ is\ %s = backup storage cannot proceed message[{0}] because its state is {1}

# at: src/main/java/org/zstack/storage/backup/BackupStorageCapacityUpdater.java:139
# args: size,backupStorageUuid,capacityVO.getAvailableCapacity()
cannot\ reserve\ %s\ on\ the\ backup\ storage[uuid\:%s],\ it\ only\ has\ %s\ available = cannot reserve {0} on the backup storage[uuid:{1}], it only has {2} available

# at: src/main/java/org/zstack/storage/backup/BackupStorageManagerImpl.java:279
# args: 
capacity\ reservation\ on\ all\ backup\ storage\ failed = capacity reservation on all backup storage failed

# at: src/main/java/org/zstack/storage/backup/BackupStorageReservedCapacityAllocatorFlow.java:46
# args: BackupStorageGlobalConfig.RESERVED_CAPACITY.value(),spec.getSize()
after\ subtracting\ reserved\ capacity[%s],\ no\ backup\ storage\ has\ required\ capacity[%s\ bytes] = after subtracting reserved capacity[{0}], no backup storage has required capacity[{1} bytes]

# at: src/main/java/org/zstack/storage/backup/CreateDatabaseBackupJob.java:284
# args: 
missing\ 'retentionType'\ in\ job\ parameters = missing 'retentionType' in job parameters

# at: src/main/java/org/zstack/storage/backup/CreateDatabaseBackupJob.java:288
# args: 
missing\ 'retentionValue'\ in\ job\ parameters = missing 'retentionValue' in job parameters

# at: src/main/java/org/zstack/storage/backup/CreateDatabaseBackupJob.java:292
# args: 
missing\ 'backupStorageUuids'\ in\ job\ parameters = missing 'backupStorageUuids' in job parameters

# at: src/main/java/org/zstack/storage/backup/CreateDatabaseBackupJob.java:296
# args: 
job\ parameter\ 'backupStorageUuids'\ is\ empty = job parameter 'backupStorageUuids' is empty

# at: src/main/java/org/zstack/storage/backup/CreateDatabaseBackupJob.java:301
# args: bsUuid
unexpected\ backup\ storage\ uuid\:\ %s = unexpected backup storage uuid: {0}

# at: src/main/java/org/zstack/storage/backup/CreateVmBackupJob.java:484
# args: getTargetResourceUuid()
volume[uuid\:%s]\ is\ deleted,\ state\ change\ is\ not\ allowed = volume[uuid:{0}] is deleted, state change is not allowed

# at: src/main/java/org/zstack/storage/backup/CreateVmBackupJob.java:114
# args: 
bandWidth\ must\ be\ a\ positive\ number = bandWidth must be a positive number

# at: src/main/java/org/zstack/storage/backup/CreateVmBackupJob.java:170
# args: 
missing\ job\ parameters = missing job parameters

# at: src/main/java/org/zstack/storage/backup/CreateVmBackupJob.java:429
# args: 
No\ available\ backup\ storage\ found,\ skip\ this\ job = No available backup storage found, skip this job

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupApiInterceptor.java:93
# args: msg.getDatabaseBackupUuid(),msg.getBackupStorageUuid()
database\ backup[uuid%s]\ has\ not\ been\ exported\ from\ backupStorage[uuid\:%s] = database backup[uuid{0}] has not been exported from backupStorage[uuid:{1}]

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupApiInterceptor.java:107
# args: msg.getDatabaseBackupUuid(),msg.getBackupStorageUuid()
database\ backup[uuid%s]\ has\ been\ exported\ from\ backupStorage[uuid\:%s] = database backup[uuid{0}] has been exported from backupStorage[uuid:{1}]

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupApiInterceptor.java:120
# args: 
do\ not\ allow\ cover\ database\ from\ backup = do not allow cover database from backup

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupApiInterceptor.java:124
# args: 
installPath\ and\ bsUrl\ are\ both\ need = installPath and bsUrl are both need

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupApiInterceptor.java:133
# args: 
databaseBackup[uuid\:%s]\ is\ not\ Enabled\ and\ Ready = databaseBackup[uuid:{0}] is not Enabled and Ready

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupApiInterceptor.java:142
# args: url
illegal\ url[%s],\ correct\ example\ is\ ssh\://username\:password@hostname[\:sshPort]/path = illegal url[{0}], correct example is ssh://username:password@hostname[:sshPort]/path

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupBase.java:467
# args: 
sync\ task\ failed. = sync task failed.

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupBase.java:474
# args: reply.getStatus()
unexpected\ task\ status\:\ %s = unexpected task status: {0}

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupBase.java:280
# args: msg.getDstBackupStorageUuid(),msg.getSrcBackupStorageUuid(),BackupStorageState.Disabled.toString()
One\ of\ the\ backup\ storage[uuids\:\ %s,\ %s]\ is\ in\ the\ state\ of\ %s,\ can\ not\ do\ sync\ operation = One of the backup storage[uuids: {0}, {1}] is in the state of {2}, can not do sync operation

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupBase.java:80
# args: self.getUuid()
database\ backup[uuid\:%s]\ is\ not\ Enabled\ and\ Ready = database backup[uuid:{0}] is not Enabled and Ready

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupBase.java:325
# args: msg.getDatabaseBackupUuid(),msg.getSrcBackupStorageUuid()
database\ backup[uuid\:%s]\ not\ found\ in\ backup\ storage[uuid\:%s] = database backup[uuid:{0}] not found in backup storage[uuid:{1}]

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupManagerImpl.java:90
# args: msg.getDatabaseBackupUuid()
database\ backup\ [uuid\:%s]\ is\ not\ existed\ yet = database backup [uuid:{0}] is not existed yet

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupManagerImpl.java:106
# args: 
backup\ storage[uuid\:%s]\ is\ not\ enabled\ and\ connected = backup storage[uuid:{0}] is not enabled and connected

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupManagerImpl.java:600
# args: result.getStderr()
not\ pass\ the\ restore\ security\ check\:\n%s = not pass the restore security check:\n{0}

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupManagerImpl.java:612
# args: 
cannot\ get\ free\ port\ to\ listen = cannot get free port to listen

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupManagerImpl.java:640
# args: version,dbf.getDbVersion()
database\ backup\ version[%s]\ is\ not\ match\ currently\ version[%s] = database backup version[{0}] is not match currently version[{1}]

# at: src/main/java/org/zstack/storage/backup/MultiDatabaseRecoverChecker.java:25
# args: 
cannot\ ssh\ peer\ node\ via\ sshkey,\ please\ check\ connection = cannot ssh peer node via sshkey, please check connection

# at: src/main/java/org/zstack/storage/backup/MultiDatabaseRecoverChecker.java:40
# args: result.getStderr()
cannot\ get\ zsha2\ status,\ because\ %s = cannot get zsha2 status, because {0}

# at: src/main/java/org/zstack/storage/backup/MultiDatabaseRecoverChecker.java:45
# args: result.getStderr()
cannot\ get\ zsha2\ config,\ because\ %s,\ maybe\ you\ need\ upgrade\ zsha2 = cannot get zsha2 config, because {0}, maybe you need upgrade zsha2

# at: src/main/java/org/zstack/storage/backup/SingleDatabaseRecoverChecker.java:19
# args: 
please\ stop\ other\ node\ first! = please stop other node first!

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:81
# args: currentState,msgName,checker.getStatesForOperation(msgName)
current\ backup\ storage\ state[%s]\ doesn't\ allow\ to\ proceed\ message[%s],\ allowed\ states\ are\ %s = current backup storage state[{0}] doesn't allow to proceed message[{1}], allowed states are {2}

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:212
# args: bsType,bsUuid
Unexpected\ backup\ storage[type\:%s,uuid\:%s] = Unexpected backup storage[type:{0},uuid:{1}]

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:233
# args: msg.getVolumeUuid()
Can\ not\ create\ volume\ backup\ for\ shareable\ volume[uuid\:%s] = Can not create volume backup for shareable volume[uuid:{0}]

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:237
# args: msg.getVolumeUuid()
Failed\ to\ create\ volume\ backup\ for\ volume[uuid\:%s],\ because\ it\ is\ not\ attached\ to\ any\ vm = Failed to create volume backup for volume[uuid:{0}], because it is not attached to any vm

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:246
# args: msg.getVolumeUuid(),VmInstanceState.Running.toString(),VmInstanceState.Paused.toString()
Failed\ to\ create\ volume\ backup\ for\ volume[uuid\:%s],\ because\ its\ attached\ volume\ is\ not\ in\ state[%s,\ %s] = Failed to create volume backup for volume[uuid:{0}], because its attached volume is not in state[{1}, {2}]

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:243
# args: msg.getVolumeUuid(),VmInstanceState.Running.toString(),VmInstanceState.Paused.toString()
Failed\ to\ create\ volume\ backup\ for\ volume[uuid\:%s],\ because\ the\ vm\ is\ not\ in\ state[%s,\ %s] = Failed to create volume backup for volume[uuid:{0}], because the vm is not in state[{1}, {2}]

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:255
# args: msg.getVolumeUuid()
Volume[uuid\:%s]\ is\ not\ root\ volume = Volume[uuid:{0}] is not root volume

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:262
# args: t.get(0),VmInstanceState.Running.toString(),VmInstanceState.Paused.toString()
Failed\ to\ create\ backups\ for\ VM[uuid\:%s],\ because\ it\ is\ not\ in\ state[%s,\ %s] = Failed to create backups for VM[uuid:{0}], because it is not in state[{1}, {2}]

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:276
# args: groupUuid
No\ volume\ backup\ found\ for\ group\ uuid\:\ %s = No volume backup found for group uuid: {0}

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:282
# args: groupUuid
root\ volume\ backup\ of\ group[uuid\:%s]\ not\ found = root volume backup of group[uuid:{0}] not found

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:312
# args: 
cannot\ specify\ primary\ storage\ which\ attached\ different\ cluster. = cannot specify primary storage which attached different cluster.

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:335
# args: backupUuid,state
volume\ backup[uuid\:%s]\ is\ in\ state\ %s,\ cannot\ revert\ volume\ to\ it = volume backup[uuid:{0}] is in state {1}, cannot revert volume to it

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:345
# args: backupUuid
original\ volume\ for\ backup[uuid\:%s]\ has\ been\ deleted,\ cannot\ revert\ volume\ to\ it = original volume for backup[uuid:{0}] has been deleted, cannot revert volume to it

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:349
# args: volUuid,backupUuid,expectVmUuid
original\ volume[uuid\:%s]\ for\ backup[uuid\:%s]\ is\ no\ longer\ attached\ to\ vm[uuid\:%s] = original volume[uuid:{0}] for backup[uuid:{1}] is no longer attached to vm[uuid:{2}]

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:359
# args: backupUuid
VM\ not\ found\ with\ volume\ backup[uuid\:%s] = VM not found with volume backup[uuid:{0}]

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:363
# args: vmState
VM\ is\ not\ in\ stopped\ state\:\ %s = VM is not in stopped state: {0}

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:380
# args: 
No\ available\ backup\ storage\ found = No available backup storage found

# at: src/main/java/org/zstack/storage/backup/VolumeBackupKvmBackend.java:181
# args: 
Operation\ not\ supported\ on\ shared\ volume = Operation not supported on shared volume

# at: src/main/java/org/zstack/storage/backup/VolumeBackupKvmBackend.java:186
# args: volumeVO.getUuid()
No\ VM\ found\ for\ volume[uuid\:%s] = No VM found for volume[uuid:{0}]

# at: src/main/java/org/zstack/storage/backup/VolumeBackupKvmBackend.java:435
# args: msg.getRootVolumeUuid()
No\ VM\ found\ with\ root\ volume\ uuid\:\ %s = No VM found with root volume uuid: {0}

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:2041
# args: cidr,fmtCidr
[%s]\ is\ not\ a\ standard\ cidr,\ do\ you\ mean\ [%s]? = [{0}] is not a standard cidr, do you mean [{1}]?

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:306
# args: vos.stream().filter( vo -> !succeedUuids.contains(vo.getUuid())).map(VolumeBackupVO::getUuid).collect(Collectors.toList())
failed\ to\ create\ image\ from\ backup\ %s = failed to create image from backup {0}

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:660
# args: msg.getImageStoreUuid(),e.getMessage()
sync\ volume\ backup\ metadata\ file\ in\ image\ store[uuid\:%s]\ meet\ I/O\ error\:\ %s = sync volume backup metadata file in image store[uuid:{0}] meet I/O error: {1}

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:697
# args: hypervisorType
No\ VolumeBackupFactory\ of\ type[%s]\ found = No VolumeBackupFactory of type[{0}] found

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:714
# args: msg.getBackupStorageUuid(),BackupStorageState.Disabled.toString()
One\ of\ the\ backup\ storage[uuid\:\ %s]\ is\ in\ the\ state\ of\ %s,\ can\ not\ do\ sync\ operation = One of the backup storage[uuid: {0}] is in the state of {1}, can not do sync operation

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:854
# args: struct.getBackupUuid(),struct.getBackupStorageUuid()
Volume\ backup[uuid\:%s]\ not\ found\ on\ backup\ storage[uuid\:%s] = Volume backup[uuid:{0}] not found on backup storage[uuid:{1}]

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:1298
# args: backupUuid,srcBackupStorageUuid
volume\ backup[uuid\:%s]\ not\ found\ in\ backup\ storage[uuid\:%s] = volume backup[uuid:{0}] not found in backup storage[uuid:{1}]

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:1506
# args: groupUuid
No\ volume\ backups\ found\ with\ group\ uuid\:\ %s = No volume backups found with group uuid: {0}

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:1513
# args: groupUuid
Root\ volume\ missing\ within\ group\ uuid\:\ %s = Root volume missing within group uuid: {0}

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:1519
# args: groupUuid
Multiple\ root\ volumes\ found\ within\ group\ uuid\:\ %s = Multiple root volumes found within group uuid: {0}

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:1531
# args: groupUuid
No\ permission\ to\ volume\ backups\ within\ group\ uuid\:\ %s = No permission to volume backups within group uuid: {0}

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:1669
# args: vo.getUuid()
Volume\ backup[uuid\:%s]\ not\ found\ on\ any\ backup\ storage = Volume backup[uuid:{0}] not found on any backup storage

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:2068
# args: degree
degree\ [%s]\ should\ be\ a\ positive\ number = degree [{0}] should be a positive number

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:2102
# args: type
invalid\ type[%s],\ should\ be\ [nfs] = invalid type[{0}], should be [nfs]

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:2108
# args: url
invalid\ url[%s],\ should\ be\ hostname\:/path = invalid url[{0}], should be hostname:/path

# at: src/main/java/org/zstack/storage/backup/VolumeBackupMetadataMaker.java:181
# args: inv.getUuid(),e.getMessage()
generate\ volume\ backup\ metadata\ file\ on\ image\ store[uuid\:%s]\ failure,\ because\ IO\ error\:\ %s = generate volume backup metadata file on image store[uuid:{0}] failure, because IO error: {1}

# at: src/main/java/org/zstack/storage/backup/VolumeBackupMetadataMaker.java:508
# args: rsp.getError()
volume\ backup\ metadata\ operation\ failure,\ because\ %s = volume backup metadata operation failure, because {0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:271
# args: url,rsp.getError()
unable\ to\ connect\ to\ SimpleHttpBackupStorage[url\:%s],\ because\ %s = unable to connect to SimpleHttpBackupStorage[url:{0}], because {1}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:493
# args: iinv.getName()
Missing\ cert\ file\ for\ downloading\ image\:\ %s = Missing cert file for downloading image: {0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:622
# args: 
image\ store\ service\ is\ temporary\ not\ available,\ because\ it\ is\ reclaiming\ space\ now = image store service is temporary not available, because it is reclaiming space now

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:798
# args: 
No\ response = No response

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:871
# args: ret.getError()
reclaim\ imagestore\ error,\ because\:%s = reclaim imagestore error, because:{0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:958
# args: self.getUuid(),ret.getError()
failed\ to\ set\ max\ capacity\ on\ image\ store[uuid\:%s],\ because\:\ %s = failed to set max capacity on image store[uuid:{0}], because: {1}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:1085
# args: msg.getImageUuid(),self.getUuid()
image[%s]\ not\ found\ on\ backup\ storage[%s] = image[{0}] not found on backup storage[{1}]

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:1235
# args: 
image\ store\ [%s]\ cannot\ add\ image,\ because\ it\ is\ used\ for\ backup\ remote = image store [{0}] cannot add image, because it is used for backup remote

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:1435
# args: 
commercial\ license\ is\ required\ to\ use\ ImageStore = commercial license is required to use ImageStore

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:1468
# args: self.getUuid(),ret.getUuid()
the\ uuid\ of\ imagestoreBackupStorage\ agent\ changed[expected\:%s,\ actual\:%s],\ it's\ most\ likely\ the\ agent\ was\ manually\ restarted.\ Issue\ a\ reconnect\ to\ sync\ the\ status = the uuid of imagestoreBackupStorage agent changed[expected:{0}, actual:{1}], it's most likely the agent was manually restarted. Issue a reconnect to sync the status

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:125
# args: msg.getHostname()
hostname[%s]\ is\ neither\ an\ IPv4\ address\ nor\ a\ valid\ hostname = hostname[{0}] is neither an IPv4 address nor a valid hostname

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:60
# args: bsUuid,imageUuid
target\ backup\ storage[uuid\:%s]\ already\ contains\ the\ image\ [uuid\:%s] = target backup storage[uuid:{0}] already contains the image [uuid:{1}]

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:79
# args: msg.getSrcBackupStorageUuid(),msg.getUuid()
source\ backup\ storage[%s]\ doesn't\ contain\ image[%s] = source backup storage[{0}] doesn't contain image[{1}]

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:94
# args: msg.getSrcBackupStorageUuid(),msg.getUuid()
src\ backupstorage[%s]\ doesn't\ contain\ image[%s] = src backupstorage[{0}] doesn't contain image[{1}]

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:142
# args: msg.getHostname()
duplicate\ backup\ storage.\ There\ has\ been\ an\ image\ store\ backup\ storage[hostname\:%s] = duplicate backup storage. There has been an image store backup storage[hostname:{0}]

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:147
# args: 
file\ path\ needed = file path needed

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:151
# args: dir
absolute\ file\ path\ required\:\ %s = absolute file path required: {0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:154
# args: 
the\ url\ contains\ an\ invalid\ folder[/dev\ or\ /proc\ or\ /sys] = the url contains an invalid folder[/dev or /proc or /sys]

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:162
# args: dir
file\ path\ contains\ invalid\ character\:\ %s = file path contains invalid character: {0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageExtension.java:188
# args: ps.getUuid()
cannot\ find\ a\ connected\ host\ in\ cluster\ to\ which\ PS\ [uuid\:\ %s]\ attached = cannot find a connected host in cluster to which PS [uuid: {0}] attached

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageFactory.java:142
# args: amsg.getUrl()
invalid\ url[%s],\ the\ url\ must\ be\ an\ absolute\ path\ starting\ with\ '/' = invalid url[{0}], the url must be an absolute path starting with '/'

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageFactory.java:151
# args: hostname
existing\ SimpleHttpBackupStorage\ with\ hostname[%s]\ found = existing SimpleHttpBackupStorage with hostname[{0}] found

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageFactory.java:100
# args: result.getStderr()
ansible\ mkdir\ failed,\ due\ to\:\ %s = ansible mkdir failed, due to: {0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageFactory.java:112
# args: result.getStderr()
ansible\ failed,\ due\ to\:\ %s = ansible failed, due to: {0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageFactory.java:110
# args: result.getStdout()
ansible\ attach\ nas\ failed,\ due\ to\:\ %s = ansible attach nas failed, due to: {0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageManagerImpl.java:395
# args: tmpHostFile,result.getStderr()
create\ tmp\ file\ [%s]\ failed,\ due\ to\:\ %s = create tmp file [{0}] failed, due to: {1}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageManagerImpl.java:229
# args: 
sync\ status\ failed. = sync status failed.

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageMetaDataMaker.java:806
# args: rsp.getError()
delete\ image\ metadata\ file\ failed\:\ %s = delete image metadata file failed: {0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageMetaDataMaker.java:389
# args: bsUuid
AddImage\ is\ forbidden\ in\ Disaster\ BS\:\ [%s] = AddImage is forbidden in Disaster BS: [{0}]

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageMetaDataMaker.java:735
# args: rsp.getBackupStorageMetaFileName()
Check\ image\ metadata\ file\:\ %s\ failed = Check image metadata file: {0} failed

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageMetaDataMaker.java:563
# args: rsp.getBackupStorageMetaFileName()
Create\ image\ metadata\ file\ \:\ %s\ failed = Create image metadata file : {0} failed

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageMetaDataMaker.java:538
# args: rsp.getBackupStorageMetaFileName()
Create\ image\ metadata\ file\ sync\ \:\ %s\ failed = Create image metadata file sync : {0} failed

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreImageStruct.java:79
# args: e.getMessage()
parse\ create\ time\ error\:\ %s = parse create time error: {0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ReclaimSpaceFromImageStoreLongJob.java:62
# args: 
Cancel\ operation\ is\ not\ supported = Cancel operation is not supported

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorage.java:105
# args: scheme,url
SftpBackupStorage\ doesn't\ support\ scheme[%s]\ in\ url[%s] = SftpBackupStorage doesn't support scheme[{0}] in url[{1}]

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorage.java:133
# args: ret.getError()
fail\ to\ download\ image,\ because\ %s = fail to download image, because {0}

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorage.java:233
# args: rsp.getError()
fail\ to\ cancel\ download\ image,\ because\ %s = fail to cancel download image, because {0}

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorage.java:307
# args: self.getUuid(),ret.getUuid()
the\ uuid\ of\ sftpBackupStorage\ agent\ changed[expected\:%s,\ actual\:%s],\ it's\ most\ likely\ the\ agent\ was\ manually\ restarted.\ Issue\ a\ reconnect\ to\ sync\ the\ status = the uuid of sftpBackupStorage agent changed[expected:{0}, actual:{1}], it's most likely the agent was manually restarted. Issue a reconnect to sync the status

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorageApiInterceptor.java:70
# args: bsUuid
Please\ stop\ the\ vm\ before\ create\ volume\ template\ to\ sftp\ backup\ storage\ %s = Please stop the vm before create volume template to sftp backup storage {0}

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorageApiInterceptor.java:106
# args: msg.getHostname()
duplicate\ backup\ storage.\ There\ has\ been\ a\ sftp\ backup\ storage[hostname\:%s]\ existing = duplicate backup storage. There has been a sftp backup storage[hostname:{0}] existing

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorageMetaDataMaker.java:543
# args: rsp.getBackupStorageMetaFileName()
check\ image\ metadata\ file\:\ %s\ failed = check image metadata file: {0} failed

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorageMetaDataMaker.java:392
# args: rsp.getBackupStorageMetaFileName()
create\ image\ metadata\ file\ \:\ %s\ failed = create image metadata file : {0} failed

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorageMetaDataMaker.java:548
# args: rsp.getBackupStorageMetaFileName()
image\ metadata\ file\:\ %s\ is\ not\ exist = image metadata file: {0} is not exist

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:77
# args: msg.getPoolName()
operation\ failure,\ because\ the\ poolName[poolName\:%s]\ can\ not\ include\ unprintable\ ascii\ characters. = operation failure, because the poolName[poolName:{0}] can not include unprintable ascii characters.

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:91
# args: duplicatePoolUuid
Ceph\ pool[uuid\:%s]\ with\ this\ name\ is\ already\ added\ into\ ZStack\ and\ used\ elsewhere,\ cannot\ reuse\ the\ ceph\ pool. = Ceph pool[uuid:{0}] with this name is already added into ZStack and used elsewhere, cannot reuse the ceph pool.

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:86
# args: msg.getPoolName(),duplicatePoolUuid
creation\ failure,\ duplicate\ poolName[%s].\ There\ has\ been\ a\ pool[uuid\:%s]\ with\ the\ same\ name\ existing. = creation failure, duplicate poolName[{0}]. There has been a pool[uuid:{1}] with the same name existing.

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:119
# args: existing
cannot\ add\ ceph\ primary\ storage,\ there\ has\ been\ some\ ceph\ primary\ storage\ using\ mon[hostnames\:%s] = cannot add ceph primary storage, there has been some ceph primary storage using mon[hostnames:{0}]

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:130
# args: uri.getHostname()
Cannot\ add\ same\ host[%s]\ in\ mons = Cannot add same host[{0}] in mons

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:156
# args: 
Adding\ the\ same\ Mon\ node\ is\ not\ allowed = Adding the same Mon node is not allowed

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:235
# args: existing
cannot\ add\ ceph\ backup\ storage,\ there\ has\ been\ some\ ceph\ backup\ storage\ using\ mon[hostnames\:%s] = cannot add ceph backup storage, there has been some ceph backup storage using mon[hostnames:{0}]

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:243
# args: 
poolName\ is\ required\ when\ importImages\ is\ true = poolName is required when importImages is true

# at: src/main/java/org/zstack/storage/ceph/CephMonBase.java:66
# args: 
The\ problem\ may\ be\ caused\ by\ an\ incorrect\ user\ name\ or\ password\ or\ SSH\ port\ or\ unstable\ network\ environment = The problem may be caused by an incorrect user name or password or SSH port or unstable network environment

# at: src/main/java/org/zstack/storage/ceph/backup/CephBackupStorageBase.java:834
# args: msg.getHostname(),msg.getBackupStorageUuid()
CephMon[hostname\:%s]\ not\ found\ on\ backup\ storage[uuid\:%s] = CephMon[hostname:{0}] not found on backup storage[uuid:{1}]

# at: src/main/java/org/zstack/storage/ceph/backup/CephBackupStorageBase.java:1218
# args: self.getUuid()
unable\ to\ connect\ to\ the\ ceph\ backup\ storage[uuid\:%s],\ failed\ to\ connect\ all\ ceph\ monitors. = unable to connect to the ceph backup storage[uuid:{0}], failed to connect all ceph monitors.

# at: src/main/java/org/zstack/storage/ceph/backup/CephBackupStorageBase.java:1339
# args: otherCeph.getName(),otherCeph.getUuid(),fsId
there\ is\ another\ CEPH\ backup\ storage[name\:%s,\ uuid\:%s]\ with\ the\ same\ FSID[%s],\ you\ cannot\ add\ the\ same\ CEPH\ setup\ as\ two\ different\ backup\ storage = there is another CEPH backup storage[name:{0}, uuid:{1}] with the same FSID[{2}], you cannot add the same CEPH setup as two different backup storage

# at: src/main/java/org/zstack/storage/ceph/backup/CephBackupStorageMonBase.java:92
# args: uuid
cannot\ update\ status\ of\ the\ ceph\ backup\ storage\ mon[uuid\:%s],\ it\ has\ been\ deleted.This\ error\ can\ be\ ignored = cannot update status of the ceph backup storage mon[uuid:{0}], it has been deleted.This error can be ignored

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:1283
# args: backupStorage.getUuid(),backupStorage.getName(),bsFsid,self.getUuid(),self.getName(),getSelf().getFsid()
the\ backup\ storage[uuid\:%s,\ name\:%s,\ fsid\:%s]\ is\ not\ in\ the\ same\ ceph\ cluster\ with\ the\ primary\ storage[uuid\:%s,\ name\:%s,\ fsid\:%s] = the backup storage[uuid:{0}, name:{1}, fsid:{2}] is not in the same ceph cluster with the primary storage[uuid:{3}, name:{4}, fsid:{5}]

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:1477
# args: poolName
cannot\ find\ cephPrimaryStorage\ pool[poolName\=%s] = cannot find cephPrimaryStorage pool[poolName={0}]

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:1483
# args: poolName
cephPrimaryStorage\ pool[poolName\=%s]\ available\ capacity\ not\ enough = cephPrimaryStorage pool[poolName={0}] available capacity not enough

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2303
# args: psUuid,bsUuid
fsid\ is\ not\ same\ between\ ps[%s]\ and\ bs[%s],\ create\ template\ is\ forbidden. = fsid is not same between ps[{0}] and bs[{1}], create template is forbidden.

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2762
# args: self.getUuid()
ceph\ primary\ storage[uuid\:%s]\ may\ have\ been\ deleted. = ceph primary storage[uuid:{0}] may have been deleted.

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2746
# args: self.getUuid()
unable\ to\ connect\ to\ the\ ceph\ primary\ storage[uuid\:%s],\ failed\ to\ connect\ all\ ceph\ monitors. = unable to connect to the ceph primary storage[uuid:{0}], failed to connect all ceph monitors.

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2866
# args: 
the\ fsid\ returned\ by\ mons\ are\ mismatching,\ it\ seems\ the\ mons\ belong\ to\ different\ ceph\ clusters\:\n = the fsid returned by mons are mismatching, it seems the mons belong to different ceph clusters:\n

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2884
# args: otherCeph.getName(),otherCeph.getUuid(),fsId
there\ is\ another\ CEPH\ primary\ storage[name\:%s,\ uuid\:%s]\ with\ the\ same\ FSID[%s],\ you\ cannot\ add\ the\ same\ CEPH\ setup\ as\ two\ different\ primary\ storage = there is another CEPH primary storage[name:{0}, uuid:{1}] with the same FSID[{2}], you cannot add the same CEPH setup as two different primary storage

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:3135
# args: self.getUuid(),self.getName(),mon.getSelf().getUuid(),res.error
the\ ceph\ primary\ storage[uuid\:%s,\ name\:%s]\ is\ down,\ as\ one\ mon[uuid\:%s]\ reports\ an\ operation\ failure[%s] = the ceph primary storage[uuid:{0}, name:{1}] is down, as one mon[uuid:{2}] reports an operation failure[{3}]

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:3736
# args: bsType
unable\ to\ upload\ bits\ to\ the\ backup\ storage[type\:%s],\ we\ only\ support\ CEPH = unable to upload bits to the backup storage[type:{0}], we only support CEPH

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:3910
# args: volume.getUuid(),volume.getRootImageUuid()
cannot\ reinit\ rootvolume\ [%s]\ because\ image\ [%s]\ has\ been\ deleted\ and\ imagecache\ cannot\ be\ found = cannot reinit rootvolume [{0}] because image [{1}] has been deleted and imagecache cannot be found

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:3929
# args: volume.getRootImageUuid(),getSelf().getUuid()
cannot\ find\ backupstorage\ to\ download\ image\ [%s]\ to\ primarystorage\ [%s] = cannot find backupstorage to download image [{0}] to primarystorage [{1}]

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageFactory.java:457
# args: vol.getPrimaryStorageUuid()
cannot\ find\ any\ Connected\ ceph\ mon\ for\ the\ primary\ storage[uuid\:%s] = cannot find any Connected ceph mon for the primary storage[uuid:{0}]

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageFactory.java:758
# args: 
not\ support\ take\ volumes\ snapshots\ on\ multiple\ ps\ when\ including\ ceph = not support take volumes snapshots on multiple ps when including ceph

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageFactory.java:853
# args: targetCephPoolName,cephPoolName
ceph\ pool\ conflict,\ the\ ceph\ pool\ specified\ by\ the\ instance\ offering\ is\ %s,\ and\ the\ ceph\ pool\ specified\ in\ the\ creation\ parameter\ is\ %s = ceph pool conflict, the ceph pool specified by the instance offering is {0}, and the ceph pool specified in the creation parameter is {1}

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageFactory.java:984
# args: targetCephPoolName,cephPoolName
ceph\ pool\ conflict,\ the\ ceph\ pool\ specified\ by\ the\ disk\ offering\ is\ %s,\ and\ the\ ceph\ pool\ specified\ in\ the\ creation\ parameter\ is\ %s = ceph pool conflict, the ceph pool specified by the disk offering is {0}, and the ceph pool specified in the creation parameter is {1}

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageFactory.java:1203
# args: rootVolume.getInstallPath(),reply.getError().getDetails()
get\ rootVolume[%s]\ rbd\ image\ watchers\ fail,\ %s = get rootVolume[{0}] rbd image watchers fail, {1}

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageFactory.java:1219
# args: msg.getVolumeUuid(),installPath
rootVolume[%s]\ is\ already\ in\ use(ceph\ rbd\ image[%s]\ already\ has\ watchers),\ in\ order\ to\ prevent\ brain\ splitting,\ Starting\ VM\ is\ prohibited. = rootVolume[{0}] is already in use(ceph rbd image[{1}] already has watchers), in order to prevent brain splitting, Starting VM is prohibited.

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageMonBase.java:92
# args: uuid
cannot\ update\ status\ of\ the\ ceph\ primary\ storage\ mon[uuid\:%s],\ it\ has\ been\ deleted.This\ error\ can\ be\ ignored = cannot update status of the ceph primary storage mon[uuid:{0}], it has been deleted.This error can be ignored

# at: src/main/java/org/zstack/storage/device/ScsiLunAllocatorFactory.java:54
# args: firstScsiLunVO.getUuid(),scsiLunVO.getUuid()
scsi\ lun[uuid\:\ %s]\ and\ [uuid\:\ %s]\ does\ not\ has\ a\ common\ host = scsi lun[uuid: {0}] and [uuid: {1}] does not has a common host

# at: src/main/java/org/zstack/storage/device/ScsiLunAllocatorFactory.java:59
# args: scsiLunVO.getUuid()
scsi\ lun[uuid\:\ %s]\ is\ in\ disabled\ state = scsi lun[uuid: {0}] is in disabled state

# at: src/main/java/org/zstack/storage/device/StorageDeviceApiInterceptor.java:62
# args: msg.getIp(),msg.getPort()
iSCSI\ server[ip\:\ %s,\ port\:\ %s]\ already\ exists = iSCSI server[ip: {0}, port: {1}] already exists

# at: src/main/java/org/zstack/storage/device/StorageDeviceApiInterceptor.java:67
# args: msg.getIp()
iSCSI\ server\ ip\:\ %s\ is\ not\ valid = iSCSI server ip: {0} is not valid

# at: src/main/java/org/zstack/storage/device/StorageDeviceApiInterceptor.java:76
# args: msg.getUuid(),msg.getClusterUuid()
iSCSI\ server[uuid\:\ %s]\ already\ attached\ to\ cluster[uuid\:\ %s] = iSCSI server[uuid: {0}] already attached to cluster[uuid: {1}]

# at: src/main/java/org/zstack/storage/device/StorageDeviceApiInterceptor.java:86
# args: msg.getUuid(),msg.getClusterUuid()
iSCSI\ server[uuid\:\ %s]\ not\ attached\ to\ cluster[uuid\:\ %s] = iSCSI server[uuid: {0}] not attached to cluster[uuid: {1}]

# at: src/main/java/org/zstack/storage/device/StorageDeviceApiInterceptor.java:97
# args: msg.getUuid(),clusterUuid
iSCSI\ server[uuid\:\ %s]\ still\ attached\ to\ cluster[uuid\:\ %s] = iSCSI server[uuid: {0}] still attached to cluster[uuid: {1}]

# at: src/main/java/org/zstack/storage/device/StorageDeviceApiInterceptor.java:126
# args: scsiLunVO.getWwid(),refVO.getVmInstanceUuid()
scsi\ lun[wwid\:\ %s]\ has\ been\ attached\ to\ vm\ instance\ %s = scsi lun[wwid: {0}] has been attached to vm instance {1}

# at: src/main/java/org/zstack/storage/device/StorageDeviceManagerImpl.java:1188
# args: msg.getUuid(),vmInstanceVO.getState(),allowedVmOperationStates
vm\ instance[%s]\ state\ [%s]\ not\ in\ allowed\ state[%s]\ for\ operation = vm instance[{0}] state [{1}] not in allowed state[{2}] for operation

# at: src/main/java/org/zstack/storage/device/StorageDeviceManagerImpl.java:1197
# args: msg.getUuid(),vmInstanceVO.getHostUuid(),msg.getUuid()
vm\ instance[uuid\:\ %s]\ host[uuid\:\ %s]\ not\ attached\ scsi\ lun[uuid\:\ %s] = vm instance[uuid: {0}] host[uuid: {1}] not attached scsi lun[uuid: {2}]

# at: src/main/java/org/zstack/storage/device/StorageDeviceManagerImpl.java:1256
# args: msg.getVmInstanceUuid(),vmInstanceVO.getState(),allowedVmOperationStates
vm\ instance[%s]\ state[%s]\ not\ in\ allowed\ state[%s]\ for\ operation = vm instance[{0}] state[{1}] not in allowed state[{2}] for operation

# at: src/main/java/org/zstack/storage/device/StorageDeviceManagerImpl.java:1265
# args: msg.getVmInstanceUuid(),hostVO.getUuid(),msg.getUuid()
vm\ instance[%s]\ host[uuid\:\ %s]\ not\ attached\ scsi\ lun[uuid\:\ %s] = vm instance[{0}] host[uuid: {1}] not attached scsi lun[uuid: {2}]

# at: src/main/java/org/zstack/storage/device/StorageDeviceManagerImpl.java:1447
# args: scannedServer.getKey(),JSONObjectUtil.toJsonString(scannedTargets),hostVO.getUuid(),JSONObjectUtil.toJsonString(returnValue.getIscsiTargets())
different\ iscsi\ configuration\ were\ found\ on\ host[uuid\:%s,\ targets\:%s]and\ host[uuid\:%s,\ targets\:%s] = different iscsi configuration were found on host[uuid:{0}, targets:{1}]and host[uuid:{2}, targets:{3}]

# at: src/main/java/org/zstack/storage/device/StorageDeviceManagerImpl.java:2055
# args: refVO.getScsiLunUuid()
specified\ scsi\ lun[wwid\:\ %s]\ not\ exists\ or\ disabled = specified scsi lun[wwid: {0}] not exists or disabled

# at: src/main/java/org/zstack/storage/migration/KvmStorageLiveMigrationFlowChain.java:256
# args: 
No\ host\ available\ for\ block\ live\ migration = No host available for block live migration

# at: src/main/java/org/zstack/storage/migration/KvmStorageLiveMigrationFlowChain.java:494
# args: rsp.getError()
live\ block\ migration\ failed\:\ %s = live block migration failed: {0}

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:123
# args: 
do\ not\ support\ storage\ migration\ with\ iso\ in\ ceph\ backup\ storage\ attached = do not support storage migration with iso in ceph backup storage attached

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:292
# args: srcVm.getUuid(),srcVm.getName()
do\ not\ support\ storage\ migration\ of\ vm[uuid\:%s,\ name\:\ %s]\ while\ shared\ volume\ attached = do not support storage migration of vm[uuid:{0}, name: {1}] while shared volume attached

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:175
# args: srcPsType,dstPsType
do\ not\ support\ storage\ migration\ from\ [%s]\ to\ [%s]\ with\ data\ volume = do not support storage migration from [{0}] to [{1}] with data volume

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:180
# args: srcPsType,dstPsType
do\ not\ support\ storage\ migration\ from\ [%s]\ to\ [%s]\ with\ snapshot = do not support storage migration from [{0}] to [{1}] with snapshot

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:188
# args: primaryStorageVO.getType(),dstPrimaryStorageVO.getType()
do\ not\ support\ storage\ migration\ from\ [%s]\ to\ [%s] = do not support storage migration from [{0}] to [{1}]

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:194
# args: vmInstanceVO.getUuid()
VM[uuid\:%s]\ is\ running\ but\ host\ uuid\ is\ missing = VM[uuid:{0}] is running but host uuid is missing

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:205
# args: 
Source\ BS\ and\ Destination\ BS\ cannot\ be\ the\ same. = Source BS and Destination BS cannot be the same.

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:213
# args: 
Source\ BS\ and\ Destination\ BS\ must\ not\ be\ Disabled. = Source BS and Destination BS must not be Disabled.

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:220
# args: msg.getImageUuid()
Image[uuid\:%s]\ is\ not\ in\ status\ Ready,\ cannot\ migrate\ it. = Image[uuid:{0}] is not in status Ready, cannot migrate it.

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:231
# args: msg.getImageUuid(),msg.getSrcBackupStorageUuid()
Image[uuid\:%s]\ is\ not\ in\ source\ backup\ storage[uuid\:%s] = Image[uuid:{0}] is not in source backup storage[uuid:{1}]

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:240
# args: srcBS.getType(),dstBS.getType()
Cannot\ migrate\ image\ from\ %s\ to\ %s. = Cannot migrate image from {0} to {1}.

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:260
# args: 
Source\ PS\ and\ Destination\ PS\ must\ not\ be\ Disabled\ or\ Maintenance\ state. = Source PS and Destination PS must not be Disabled or Maintenance state.

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:267
# args: msg.getVolumeUuid(),msg.getDstPrimaryStorageUuid()
Volume[uuid\:%s]\ is\ already\ in\ PS[uuid\:%s],\ cannot\ migrate. = Volume[uuid:{0}] is already in PS[uuid:{1}], cannot migrate.

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:274
# args: msg.getVolumeUuid()
Volume[uuid\:%s]\ is\ not\ in\ status\ Ready,\ cannot\ migrate\ it. = Volume[uuid:{0}] is not in status Ready, cannot migrate it.

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:330
# args: msg.getVolumeUuid(),srcVolume.getVmInstanceUuid()
the\ volume[uuid\:%s]\ is\ still\ attached\ on\ vm[uuid\:%s],\ please\ detach\ it\ before\ migration. = the volume[uuid:{0}] is still attached on vm[uuid:{1}], please detach it before migration.

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:338
# args: srcVolume.getUuid(),srcVolume.getName()
do\ not\ support\ storage\ migration\ while\ shared\ volume[uuid\:\ %s,\ name\:\ %s]\ attached = do not support storage migration while shared volume[uuid: {0}, name: {1}] attached

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:287
# args: 
Cannot\ migrate\ root\ volume\ when\ vm\ instance\ is\ not\ stopped. = Cannot migrate root volume when vm instance is not stopped.

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:304
# args: 
Cannot\ migrate\ root\ volume\ when\ there\ are\ data\ volumes\ attached\ to\ the\ vm\ instance. = Cannot migrate root volume when there are data volumes attached to the vm instance.

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:323
# args: 
The\ destination\ primary\ storage\ is\ not\ attached\ to\ any\ cluster\ that\ has\ the\ same\ L2\ networks\ as\ source\ cluster. = The destination primary storage is not attached to any cluster that has the same L2 networks as source cluster.

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:348
# args: srcPS.getType(),dstPS.getType()
Cannot\ migrate\ volume\ from\ %s\ to\ %s. = Cannot migrate volume from {0} to {1}.

# at: src/main/java/org/zstack/storage/migration/StorageMigrationBase.java:531
# args: vmInstanceVO.getState()
not\ support\ vm\ state[%s]\ to\ do\ storage\ migration = not support vm state[{0}] to do storage migration

# at: src/main/java/org/zstack/storage/migration/StorageMigrationBase.java:472
# args: msg.getVmInstanceUuid(),size,dstPrimaryStorageVO.getCapacity().getAvailablePhysicalCapacity()
there\ are\ not\ enough\ capacity\ for\ vm[uuid\:\ %s]\ storage\ migration,\ required\ capacity(include\ image\ cache)\:\ %s,\ current\ available\ physical\ capacity\:\ %s = there are not enough capacity for vm[uuid: {0}] storage migration, required capacity(include image cache): {1}, current available physical capacity: {2}

# at: src/main/java/org/zstack/storage/migration/StorageMigrationBase.java:582
# args: msg.getVmInstanceUuid()
VM[uuid\:\ %s]\ not\ found = VM[uuid: {0}] not found

# at: src/main/java/org/zstack/storage/migration/StorageMigrationBase.java:815
# args: srcPs.getType()
unsupported\ primary\ storage\ type[%s]\ for\ storage\ migration = unsupported primary storage type[{0}] for storage migration

# at: src/main/java/org/zstack/storage/migration/StorageMigrationBase.java:1001
# args: msg.getType()
not\ support\ to\ cancel\ %s = not support to cancel {0}

# at: src/main/java/org/zstack/storage/migration/backup/ReserveCapacityFromDstBSFlow.java:61
# args: imageUuid,dstBsUuid
Cannot\ reserve\ enough\ space\ for\ Image[uuid\:%s]\ in\ BS[uuid\:%s] = Cannot reserve enough space for Image[uuid:{0}] in BS[uuid:{1}]

# at: src/main/java/org/zstack/storage/migration/backup/ceph/CephToCephMigrateImageFlow.java:114
# args: dstBsVO.getUuid()
all\ ceph\ mons\ are\ Disconnected\ in\ ceph\ backup\ storage[uuid\:%s] = all ceph mons are Disconnected in ceph backup storage[uuid:{0}]

# at: src/main/java/org/zstack/storage/migration/backup/ceph/CephToCephMigrateImageFlow.java:187
# args: imageUuid,srcBsUuid,dstBsUuid,errCode.getDetails()
Failed\ to\ migrate\ Image\ %s\ from\ BS\ %s\ to\ BS\ %s.\ cause\:\ %s = Failed to migrate Image {0} from BS {1} to BS {2}. cause: {3}

# at: src/main/java/org/zstack/storage/migration/backup/ceph/CephToCephMigrateImageFlow.java:143
# args: reply1.getTrashId(),dstBsUuid,dstImageInstallPath,reply1.getResourceUuid()
found\ trashId(%s)\ in\ BackupStorage\ [%s]\ for\ the\ migrate\ installPath[%s].\ Please\ clean\ it\ first\ by\ 'APICleanUpTrashOnBackupStorageMsg'\ if\ you\ insist\ to\ migrate\ the\ image[%s] = found trashId({0}) in BackupStorage [{1}] for the migrate installPath[{2}]. Please clean it first by 'APICleanUpTrashOnBackupStorageMsg' if you insist to migrate the image[{3}]

# at: src/main/java/org/zstack/storage/migration/primary/ReserveCapacityFromDstPSFlow.java:85
# args: volumeUuid,dstPsUuid
Cannot\ reserve\ enough\ space\ for\ Volume[uuid\:%s]\ in\ PS[uuid\:%s] = Cannot reserve enough space for Volume[uuid:{0}] in PS[uuid:{1}]

# at: src/main/java/org/zstack/storage/migration/primary/ceph/CephToCephMigrateVolumeFlow.java:120
# args: dstPsVO.getUuid()
all\ ceph\ mons\ are\ Disconnected\ in\ ceph\ primary\ storage[uuid\:%s] = all ceph mons are Disconnected in ceph primary storage[uuid:{0}]

# at: src/main/java/org/zstack/storage/migration/primary/ceph/CephToCephMigrateVolumeFlow.java:571
# args: volume.getType()
The\ type\ [%s]\ of\ volume\ is\ invalid. = The type [{0}] of volume is invalid.

# at: src/main/java/org/zstack/storage/migration/primary/nfs/NfsToNfsMigrateVolumeFlow.java:88
# args: 
cannot\ find\ any\ connected\ host\ to\ perform\ the\ storage\ migration\ operation = cannot find any connected host to perform the storage migration operation

# at: src/main/java/org/zstack/storage/migration/primary/nfs/NfsToNfsMigrateVolumeFlow.java:187
# args: imageUuid
both\ image\ %s\ and\ its\ cache\ is\ missing = both image {0} and its cache is missing

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:189
# args: 
'resourceUuid'\ and\ 'resourceType'\ must\ be\ set\ both\ or\ neither! = 'resourceUuid' and 'resourceType' must be set both or neither!

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:85
# args: 
zoneUuids,\ clusterUuids,\ primaryStorageUuids\ must\ have\ at\ least\ one\ be\ none-empty\ list,\ or\ all\ is\ set\ to\ true = zoneUuids, clusterUuids, primaryStorageUuids must have at least one be none-empty list, or all is set to true

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:107
# args: msg.getPrimaryStorageUuid(),msg.getClusterUuid()
primary\ storage[uuid\:%s]\ has\ not\ been\ attached\ to\ cluster[uuid\:%s]\ yet = primary storage[uuid:{0}] has not been attached to cluster[uuid:{1}] yet

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:124
# args: msg.getPrimaryStorageUuid(),msg.getClusterUuid()
primary\ storage[uuid\:%s]\ has\ been\ attached\ to\ cluster[uuid\:%s] = primary storage[uuid:{0}] has been attached to cluster[uuid:{1}]

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:139
# args: msg.getPrimaryStorageUuid(),msg.getClusterUuid()
primary\ storage[uuid\:%s]\ and\ cluster[uuid\:%s]\ are\ not\ in\ the\ same\ zone = primary storage[uuid:{0}] and cluster[uuid:{1}] are not in the same zone

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:161
# args: url
url[%s]\ has\ been\ occupied,\ it\ cannot\ be\ duplicate\ in\ same\ cluster = url[{0}] has been occupied, it cannot be duplicate in same cluster

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:181
# args: msg.getPrimaryStorageUuid(),clusterUuidsString
primary\ storage[uuid\:%s]\ cannot\ be\ deleted\ for\ still\ being\ attached\ to\ cluster[uuid\:%s]. = primary storage[uuid:{0}] cannot be deleted for still being attached to cluster[uuid:{1}].

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:206
# args: psUuids
primary\ storage(s)\ [uuid\:\ %s]\ where\ volume(s)\ locate\ is\ not\ Enabled\ or\ Connected = primary storage(s) [uuid: {0}] where volume(s) locate is not Enabled or Connected

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageAvoidAllocatorFlow.java:50
# args: spec.getAvoidPrimaryStorageUuids()
after\ removing\ primary\ storage%s\ to\ avoid,\ there\ is\ no\ candidate\ primary\ storage\ anymore.\ please\ check\ primary\ storage\ status\ and\ state\ in\ the\ cluster. = after removing primary storage{0} to avoid, there is no candidate primary storage anymore. please check primary storage status and state in the cluster.

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageBase.java:221
# args: self.getUuid()
cannot\ attach\ ISO\ to\ a\ primary\ storage[uuid\:%s]\ which\ is\ disabled = cannot attach ISO to a primary storage[uuid:{0}] which is disabled

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageBase.java:657
# args: bsUuid,self.getZoneUuid(),self.getUuid()
backup\ storage[uuid\:%s]\ is\ not\ attached\ to\ zone[uuid\:%s]\ the\ primary\ storage[uuid\:%s]\ belongs\ to = backup storage[uuid:{0}] is not attached to zone[uuid:{1}] the primary storage[uuid:{2}] belongs to

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageBase.java:781
# args: 
operation\ not\ supported = operation not supported

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageBase.java:1558
# args: volumeUuid
cannot\ attach\ volume[uuid\:%s]\ whose\ primary\ storage\ is\ Maintenance = cannot attach volume[uuid:{0}] whose primary storage is Maintenance

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageCapacityUpdater.java:283
# args: size,capacityVO.getUuid()
cannot\ reserve\ %s\ bytes\ on\ the\ primary\ storage[uuid\:%s],\ it's\ short\ of\ available\ capacity = cannot reserve {0} bytes on the primary storage[uuid:{1}], it's short of available capacity

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageDeleteBitGC.java:45
# args: ps.getUuid(),ps.getStatus().toString()
the\ primary\ storage[uuid\:%s]\ is\ not\ in\ status\ of\ Connected,\ current\ status\ is\ %s = the primary storage[uuid:{0}] is not in status of Connected, current status is {1}

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:115
# args: systemTag,uuid
%s\ is\ invalid.\ %s\ is\ not\ a\ valid\ zstack\ uuid = {0} is invalid. {1} is not a valid zstack uuid

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:119
# args: resourceUuid
no\ primary\ storage[uuid\:%s]\ found = no primary storage[uuid:{0}] found

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:147
# args: msg.getUuid()
primaryStorage[uuid\=%s]\ does\ not\ exist = primaryStorage[uuid={0}] does not exist

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:482
# args: errs
cannot\ find\ any\ qualified\ primary\ storage,\ errors\ are\ %s = cannot find any qualified primary storage, errors are {0}

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:558
# args: cidr
cidr[%s]\ Input\ Format\ Error = cidr[{0}] Input Format Error

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:554
# args: cidrCount
only\ one\ primaryStorage\ cidr\ system\ tag\ is\ allowed,\ but\ %d\ got = only one primaryStorage cidr system tag is allowed, but {0} got

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:903
# args: psUuid,msg.getPrimaryStorageUuidForRootVolume()
primaryStorageUuid\ conflict,\ the\ primary\ storage\ specified\ by\ the\ instance\ offering\ is\ %s,\ and\ the\ primary\ storage\ specified\ in\ the\ creation\ parameter\ is\ %s = primaryStorageUuid conflict, the primary storage specified by the instance offering is {0}, and the primary storage specified in the creation parameter is {1}

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:985
# args: psUuid,msg.getPrimaryStorageUuid()
primaryStorageUuid\ conflict,\ the\ primary\ storage\ specified\ by\ the\ disk\ offering\ is\ %s,\ and\ the\ primary\ storage\ specified\ in\ the\ creation\ parameter\ is\ %s = primaryStorageUuid conflict, the primary storage specified by the disk offering is {0}, and the primary storage specified in the creation parameter is {1}

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageReservedCapacityAllocatorFlow.java:55
# args: PrimaryStorageGlobalConfig.RESERVED_CAPACITY.value(),spec.getSize()
after\ subtracting\ reserved\ capacity[%s],\ there\ is\ no\ primary\ storage\ having\ required\ size[%s\ bytes],\ may\ be\ the\ threshold\ of\ primary\ storage\ physical\ capacity\ setting\ is\ lower = after subtracting reserved capacity[{0}], there is no primary storage having required size[{1} bytes], may be the threshold of primary storage physical capacity setting is lower

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageTagAllocatorExtension.java:127
# args: uuid
cannot\ find\ primary\ storage[uuid\:%s],\ the\ uuid\ is\ specified\ in\ instance\ offering\ or\ disk\ offering = cannot find primary storage[uuid:{0}], the uuid is specified in instance offering or disk offering

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageTagAllocatorExtension.java:167
# args: tag
cannot\ find\ primary\ storage\ having\ user\ tag[%s].\ The\ user\ tag\ is\ specified\ in\ instance\ offering\ or\ disk\ offering = cannot find primary storage having user tag[{0}]. The user tag is specified in instance offering or disk offering

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageTagAllocatorFlow.java:85
# args: extp.getClass().getName()
PrimaryStorageTagAllocatorExtensionPoint[%s]\ returns\ zero\ primary\ storage\ candidate = PrimaryStorageTagAllocatorExtensionPoint[{0}] returns zero primary storage candidate

# at: src/main/java/org/zstack/storage/primary/imagestore/ceph/CephPrimaryToImageStoreBackupStorageMediatorImpl.java:132
# args: path
all\ monitors\ cannot\ execute\ http\ call[%s] = all monitors cannot execute http call[{0}]

# at: src/main/java/org/zstack/storage/primary/imagestore/ceph/CephPrimaryToImageStoreBackupStorageMediatorImpl.java:97
# args: vo.getUuid()
all\ ceph\ mons\ of\ primary\ storage[uuid\:%s]\ are\ not\ in\ Connected\ state = all ceph mons of primary storage[uuid:{0}] are not in Connected state

# at: src/main/java/org/zstack/storage/primary/imagestore/ceph/CephPrimaryToImageStoreBackupStorageMediatorImpl.java:120
# args: param.getPrimaryStorageUuid()
CephPrimaryStorage[%s]\ not\ existed! = CephPrimaryStorage[{0}] not existed!

# at: src/main/java/org/zstack/storage/primary/imagestore/ceph/CephPrimaryToImageStoreBackupStorageMediatorImpl.java:170
# args: licMgr.getLicenseType().toString()
current\ license[%s]\ is\ not\ valid\ license\ while\ download\ from\ imagestore\ backupstorage = current license[{0}] is not valid license while download from imagestore backupstorage

# at: src/main/java/org/zstack/storage/primary/imagestore/local/LocalStorageKvmImageStoreBackupStorageMediatorImpl.java:207
# args: 
System\ can't\ find\ imagestore\ backup\ Storage.\ Please\ do\ not\ set\ imagestore\ backup\ Storage\ server\ IP\ to\ localhost(127.*.*.*), = System can't find imagestore backup Storage. Please do not set imagestore backup Storage server IP to localhost(127.*.*.*),

# at: src/main/java/org/zstack/storage/primary/imagestore/local/LocalStorageKvmImageStoreBackupStorageMediatorImpl.java:210
# args: operationSuggestion,greply.getHostname(),backupStorageInstallPath,pinv.getUuid(),primaryStorageInstallPath,rsp.getError()
%s\ failed\ to\ download\ bits\ from\ the\ imagestore\ backup\ storage[hostname\:%s,\ path\:\ %s]\ to\ the\ local\ primary\ storage[uuid\:%s,\ path\:\ %s],\ %s = {0} failed to download bits from the imagestore backup storage[hostname:{1}, path: {2}] to the local primary storage[uuid:{3}, path: {4}], {5}

# at: src/main/java/org/zstack/storage/primary/imagestore/local/LocalStorageKvmImageStoreBackupStorageMediatorImpl.java:270
# args: pinv.getUuid(),primaryStorageInstallPath,r.getHostname(),rsp.getError()
failed\ to\ upload\ bits\ from\ the\ local\ storage[uuid\:%s,\ path\:%s]\ to\ image\ store\ [hostname\:%s],\ %s = failed to upload bits from the local storage[uuid:{0}, path:{1}] to image store [hostname:{2}], {3}

# at: src/main/java/org/zstack/storage/primary/imagestore/nfs/NfsPrimaryToImageStoreBackupKVMBackend.java:207
# args: volume.getUuid(),image.getImageUuid(),rsp.getError()
fails\ to\ create\ root\ volume[uuid\:%s]\ from\ cached\ image[path\:%s]\ because\ %s = fails to create root volume[uuid:{0}] from cached image[path:{1}] because {2}

# at: src/main/java/org/zstack/storage/primary/imagestore/nfs/NfsPrimaryToImageStoreBackupKVMBackend.java:262
# args: greply.getHostname(),backupStorageInstallPath,pinv.getUuid(),primaryStorageInstallPath,rsp.getError()
failed\ to\ download\ bits\ from\ the\ imagestore\ backup\ storage[hostname\:%s,\ path\:\ %s]\ to\ the\ nfs\ primary\ storage[uuid\:%s,\ path\:\ %s],\ %s = failed to download bits from the imagestore backup storage[hostname:{0}, path: {1}] to the nfs primary storage[uuid:{2}, path: {3}], {4}

# at: src/main/java/org/zstack/storage/primary/imagestore/nfs/NfsPrimaryToImageStoreBackupKVMBackend.java:323
# args: pinv.getUuid(),primaryStorageInstallPath,r.getHostname(),rsp.getError()
failed\ to\ upload\ bits\ from\ the\ NFS[uuid\:%s,\ path\:%s]\ to\ image\ store\ [hostname\:%s],\ %s = failed to upload bits from the NFS[uuid:{0}, path:{1}] to image store [hostname:{2}], {3}

# at: src/main/java/org/zstack/storage/primary/license/XskyLicenseInfoFactory.java:39
# args: primaryStorageUuid
failed\ to\ get\ primaryStorage[%s]\ license\ info,\ because\ no\ MonIP\ available = failed to get primaryStorage[{0}] license info, because no MonIP available

# at: src/main/java/org/zstack/storage/primary/license/XskyLicenseInfoFactory.java:46
# args: primaryStorageUuid
failed\ to\ get\ primaryStorage[%s]\ license\ info,\ because\ no\ data\ returned = failed to get primaryStorage[{0}] license info, because no data returned

# at: src/main/java/org/zstack/storage/primary/license/XskyLicenseInfoFactory.java:61
# args: primaryStorageUuid
failed\ to\ get\ primaryStorage[%s]\ license\ info,\ because\ the\ returned\ data\ does\ not\ have\ an\ active\ license = failed to get primaryStorage[{0}] license info, because the returned data does not have an active license

# at: src/main/java/org/zstack/storage/primary/license/XskyLicenseInfoFactory.java:53
# args: primaryStorageUuid
failed\ to\ get\ primaryStorage[%s]\ license\ info,\ because\ expired_time\ is\ null = failed to get primaryStorage[{0}] license info, because expired_time is null

# at: src/main/java/org/zstack/storage/primary/local/AllocatePrimaryStorageForVmMigrationFlow.java:85
# args: volumeSize,spec.getVmInstance().getUuid()
no\ hosts\ can\ provide\ %s\ bytes\ for\ all\ volumes\ of\ the\ vm[uuid\:%s] = no hosts can provide {0} bytes for all volumes of the vm[uuid:{1}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageAllocatorFactory.java:306
# args: 
localstorage\ allocator\ failed = localstorage allocator failed

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:90
# args: msg.getVolumeUuid()
the\ volume[uuid\:%s]\ is\ not\ on\ any\ local\ primary\ storage = the volume[uuid:{0}] is not on any local primary storage

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:95
# args: msg.getVolumeUuid(),msg.getDestHostUuid()
the\ volume[uuid\:%s]\ is\ already\ on\ the\ host[uuid\:%s] = the volume[uuid:{0}] is already on the host[uuid:{1}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:101
# args: msg.getPrimaryStorageUuid()
the\ primary\ storage[uuid\:%s]\ is\ not\ found = the primary storage[uuid:{0}] is not found

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:105
# args: ref.getPrimaryStorageUuid()
the\ primary\ storage[uuid\:%s]\ is\ disabled\ or\ maintenance\ cold\ migrate\ is\ not\ allowed = the primary storage[uuid:{0}] is disabled or maintenance cold migrate is not allowed

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:114
# args: msg.getDestHostUuid(),ref.getPrimaryStorageUuid(),msg.getVolumeUuid()
the\ dest\ host[uuid\:%s]\ doesn't\ belong\ to\ the\ local\ primary\ storage[uuid\:%s]\ where\ the\ volume[uuid\:%s]\ locates = the dest host[uuid:{0}] doesn't belong to the local primary storage[uuid:{1}] where the volume[uuid:{2}] locates

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:120
# args: msg.getDestHostUuid(),msg.getPrimaryStorageUuid(),physicalThreshold,refVO.getAvailablePhysicalCapacity()
the\ dest\ host[uuid\:%s]\ doesn't\ have\ enough\ physical\ capacity\ due\ to\ the\ threshold\ of\ primary\ storage[uuid\:%s]\ is\ %f\ but\ available\ physical\ capacity\ is\ %d = the dest host[uuid:{0}] doesn't have enough physical capacity due to the threshold of primary storage[uuid:{1}] is {2} but available physical capacity is {3}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:127
# args: msg.getVolumeUuid()
the\ volume[uuid\:%s]\ is\ not\ in\ status\ of\ Ready,\ cannot\ migrate\ it = the volume[uuid:{0}] is not in status of Ready, cannot migrate it

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:139
# args: vol.getUuid(),vol.getVmInstanceUuid(),vmstate
the\ volume[uuid\:%s]\ is\ the\ root\ volume\ of\ the\ vm[uuid\:%s].\ Currently\ the\ vm\ is\ in\ state\ of\ %s,\ please\ stop\ it\ before\ migration = the volume[uuid:{0}] is the root volume of the vm[uuid:{1}]. Currently the vm is in state of {2}, please stop it before migration

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:147
# args: vol.getUuid(),vol.getVmInstanceUuid(),count
the\ volume[uuid\:%s]\ is\ the\ root\ volume\ of\ the\ vm[uuid\:%s].\ Currently\ the\ vm\ still\ has\ %s\ data\ volumes\ attached,\ please\ detach\ them\ before\ migration = the volume[uuid:{0}] is the root volume of the vm[uuid:{1}]. Currently the vm still has {2} data volumes attached, please detach them before migration

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:152
# args: vol.getUuid(),vol.getVmInstanceUuid()
the\ volume[uuid\:%s]\ is\ the\ root\ volume\ of\ the\ vm[uuid\:%s].\ Currently\ the\ vm\ still\ has\ ISO\ attached,\ please\ detach\ it\ before\ migration = the volume[uuid:{0}] is the root volume of the vm[uuid:{1}]. Currently the vm still has ISO attached, please detach it before migration

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:177
# args: originClusterUuid,clusterUuid,vol.getVmInstanceUuid()
The\ two\ clusters[uuid\:%s,uuid\:%s]\ cannot\ access\ each\ other\ in\ l2\ network\ \ when\ migrate\ the\ vm[uuid\:%s]\ to\ another\ cluster = The two clusters[uuid:{0},uuid:{1}] cannot access each other in l2 network  when migrate the vm[uuid:{2}] to another cluster

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:132
# args: vol.getUuid(),vol.getName(),vol.getVmInstanceUuid()
the\ data\ volume[uuid\:%s,\ name\:\ %s]\ is\ still\ attached\ to\ the\ VM[uuid\:%s].\ Please\ detach\ it\ before\ migration = the data volume[uuid:{0}, name: {1}] is still attached to the VM[uuid:{2}]. Please detach it before migration

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:191
# args: msg.getUrl()
the\ url[%s]\ is\ not\ an\ absolute\ path\ starting\ with\ '/' = the url[{0}] is not an absolute path starting with '/'

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:258
# args: msg.getPrimaryStorageUuid()
The\ primary\ storage[uuid\:%s]\ is\ disabled\ cold\ migrate\ is\ not\ allowed = The primary storage[uuid:{0}] is disabled cold migrate is not allowed

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:560
# args: msg.getVolumeUuid()
volume[uuid\:%s]\ is\ not\ on\ the\ local\ storage\ anymore,it\ may\ have\ been\ deleted = volume[uuid:{0}] is not on the local storage anymore,it may have been deleted

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:1143
# args: msg.getImage().getUuid(),self.getUuid(),JSONObjectUtil.toJsonString(ret.errorCodes)
failed\ to\ download\ image[uuid\:%s]\ to\ all\ hosts\ in\ the\ local\ storage[uuid\:%s].\ %s = failed to download image[uuid:{0}] to all hosts in the local storage[uuid:{1}]. {2}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:1392
# args: resUuid,uuid
Resource[uuid\:%s]\ can\ only\ be\ operated\ on\ host[uuid\:%s],\ but\ the\ host\ has\ been\ deleted = Resource[uuid:{0}] can only be operated on host[uuid:{1}], but the host has been deleted

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:1389
# args: resUuid
cannot\ find\ any\ host\ which\ has\ resource[uuid\:%s] = cannot find any host which has resource[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:1764
# args: hostUuid,self.getUuid(),ref.getAvailableCapacity(),size
host[uuid\:\ %s]\ of\ local\ primary\ storage[uuid\:\ %s]\ doesn't\ have\ enough\ capacity[current\:\ %s\ bytes,\ needed\:\ %s] = host[uuid: {0}] of local primary storage[uuid: {1}] doesn't have enough capacity[current: {2} bytes, needed: {3}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:2111
# args: msg.getVolumeUuid(),self.getUuid()
unable\ to\ create\ the\ data\ volume[uuid\:\ %s]\ on\ a\ local\ primary\ storage[uuid\:%s],\ because\ the\ hostUuid\ is\ not\ specified. = unable to create the data volume[uuid: {0}] on a local primary storage[uuid:{1}], because the hostUuid is not specified.

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:2634
# args: 
No\ Host\ state\ is\ Enabled,\ Please\ check\ the\ availability\ of\ the\ host = No Host state is Enabled, Please check the availability of the host

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:2741
# args: hostUuid,self.getUuid()
host[uuid\:%s]\ cannot\ access\ local\ storage[uuid\:%s],\ maybe\ it\ is\ detached = host[uuid:{0}] cannot access local storage[uuid:{1}], maybe it is detached

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:2765
# args: resUuid,resourceType,self.getUuid()
resource[uuid\:%s,\ type\:\ %s]\ is\ not\ on\ the\ local\ primary\ storage[uuid\:%s] = resource[uuid:{0}, type: {1}] is not on the local primary storage[uuid:{2}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:2770
# args: resUuid,resourceType,self.getUuid(),ret
resource[uuid\:%s,\ type\:\ %s]\ on\ the\ local\ primary\ storage[uuid\:%s]\ maps\ to\ multiple\ hypervisor%s = resource[uuid:{0}, type: {1}] on the local primary storage[uuid:{2}] maps to multiple hypervisor{3}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageDefaultAllocateCapacityFlow.java:99
# args: PrimaryStorageState.Enabled,PrimaryStorageStatus.Connected,clusterUuid
There\ is\ no\ LocalStorage\ primary\ storage[state\=%s,status\=%s]\ on\ the\ cluster[%s],\ when\ the\ cluster\ mounts\ multiple\ primary\ storage,\ the\ system\ uses\ the\ local\ primary\ storage\ by\ default.\ Check\ the\ state/status\ of\ primary\ storage\ and\ make\ sure\ they\ have\ been\ attached\ to\ clusters = There is no LocalStorage primary storage[state={0},status={1}] on the cluster[{2}], when the cluster mounts multiple primary storage, the system uses the local primary storage by default. Check the state/status of primary storage and make sure they have been attached to clusters

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageDefaultAllocateCapacityFlow.java:118
# args: psUuid
the\ type\ of\ primary\ storage[uuid\:%s]\ chosen\ is\ not\ local\ storage,\ check\ if\ the\ resource\ can\ be\ created\ on\ other\ storage\ when\ cluster\ has\ attached\ local\ primary\ storage = the type of primary storage[uuid:{0}] chosen is not local storage, check if the resource can be created on other storage when cluster has attached local primary storage

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageDefaultAllocateCapacityFlow.java:183
# args: requiredPrimaryStorageUuidForDataVolume.getUuid(),requiredPrimaryStorageUuidForDataVolume.getType(),LocalStorageConstants.LOCAL_STORAGE_TYPE
The\ cluster\ mounts\ multiple\ primary\ storage[%s(%s),\ other\ non-LocalStorage\ primary\ storage],\ primaryStorageUuidForDataVolume\ cannot\ be\ specified\ %s = The cluster mounts multiple primary storage[{0}({1}), other non-LocalStorage primary storage], primaryStorageUuidForDataVolume cannot be specified {2}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageDesignatedAllocateCapacityFlow.java:119
# args: spec.getDestHost().getClusterUuid()
The\ cluster[uuid\=%s]\ mounts\ multiple\ primary\ storage[LocalStorage,\ other\ non-LocalStorage\ primary\ storage],\ You\ must\ specify\ the\ primary\ storage\ where\ the\ root\ disk\ is\ located = The cluster[uuid={0}] mounts multiple primary storage[LocalStorage, other non-LocalStorage primary storage], You must specify the primary storage where the root disk is located

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageDesignatedAllocateCapacityFlow.java:125
# args: spec.getDestHost().getClusterUuid()
The\ cluster[uuid\=%s]\ mounts\ multiple\ primary\ storage[LocalStorage,\ other\ non-LocalStorage\ primary\ storage],\ You\ must\ specify\ the\ primary\ storage\ where\ the\ data\ disk\ is\ located = The cluster[uuid={0}] mounts multiple primary storage[LocalStorage, other non-LocalStorage primary storage], You must specify the primary storage where the data disk is located

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:365
# args: spec.getVmInventory().getHypervisorType()
local\ storage\ doesn't\ support\ live\ migration\ for\ hypervisor[%s] = local storage doesn't support live migration for hypervisor[{0}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:581
# args: volume.getUuid(),vm.getUuid(),vm.getRootVolumeUuid(),rootHost,volume.getUuid(),dataHost
cannot\ attach\ the\ data\ volume[uuid\:%s]\ to\ the\ vm[uuid\:%s].\ Both\ vm's\ root\ volume\ and\ the\ data\ volume\ are\ on\ local\ primary\ storage,\ but\ they\ are\ on\ different\ hosts.\ The\ root\ volume[uuid\:%s]\ is\ on\ the\ host[uuid\:%s]\ but\ the\ data\ volume[uuid\:\ %s]\ is\ on\ the\ host[uuid\:\ %s] = cannot attach the data volume[uuid:{0}] to the vm[uuid:{1}]. Both vm's root volume and the data volume are on local primary storage, but they are on different hosts. The root volume[uuid:{2}] is on the host[uuid:{3}] but the data volume[uuid: {4}] is on the host[uuid: {5}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:809
# args: vol.getName(),vol.getUuid(),vol.getPrimaryStorageUuid()
the\ data\ volume[name\:%s,\ uuid\:%s]\ is\ on\ the\ local\ storage[uuid\:%s];\ however,the\ host\ on\ which\ the\ data\ volume\ is\ has\ been\ deleted.\ Unable\ to\ recover\ this\ volume = the data volume[name:{0}, uuid:{1}] is on the local storage[uuid:{2}]; however,the host on which the data volume is has been deleted. Unable to recover this volume

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:851
# args: vm.getUuid(),vm.getName(),psuuid
unable\ to\ recover\ the\ vm[uuid\:%s,\ name\:%s].\ The\ vm's\ root\ volume\ is\ on\ the\ local\ storage[uuid\:%s];\ however,\ the\ host\ on\ which\ the\ root\ volume\ is\ has\ been\ deleted = unable to recover the vm[uuid:{0}, name:{1}]. The vm's root volume is on the local storage[uuid:{2}]; however, the host on which the root volume is has been deleted

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:888
# args: vm.getUuid()
unable\ to\ live\ migrate\ vm[uuid\:%s]\ with\ data\ volumes\ on\ local\ storage.\ Need\ detach\ all\ data\ volumes\ first. = unable to live migrate vm[uuid:{0}] with data volumes on local storage. Need detach all data volumes first.

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:893
# args: vm.getUuid(),vm.getPlatform()
unable\ to\ live\ migrate\ vm[uuid\:%s]\ with\ local\ storage.\ Only\ linux\ guest\ is\ supported.\ Current\ platform\ is\ [%s] = unable to live migrate vm[uuid:{0}] with local storage. Only linux guest is supported. Current platform is [{1}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:898
# args: vm.getUuid()
unable\ to\ live\ migrate\ vm[uuid\:%s]\ with\ ISO\ on\ local\ storage.\ Need\ detach\ all\ ISO\ first. = unable to live migrate vm[uuid:{0}] with ISO on local storage. Need detach all ISO first.

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:929
# args: vm.getUuid()
unable\ to\ live\ migrate\ with\ local\ storage.\ The\ vm[uuid\:%s]\ has\ volumes\ on\ local\ storage,to\ protect\ your\ data,\ please\ stop\ the\ vm\ and\ do\ the\ volume\ migration = unable to live migrate with local storage. The vm[uuid:{0}] has volumes on local storage,to protect your data, please stop the vm and do the volume migration

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:979
# args: LocalStorageSystemTags.DEST_HOST_FOR_CREATING_DATA_VOLUME.getTagFormat()
To\ create\ data\ volume\ on\ the\ local\ primary\ storage,\ you\ must\ specify\ the\ host\ that\ the\ data\ volume\ is\ going\ to\ be\ created\ using\ the\ system\ tag\ [%s] = To create data volume on the local primary storage, you must specify the host that the data volume is going to be created using the system tag [{0}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:989
# args: hostUuid,msg.getPrimaryStorageUuid()
the\ host[uuid\:%s]\ doesn't\ belong\ to\ the\ local\ primary\ storage[uuid\:%s] = the host[uuid:{0}] doesn't belong to the local primary storage[uuid:{1}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmBackend.java:1782
# args: 
root\ image\ has\ been\ deleted,\ cannot\ reimage\ now = root image has been deleted, cannot reimage now

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmBackend.java:3117
# args: makeInitializedFilePath(),hostUuid
cannot\ find\ flag\ file\ [%s]\ on\ host\ [%s],\ it\ might\ not\ mount\ correct\ path = cannot find flag file [{0}] on host [{1}], it might not mount correct path

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmFactory.java:105
# args: context.getInventory().getUuid(),priUuid,reply.getError()
KVM\ host[uuid\:\ %s]\ fails\ to\ be\ added\ into\ local\ primary\ storage[uuid\:\ %s],\ %s = KVM host[uuid: {0}] fails to be added into local primary storage[uuid: {1}], {2}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmMigrateVmFlow.java:1196
# args: p.volume.getUuid(),p.volume.getName(),dstHostUuid
unable\ to\ create\ an\ empty\ volume[uuid\:%s,\ name\:%s]\ on\ the\ kvm\ host[uuid\:%s] = unable to create an empty volume[uuid:{0}, name:{1}] on the kvm host[uuid:{2}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmSftpBackupStorageMediatorImpl.java:204
# args: greply.getHostname(),backupStorageInstallPath,pinv.getUuid(),primaryStorageInstallPath,rsp.getError()
failed\ to\ download\ bits\ from\ the\ SFTP\ backup\ storage[hostname\:%s,\ path\:\ %s]\ to\ the\ local\ primary\ storage[uuid\:%s,\ path\:\ %s],\ %s = failed to download bits from the SFTP backup storage[hostname:{0}, path: {1}] to the local primary storage[uuid:{2}, path: {3}], {4}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmSftpBackupStorageMediatorImpl.java:254
# args: pinv.getUuid(),primaryStorageInstallPath,r.getHostname(),backupStorageInstallPath,rsp.getError()
failed\ to\ upload\ bits\ from\ the\ local\ storage[uuid\:%s,\ path\:%s]\ to\ the\ SFTP\ backup\ storage[hostname\:%s,\ path\:%s],\ %s = failed to upload bits from the local storage[uuid:{0}, path:{1}] to the SFTP backup storage[hostname:{2}, path:{3}], {4}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageMainAllocatorFlow.java:157
# args: PrimaryStorageState.Enabled,PrimaryStorageStatus.Connected,HostState.Enabled,HostStatus.Connected,spec.getSize()
no\ local\ primary\ storage\ can\ satisfy\ conditions[state\:\ %s,\ status\:\ %s]\ or\ contain\ hosts\ satisfying\ conditions[state\:\ %s,\ status\:\ %s,\ size\ >\ %s\ bytes] = no local primary storage can satisfy conditions[state: {0}, status: {1}] or contain hosts satisfying conditions[state: {2}, status: {3}, size > {4} bytes]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageMainAllocatorFlow.java:132
# args: spec.getRequiredZoneUuid(),PrimaryStorageState.Enabled,PrimaryStorageStatus.Connected,HostState.Enabled,HostStatus.Connected,spec.getSize()
no\ local\ primary\ storage\ in\ zone[uuid\:%s]\ can\ satisfy\ conditions[state\:\ %s,\ status\:\ %s]\ or\ contain\ hosts\ satisfying\ conditions[state\:\ %s,\ status\:\ %s,\ size\ >\ %s\ bytes] = no local primary storage in zone[uuid:{0}] can satisfy conditions[state: {1}, status: {2}] or contain hosts satisfying conditions[state: {3}, status: {4}, size > {5} bytes]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageMainAllocatorFlow.java:105
# args: spec.getRequiredHostUuid(),HostState.Enabled,HostStatus.Connected,spec.getSize(),PrimaryStorageState.Enabled,PrimaryStorageStatus.Connected
the\ required\ host[uuid\:%s]\ cannot\ satisfy\ conditions[state\:\ %s,\ status\:\ %s,\ size\ >\ %s\ bytes],\ or\ doesn't\ belong\ to\ a\ local\ primary\ storage\ satisfying\ conditions[state\:\ %s,\ status\:\ %s],\ or\ its\ cluster\ doesn't\ attach\ to\ any\ local\ primary\ storage = the required host[uuid:{0}] cannot satisfy conditions[state: {1}, status: {2}, size > {3} bytes], or doesn't belong to a local primary storage satisfying conditions[state: {4}, status: {5}], or its cluster doesn't attach to any local primary storage

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageMainAllocatorFlow.java:77
# args: spec.getRequiredPrimaryStorageUuid(),PrimaryStorageState.Enabled,PrimaryStorageStatus.Connected,HostState.Enabled,HostStatus.Connected,spec.getSize()
required\ local\ primary\ storage[uuid\:%s]\ cannot\ satisfy\ conditions[state\:\ %s,\ status\:\ %s],\ or\ hosts\ providing\ the\ primary\ storage\ don't\ satisfy\ conditions[state\:\ %s,\ status\:\ %s,\ size\ >\ %s\ bytes] = required local primary storage[uuid:{0}] cannot satisfy conditions[state: {1}, status: {2}], or hosts providing the primary storage don't satisfy conditions[state: {3}, status: {4}, size > {5} bytes]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageMainAllocatorFlow.java:198
# args: ref.getHostUuid(),physicalCapacityMgr.getRatio(ref.getPrimaryStorageUuid())
{the\ physical\ capacity\ usage\ of\ the\ host[uuid\:%s]\ has\ exceeded\ the\ threshold[%s]} = '{the physical capacity usage of the host[uuid:{0}'] has exceeded the threshold[{1}]}

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageBase.java:1002
# args: 
not\ supported = not supported

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageBase.java:1104
# args: self.getUuid(),hostUuid
cannot\ reserve\ enough\ space\ for\ primary\ storage[uuid\:\ %s]\ on\ host[uuid\:\ %s],\ not\ enough\ physical\ capacity = cannot reserve enough space for primary storage[uuid: {0}] on host[uuid: {1}], not enough physical capacity

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageBase.java:154
# args: psUuid,imageFormat
cannot\ find\ proper\ hypervisorType\ for\ primary\ storage[uuid\:%s]\ to\ handle\ image\ format\ or\ volume\ format[%s] = cannot find proper hypervisorType for primary storage[uuid:{0}] to handle image format or volume format[{1}]

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageBase.java:226
# args: self.getUuid(),self.getName()
the\ mini\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ any\ available\ host\ in\ attached\ clusters\ for\ instantiating\ the\ volume = the mini storage[uuid:{0}, name:{1}] cannot find any available host in attached clusters for instantiating the volume

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageBase.java:449
# args: 
can\ not\ determine\ which\ host = can not determine which host

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageBase.java:1118
# args: hostUuid,self.getUuid(),ref.getAvailableCapacity(),size
host[uuid\:\ %s]\ of\ mini\ primary\ storage[uuid\:\ %s]\ doesn't\ have\ enough\ capacity[current\:\ %s\ bytes,\ needed\:\ %s] = host[uuid: {0}] of mini primary storage[uuid: {1}] doesn't have enough capacity[current: {2} bytes, needed: {3}]

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageFactory.java:167
# args: hvType,bsType
no\ LocalStorageBackupStorageMediator\ supporting\ hypervisor[%s]\ and\ backup\ storage\ type[%s]\  = no LocalStorageBackupStorageMediator supporting hypervisor[{0}] and backup storage type[{1}] 

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageImageStoreBackend.java:59
# args: volumeUuid
can\ not\ get\ cluster\ uuid\ of\ volume\ %s = can not get cluster uuid of volume {0}

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageKvmBackend.java:736
# args: returnValue.error
%s = {0}

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageKvmBackend.java:181
# args: clusterUuid
no\ connected\ host\ found\ in\ the\ cluster[uuid\:%s] = no connected host found in the cluster[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageKvmBackend.java:1271
# args: backupStorageUuid
cannot\ find\ backup\ storage[uuid\:%s] = cannot find backup storage[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageKvmBackend.java:1056
# args: msg.getVolumeUuid()
can\ not\ find\ volume[uuid\:\ %s] = can not find volume[uuid: {0}]

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageKvmFactory.java:723
# args: volume.getUuid(),volume.getPrimaryStorageUuid()
can\ not\ find\ any\ available\ host\ to\ resize\ volume[uuid\:\ %s]\ on\ mini\ storage[uuid\:\ %s] = can not find any available host to resize volume[uuid: {0}] on mini storage[uuid: {1}]

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStoragePathManagerImpl.java:105
# args: resourceUuid,hostUuid
can\ not\ find\ replication\ of\ volume\ %s\ on\ host\ %s = can not find replication of volume {0} on host {1}

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStoragePlacementManagerImpl.java:187
# args: 
no\ candidate\ host\ with\ the\ scsi\ lun\ with\ enough\ cpu\ /\ memory\ or\ Enabled/Connected\ status = no candidate host with the scsi lun with enough cpu / memory or Enabled/Connected status

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStoragePlacementManagerImpl.java:113
# args: clusterUuid,msg.getPrimaryStorageUuid(),volume.getUuid()
required\ cluster\ %s\ not\ attached\ to\ primary\ storage\ %s\ for\ volume\ %s\ create = required cluster {0} not attached to primary storage {1} for volume {2} create

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStoragePlacementManagerImpl.java:120
# args: clusterUuid,volume.getUuid()
can\ not\ find\ avaliable\ host\ on\ required\ cluster\ %s\ for\ volume\ %s\ create = can not find avaliable host on required cluster {0} for volume {1} create

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStoragePlacementManagerImpl.java:347
# args: primaryStorageUuid
cannot\ find\ an\ available\ host\ to\ execute\ command\ for\ primary\ storage[uuid\:\ %s] = cannot find an available host to execute command for primary storage[uuid: {0}]

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStoragePlacementManagerImpl.java:378
# args: hostUuid
can\ not\ allocate\ storage\ sync\ port\ on\ host\ %s\:\ %s = can not allocate storage sync port on host {0}: {1}

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStoragePlacementManagerImpl.java:490
# args: hostUuids,connectedEnabledHosts
expect\ operate\ on\ hosts[%s]\ but\ only\ host\ %s\ are\ connected\ and\ enabled = expect operate on hosts[{0}] but only host {1} are connected and enabled

# at: src/main/java/org/zstack/storage/primary/nfs/NfsApiParamChecker.java:46
# args: url,zoneUuid
there\ has\ been\ a\ nfs\ primary\ storage\ having\ url\ as\ %s\ in\ zone[uuid\:%s] = there has been a nfs primary storage having url as {0} in zone[uuid:{1}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsApiParamChecker.java:65
# args: 
found\ multiple\ CIDR = found multiple CIDR

# at: src/main/java/org/zstack/storage/primary/nfs/NfsApiParamChecker.java:78
# args: cidr
invalid\ CIDR\:\ %s = invalid CIDR: {0}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsApiParamChecker.java:82
# args: ipAddr,cidr
IP\ address[%s]\ is\ not\ in\ CIDR[%s] = IP address[{0}] is not in CIDR[{1}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsApiParamChecker.java:96
# args: vms.size(),StringUtils.join(vms, "\n")
there\ are\ %s\ running\ VMs\ on\ the\ NFS\ primary\ storage,\ please\ stop\ them\ and\ try\ again\:\n%s\n = there are {0} running VMs on the NFS primary storage, please stop them and try again:\n{1}\n

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:227
# args: 
cannot\ find\ usable\ backend = cannot find usable backend

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:286
# args: 
no\ usable\ backend\ found = no usable backend found

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:426
# args: self.getUuid(),self.getName(),msg.getVolume().getUuid(),msg.getSnapshot().getUuid(),msg.getSnapshot().getName()
no\ host\ in\ Connected\ status\ to\ which\ nfs\ primary\ storage[uuid\:%s,\ name\:%s]\ attached\ found\ to\ revert\ volume[uuid\:%s]\ to\ snapshot[uuid\:%s,\ name\:%s] = no host in Connected status to which nfs primary storage[uuid:{0}, name:{1}] attached found to revert volume[uuid:{2}] to snapshot[uuid:{3}, name:{4}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:457
# args: self.getUuid(),self.getName(),msg.getVolume().getUuid(),msg.getVolume().getRootImageUuid()
no\ host\ in\ Connected\ status\ to\ which\ nfs\ primary\ storage[uuid\:%s,\ name\:%s]\ attached\ found\ to\ revert\ volume[uuid\:%s]\ to\ image[uuid\:%s] = no host in Connected status to which nfs primary storage[uuid:{0}, name:{1}] attached found to revert volume[uuid:{2}] to image[uuid:{3}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:536
# args: vol.getVmInstanceUuid(),state
vm[uuid\:%s]\ is\ not\ Running,\ Paused\ or\ Stopped,\ current\ state\ is\ %s = vm[uuid:{0}] is not Running, Paused or Stopped, current state is {1}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:579
# args: self.getUuid()
primary\ storage[uuid\:%s]\ doesn't\ attach\ to\ any\ cluster = primary storage[uuid:{0}] doesn't attach to any cluster

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:809
# args: self.getUuid(),self.getName(),msg.getVolume().getUuid(),msg.getVolume().getName()
the\ NFS\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ any\ usable\ host\ to\ create\ the\ data\ volume[uuid\:%s,\ name\:%s] = the NFS primary storage[uuid:{0}, name:{1}] cannot find any usable host to create the data volume[uuid:{2}, name:{3}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:1425
# args: self.getUuid(),self.getName()
the\ NFS\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ hosts\ in\ attached\ clusters\ to\ perform\ the\ operation = the NFS primary storage[uuid:{0}, name:{1}] cannot find hosts in attached clusters to perform the operation

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:1392
# args: self.getUuid(),self.getName()
the\ NFS\ primary\ storage[uuid\:%s,\ name\:%s]\ has\ not\ attached\ to\ any\ clusters,\ or\ no\ hosts\ in\ the\ attached\ clusters\ are\ connected = the NFS primary storage[uuid:{0}, name:{1}] has not attached to any clusters, or no hosts in the attached clusters are connected

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageFactory.java:112
# args: psUuid,vmUuid,volumeUuid
the\ NFS\ primary\ storage[uuid\:%s]\ is\ not\ attached\ to\ any\ clusters,\ and\ cannot\ expunge\ the\ root\ volume[uuid\:%s]\ of\ the\ VM[uuid\:%s] = the NFS primary storage[uuid:{0}] is not attached to any clusters, and cannot expunge the root volume[uuid:{1}] of the VM[uuid:{2}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageFactory.java:278
# args: pri.getUuid()
cannot\ find\ a\ Connected\ host\ to\ execute\ command\ for\ nfs\ primary\ storage[uuid\:%s] = cannot find a Connected host to execute command for nfs primary storage[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageFactory.java:269
# args: pri.getUuid()
cannot\ find\ a\ connected\ host\ in\ cluster\ which\ ps\ [uuid\:\ %s]\ attached = cannot find a connected host in cluster which ps [uuid: {0}] attached

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageFactory.java:297
# args: pri.getUuid()
cannot\ find\ a\ host\ which\ has\ Connected\ host-NFS\ connection\ to\ execute\ command\ for\ nfs\ primary\ storage[uuid\:%s] = cannot find a host which has Connected host-NFS connection to execute command for nfs primary storage[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:673
# args: msg.getVolume().getUuid()
cannot\ get\ root\ image\ of\ volume[uuid\:%s],\ may\ be\ it\ create\ from\ iso = cannot get root image of volume[uuid:{0}], may be it create from iso

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:241
# args: inv.getUuid(),inv.getName(),clusterUuid,versionInCluster,otherVersion,QCOW3_QEMU_IMG_VERSION,QCOW3_QEMU_IMG_VERSION
unable\ to\ attach\ a\ primary\ storage[uuid\:%s,\ name\:%s]\ to\ cluster[uuid\:%s].\ Kvm\ host\ in\ the\ cluster\ has\ qemu-img\ with\ version[%s];\ but\ the\ primary\ storage\ has\ attached\ to\ another\ cluster\ that\ has\ kvm\ host\ which\ has\ qemu-img\ with\ version[%s].\ qemu-img\ version\ greater\ than\ %s\ is\ incompatible\ with\ versions\ less\ than\ %s,\ this\ will\ causes\ volume\ snapshot\ operation\ to\ fail.\ Please\ avoid\ attaching\ a\ primary\ storage\ to\ clusters\ that\ have\ different\ Linux\ distributions,\ in\ order\ to\ prevent\ qemu-img\ version\ mismatch = unable to attach a primary storage[uuid:{0}, name:{1}] to cluster[uuid:{2}]. Kvm host in the cluster has qemu-img with version[{3}]; but the primary storage has attached to another cluster that has kvm host which has qemu-img with version[{4}]. qemu-img version greater than {5} is incompatible with versions less than {6}, this will causes volume snapshot operation to fail. Please avoid attaching a primary storage to clusters that have different Linux distributions, in order to prevent qemu-img version mismatch

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:316
# args: cmd.getInstallUrl(),host.getUuid(),host.getManagementIp(),rsp.getError()
unable\ to\ create\ folder[installUrl\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = unable to create folder[installUrl:{0}] on kvm host[uuid:{1}, ip:{2}], because {3}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:394
# args: inv.getUuid()
no\ host\ in\ is\ Connected\ or\ primary\ storage[uuid\:%s]\ attach\ no\ cluster = no host in is Connected or primary storage[uuid:{0}] attach no cluster

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:433
# args: psInv.getUuid(),huuid,reply.isSuccess() ? rsp.getError() : reply.getError()
failed\ to\ ping\ nfs\ primary\ storage[uuid\:%s]\ from\ host[uuid\:%s],because\ %s.\ disconnect\ this\ host-ps\ connection = failed to ping nfs primary storage[uuid:{0}] from host[uuid:{1}],because {2}. disconnect this host-ps connection

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:699
# args: msg.getHostUuid()
The\ chosen\ host[uuid\:%s]\ to\ perform\ storage\ migration\ is\ lost = The chosen host[uuid:{0}] to perform storage migration is lost

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:835
# args: installPath,inv.getUuid(),rsp.getError()
failed\ to\ check\ existence\ of\ %s\ on\ nfs\ primary\ storage[uuid\:%s],\ %s = failed to check existence of {0} on nfs primary storage[uuid:{1}], {2}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:947
# args: volume.getUuid(),volume.getName(),host.getUuid(),host.getManagementIp(),rsp.getError()
unable\ to\ create\ empty\ volume[uuid\:%s,\ \ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = unable to create empty volume[uuid:{0},  name:{1}] on kvm host[uuid:{2}, ip:{3}], because {4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:1051
# args: installPath,pinv.getUuid(),rsp.getError()
failed\ to\ delete\ bits[%s]\ on\ nfs\ primary\ storage[uuid\:%s],\ %s,\ will\ clean\ up\ installPath,\ pinv.getUuid(),\ rsp.getError() = failed to delete bits[{0}] on nfs primary storage[uuid:{1}], {2}, will clean up installPath, pinv.getUuid(), rsp.getError()

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:1095
# args: vol.getUuid(),sinv.getUuid(),host.getUuid(),host.getManagementIp(),rsp.getError()
failed\ to\ revert\ volume[uuid\:%s]\ to\ snapshot[uuid\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ %s = failed to revert volume[uuid:{0}] to snapshot[uuid:{1}] on kvm host[uuid:{2}, ip:{3}], {4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:1132
# args: vol.getUuid(),vol.getRootImageUuid(),host.getUuid(),host.getManagementIp(),rsp.getError()
failed\ to\ revert\ volume[uuid\:%s]\ to\ image[uuid\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ %s = failed to revert volume[uuid:{0}] to image[uuid:{1}] on kvm host[uuid:{2}, ip:{3}], {4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:1270
# args: clusterUuid
no\ hosts\ in\ the\ cluster[uuid\:%s]\ are\ connected = no hosts in the cluster[uuid:{0}] are connected

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryToSftpBackupKVMBackend.java:158
# args: backupStorageInstallPath,greply.getHostname(),pinv.getUuid(),primaryStorageInstallPath,rsp.getError()
failed\ to\ download[%s]\ from\ SftpBackupStorage[hostname\:%s]\ to\ nfs\ primary\ storage[uuid\:%s,\ path\:%s],\ %s = failed to download[{0}] from SftpBackupStorage[hostname:{1}] to nfs primary storage[uuid:{2}, path:{3}], {4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryToSftpBackupKVMBackend.java:214
# args: pinv.getUuid(),primaryStorageInstallPath,hostname,backupStorageInstallPath,rsp.getError()
failed\ to\ upload\ bits\ from\ nfs\ primary\ storage[uuid\:%s,\ path\:%s]\ to\ SFTP\ backup\ storage[hostname\:%s,\ path\:\ %s],\ %s = failed to upload bits from nfs primary storage[uuid:{0}, path:{1}] to SFTP backup storage[hostname:{2}, path: {3}], {4}

# at: src/main/java/org/zstack/storage/primary/sharedblock/KvmAgentCommandDispatcher.java:65
# args: this.primaryStorageUuid
cannot\ find\ any\ connected\ host\ to\ perform\ the\ operation,\ it\ seems\ all\ KVM\ hosts\ in\ the\ clusters\ attached\ with\ the\ shared\ mount\ point\ storage[uuid\:%s]\ are\ disconnected = cannot find any connected host to perform the operation, it seems all KVM hosts in the clusters attached with the shared mount point storage[uuid:{0}] are disconnected

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockApiInterceptor.java:77
# args: sharedBlockVO.getSharedBlockGroupUuid(),scsiLunVO.getWwid()
primary\ storage[uuid\:\ %s]\ has\ attached\ the\ scsi\ lun[wwid\:\ %s] = primary storage[uuid: {0}] has attached the scsi lun[wwid: {1}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockApiInterceptor.java:100
# args: msg.getVmInstanceUuid()
the\ vm[uuid\:\ %s]\ does\ not\ has\ additional\ qmp\ socket,\ it\ may\ because\ of\ the\ vm\ start\ without\ the\ global\ config[vm.additionalQmp]\ enabled,\ please\ make\ sure\ it\ enabled\ and\ reboot\ vm\ in\ zstack = the vm[uuid: {0}] does not has additional qmp socket, it may because of the vm start without the global config[vm.additionalQmp] enabled, please make sure it enabled and reboot vm in zstack

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockApiInterceptor.java:125
# args: 
must\ specify\ at\ least\ one\ disk\ when\ add\ shared\ block\ group\ primary\ storage = must specify at least one disk when add shared block group primary storage

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockApiInterceptor.java:137
# args: vo.getUuid(),vo.getDiskUuid(),vo.getDescription(),vo.getSharedBlockGroupUuid()
shared\ block[uuid\:%s,\ diskUuid\:%s,\ description\:%s]\ already\ added\ to\ shared\ block\ group[uuid\:%s]in\ new\ shared\ block\ group = shared block[uuid:{0}, diskUuid:{1}, description:{2}] already added to shared block group[uuid:{3}]in new shared block group

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockApiInterceptor.java:160
# args: msg.getUuid()
shared\ volume[uuid\:\ %s]\ on\ shared\ block\ group\ primary\ storage\ can\ not\ resize = shared volume[uuid: {0}] on shared block group primary storage can not resize

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockApiInterceptor.java:229
# args: volumeUuid,notStoppedVmUuids
shared\ volume[uuid\:\ %s]\ on\ shared\ block\ group\ primary\ storage\ has\ attached\ to\ not\ stopped\ vm\ instances[uuids\:\ %s] = shared volume[uuid: {0}] on shared block group primary storage has attached to not stopped vm instances[uuids: {1}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockGroupPrimaryStorageBase.java:301
# args: self.getUuid(),self.getName()
the\ shared\ mount\ point\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ any\ available\ host\ in\ attached\ clusters\ for\ instantiating\ the\ volume = the shared mount point primary storage[uuid:{0}, name:{1}] cannot find any available host in attached clusters for instantiating the volume

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockGroupPrimaryStorageBase.java:530
# args: getSelfInventory().getUuid()
can\ not\ found\ any\ cluster\ attached\ on\ shared\ block\ group\ primary\ storage[uuid\:\ %S] = can not found any cluster attached on shared block group primary storage[uuid: %S]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockGroupPrimaryStorageBase.java:880
# args: self.getUuid(),self.getName()
the\ shared\ block\ group\ primary\ storage[uuid\:%s,\ name\:%s]\ has\ not\ attached\ to\ any\ clusters,\ or\ no\ hosts\ in\ the\ attached\ clusters\ are\ connected = the shared block group primary storage[uuid:{0}, name:{1}] has not attached to any clusters, or no hosts in the attached clusters are connected

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockGroupPrimaryStorageBase.java:1070
# args: 
empty\ migrateVolumeStructs\ in\ migrateVolumesBetweenSharedBlockGroupPrimaryStorageMsg! = empty migrateVolumeStructs in migrateVolumesBetweenSharedBlockGroupPrimaryStorageMsg!

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockGroupPrimaryStorageBase.java:1076
# args: 
no\ volume\ in\ migrateVolumeStructs\ in\ migrateVolumesBetweenSharedBlockGroupPrimaryStorageMsg! = no volume in migrateVolumeStructs in migrateVolumesBetweenSharedBlockGroupPrimaryStorageMsg!

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockGroupPrimaryStorageFactory.java:110
# args: newValue
the\ value[%s]\ is\ not\ power\ of\ 2 = the value[{0}] is not power of 2

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockGroupPrimaryStorageFactory.java:438
# args: pri.getUuid()
cannot\ find\ an\ available\ host\ to\ execute\ command\ for\ shared\ block\ group\ primary\ storage[uuid\:%s] = cannot find an available host to execute command for shared block group primary storage[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockGroupPrimaryStorageFactory.java:462
# args: pri.getUuid()
cannot\ find\ a\ host\ which\ has\ connected\ shared\ block\ to\ execute\ command\ for\ shared\ block\ group\ primary\ storage[uuid\:%s] = cannot find a host which has connected shared block to execute command for shared block group primary storage[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:1104
# args: img.getUuid(),img.getName(),self.getZoneUuid()
the\ image[uuid\:%s,\ name\:\ %s]\ is\ not\ available\ to\ download\ on\ any\ backup\ storage\:\n1.\ check\ if\ image\ is\ in\ status\ of\ Deleted\n2.\ check\ if\ the\ backup\ storage\ on\ which\ the\ image\ is\ shown\ as\ Ready\ is\ attached\ to\ the\ zone[uuid\:%s] = the image[uuid:{0}, name: {1}] is not available to download on any backup storage:\n1. check if image is in status of Deleted\n2. check if the backup storage on which the image is shown as Ready is attached to the zone[uuid:{2}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:832
# args: vol.getVmInstanceUuid(),state
vm[uuid\:%s]\ is\ not\ Running,\ Paused\ or\ Stopped,\ current\ state[%s] = vm[uuid:{0}] is not Running, Paused or Stopped, current state[{1}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:986
# args: volume.getUuid(),volume.getVmInstanceUuid(),state
the\ volume[uuid;%s]\ is\ attached\ to\ a\ VM[uuid\:%s]\ which\ is\ in\ state\ of\ %s,\ cannot\ do\ the\ snapshot\ merge = the volume[uuid;{0}] is attached to a VM[uuid:{1}] which is in state of {2}, cannot do the snapshot merge

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:1075
# args: volume.getUuid()
not\ support\ online\ merge\ snapshot\ for\ shareable\ volume[uuid\:\ %s]\ on\ sharedblock = not support online merge snapshot for shareable volume[uuid: {0}] on sharedblock

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:1120
# args: img.getUuid(),img.getName()
the\ image[uuid\:\ %s,\ name\:%s]\ is\ not\ found\ on\ any\ backup\ storage = the image[uuid: {0}, name:{1}] is not found on any backup storage

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:1561
# args: ret.firstAccessHosts.stream().map( h -> h.hostUuid).collect(Collectors.toList())
hosts[uuid\:%s]\ have\ the\ disk\ uuid\ of\ shared\ block,\ but\ actually\ different\ storage. = hosts[uuid:{0}] have the disk uuid of shared block, but actually different storage.

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:1867
# args: 
not\ support\ convert\ thin\ volume\ to\ thick\ volume\ yet = not support convert thin volume to thick volume yet

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:1921
# args: 
expected\ status\ is\ %s\ and\ current\ status = expected status is {0} and current status

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:2372
# args: self.getUuid()
cannot\ find\ any\ connected\ host\ to\ perform\ the\ operation,\ it\ seems\ all\ KVM\ hosts\ in\ the\ clusters\ attached\ with\ the\ shared\ block\ group\ storage[uuid\:%s]\ are\ disconnected = cannot find any connected host to perform the operation, it seems all KVM hosts in the clusters attached with the shared block group storage[uuid:{0}] are disconnected

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:2344
# args: 
can\ not\ find\ volume\ need\ to\ operate\ shared\ block\ group\ primary\ storage = can not find volume need to operate shared block group primary storage

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:2352
# args: volumeInventory.getUuid(),self.getUuid()
KVM\ host\ which\ volume[uuid%s]\ attached\ disconnected\ with\ the\ shared\ block\ group\ storage[uuid\:%s] = KVM host which volume[uuid{0}] attached disconnected with the shared block group storage[uuid:{1}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:2361
# args: psUuid
can\ not\ find\ qualified\ kvm\ host\ for\ shared\ block\ group\ primary\ storage[uuid\:\ %s] = can not find qualified kvm host for shared block group primary storage[uuid: {0}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:2779
# args: spec.getVmInventory().getUuid(),String.join(",", psUuids)
VM[uuid\:%s]\ has\ multiple\ ISOs\ from\ different\ primary\ storage\:\ %s = VM[uuid:{0}] has multiple ISOs from different primary storage: {1}

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:2954
# args: volume.getUuid()
QCow2\ shared\ volume[uuid\:%s]\ is\ not\ supported = QCow2 shared volume[uuid:{0}] is not supported

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:3819
# args: volumeVO.getUuid(),volumeVO.getPrimaryStorageUuid()
can\ not\ find\ any\ available\ host\ to\ resize\ volume[uuid\:\ %s]\ on\ shared\ block\ group\ primary\ storage[uuid\:\ %s] = can not find any available host to resize volume[uuid: {0}] on shared block group primary storage[uuid: {1}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:3825
# args: struct.getVmHostUuid(),volumeVO.getUuid(),volumeVO.getPrimaryStorageUuid()
the\ host[uuid\:\ %s]\ running\ on\ is\ not\ available\ to\ resize\ volume[uuid\:\ %s]\ on\ shared\ block\ group\ primary\ storage[uuid\:\ %s] = the host[uuid: {0}] running on is not available to resize volume[uuid: {1}] on shared block group primary storage[uuid: {2}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:3943
# args: msg.getVolumeUuid(),msg.getTargetPrimaryStorageUuid()
can\ not\ find\ any\ available\ host\ to\ take\ snapshot\ for\ volume[uuid\:\ %s]\ on\ shared\ block\ group\ primary\ storage[uuid\:\ %s] = can not find any available host to take snapshot for volume[uuid: {0}] on shared block group primary storage[uuid: {1}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:4001
# args: msg.getPrimaryStorageUuid(),msg.getTargetPrimaryStorageUuid()
can\ not\ find\ hosts\ both\ connect\ to\ primary\ storage[uuid\:\ %s]\ and\ primary\ storage[uuid\:\ %s] = can not find hosts both connect to primary storage[uuid: {0}] and primary storage[uuid: {1}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:3956
# args: 
only\ support\ full = only support full

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:3984
# args: msg.getMigrateVolumeStructs().get(0).volumeUuid,msg.getPrimaryStorageUuid(),msg.getTargetPrimaryStorageUuid()
can\ not\ find\ any\ available\ host\ to\ migrate\ volume[uuid\:\ %s]\ between\ shared\ block\ group\ primary\ storage[uuid\:\ %s]\ and\ [uuid\:\ %s] = can not find any available host to migrate volume[uuid: {0}] between shared block group primary storage[uuid: {1}] and [uuid: {2}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:3993
# args: msg.getMigrateVolumeStructs().get(0).volumeUuid,msg.getTargetPrimaryStorageUuid(),msg.getTargetPrimaryStorageUuid()
can\ not\ find\ any\ available\ host\ to\ migrate\ for\ volume[uuid\:\ %s]\ on\ shared\ block\ group\ primary\ storage[uuid\:\ %s]\ and\ [uuid\:\ %s] = can not find any available host to migrate for volume[uuid: {0}] on shared block group primary storage[uuid: {1}] and [uuid: {2}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:4045
# args: msg.getPrimaryStorageUuid()
cannot\ find\ any\ connected\ host\ to\ perform\ the\ operation,\ it\ seems\ all\ KVM\ hosts\ attached\ with\ the\ shared\ block\ group\ storage[uuid\:%s]\ are\ disconnected = cannot find any connected host to perform the operation, it seems all KVM hosts attached with the shared block group storage[uuid:{0}] are disconnected

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:4386
# args: vmVolumesStruct.vmInstanceVO.getUuid()
get\ null\ install\ path\ in\ snapshot\ for\ vm\ %s = get null install path in snapshot for vm {0}

# at: src/main/java/org/zstack/storage/primary/sharedblock/migration/SblkToSblkCancelMigrateVolumeFlow.java:37
# args: 
migrate\ volume\ without\ snapshot\ on\ shared\ block\ is\ not\ support\ to\ cancel. = migrate volume without snapshot on shared block is not support to cancel.

# at: src/main/java/org/zstack/storage/primary/sharedblock/migration/SblkToSblkMigrateVolumeFlow.java:129
# args: reply1.getTrashId(),dstPsUuid,dstVolumeFolderPath,reply1.getResourceUuid()
found\ trashId(%s)\ in\ PrimaryStorage\ [%s]\ for\ the\ migrate\ installPath[%s].\ Please\ clean\ it\ first\ by\ 'APICleanUpTrashOnPrimaryStorageMsg'\ if\ you\ insist\ to\ migrate\ the\ volume[%s] = found trashId({0}) in PrimaryStorage [{1}] for the migrate installPath[{2}]. Please clean it first by 'APICleanUpTrashOnPrimaryStorageMsg' if you insist to migrate the volume[{3}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/migration/SblkToSblkMigrateVolumeFlow.java:263
# args: volumeUuid,volumeVO.getActualSize(),dstPsInv.getAvailablePhysicalCapacity()
there\ are\ not\ enough\ capacity\ for\ volume[uuid\:\ %s]\ storage\ migration,\ required\ capacity\:\ %s,\ current\ available\ physical\ capacity\:\ %s = there are not enough capacity for volume[uuid: {0}] storage migration, required capacity: {1}, current available physical capacity: {2}

# at: src/main/java/org/zstack/storage/primary/sharedblock/migration/SblkToSblkMigrateVolumeFlow.java:194
# args: imageUuid,zoneUuid,zoneUuid
cannot\ find\ the\ image[uuid\:%s]\ in\ any\ connected\ backup\ storage\ attached\ to\ the\ zone[uuid\:%s].\ check\ below\:\n1.\ whether\ the\ backup\ storage\ is\ attached\ to\ the\ zone[uuid\:%s]\n2.\ whether\ the\ backup\ storage\ is\ in\ connected\ status;\ try\ to\ reconnect\ it\ if\ not = cannot find the image[uuid:{0}] in any connected backup storage attached to the zone[uuid:{1}]. check below:\n1. whether the backup storage is attached to the zone[uuid:{2}]\n2. whether the backup storage is in connected status; try to reconnect it if not

# at: src/main/java/org/zstack/storage/primary/sharedblock/migration/SblkToSblkMigrateVolumeFlow.java:217
# args: image.getUuid(),volumeUuid,image.getActualSize(),dstPsInv.getAvailablePhysicalCapacity()
there\ are\ not\ enough\ capacity\ for\ image[uuid\:\ %s]\ download\ while\ volume[uuid\:\ %s]\ storage\ migration,\ required\ capacity\:\ %s,\ current\ available\ physical\ capacity\:\ %s = there are not enough capacity for image[uuid: {0}] download while volume[uuid: {1}] storage migration, required capacity: {2}, current available physical capacity: {3}

# at: src/main/java/org/zstack/storage/primary/sharedblock/migration/SblkToSblkRollbackMigrateVolumeFlow.java:70
# args: srcPsUuid
data\ on\ source\ ps[uuid\:\ %s]\ has\ been\ discarded,\ not\ support\ rollback = data on source ps[uuid: {0}] has been discarded, not support rollback

# at: src/main/java/org/zstack/storage/primary/smp/KvmBackend.java:1673
# args: ret.firstAccessHostUuids
hosts[uuid\:%s]\ have\ the\ same\ mount\ path,\ but\ actually\ mount\ different\ storage. = hosts[uuid:{0}] have the same mount path, but actually mount different storage.

# at: src/main/java/org/zstack/storage/primary/smp/KvmBackend.java:1837
# args: msg.getHostUuid(),msg.getPrimaryStorageUuid()
host[uuid\:%s]\ might\ mount\ storage\ which\ is\ different\ from\ SMP[uuid\:%s],\ please\ check\ it = host[uuid:{0}] might mount storage which is different from SMP[uuid:{1}], please check it

# at: src/main/java/org/zstack/storage/primary/smp/SMPPrimaryStorageBase.java:497
# args: 
not\ supported\ operation = not supported operation

# at: src/main/java/org/zstack/storage/primary/smp/SMPPrimaryStorageFactory.java:106
# args: psUuid,vmUuid,volumeUuid
the\ SMP\ primary\ storage[uuid\:%s]\ is\ not\ attached\ to\ any\ clusters,\ and\ cannot\ expunge\ the\ root\ volume[uuid\:%s]\ of\ the\ VM[uuid\:%s] = the SMP primary storage[uuid:{0}] is not attached to any clusters, and cannot expunge the root volume[uuid:{1}] of the VM[uuid:{2}]

# at: src/main/java/org/zstack/storage/primary/smp/SMPPrimaryStorageFactory.java:300
# args: pri.getUuid()
cannot\ find\ a\ Connected\ host\ to\ execute\ command\ for\ smp\ primary\ storage[uuid\:%s] = cannot find a Connected host to execute command for smp primary storage[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/smp/SMPPrimaryStorageFactory.java:320
# args: pri.getUuid()
cannot\ find\ a\ host\ which\ has\ Connected\ host-SMP\ connection\ to\ execute\ command\ for\ smp\ primary\ storage[uuid\:%s] = cannot find a host which has Connected host-SMP connection to execute command for smp primary storage[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/smp/SharedMountPointApiInterceptor.java:25
# args: 
\ the\ url\ contains\ an\ invalid\ folder[/dev\ or\ /proc\ or\ /sys] =  the url contains an invalid folder[/dev or /proc or /sys]

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotApiInterceptor.java:88
# args: VmInstanceState.Running.toString(),VmInstanceState.Paused.toString()
Can\ not\ take\ memory\ snapshot,\ expected\ vm\ states\ are\ [%s,\ %s] = Can not take memory snapshot, expected vm states are [{0}, {1}]

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotApiInterceptor.java:155
# args: msg.getUuid(),state
volume\ snapshot[uuid\:%s]\ is\ in\ state\ %s,\ cannot\ revert\ volume\ to\ it = volume snapshot[uuid:{0}] is in state {1}, cannot revert volume to it

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotApiInterceptor.java:160
# args: msg.getUuid()
original\ volume\ for\ snapshot[uuid\:%s]\ has\ been\ deleted,\ cannot\ revert\ volume\ to\ it = original volume for snapshot[uuid:{0}] has been deleted, cannot revert volume to it

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotApiInterceptor.java:178
# args: msg.getVolumeUuid(),snapshotVO.getVolumeUuid()
not\ support\ delete\ snapshots\ on\ different\ volumes[uuid\:\ %s,\ %s] = not support delete snapshots on different volumes[uuid: {0}, {1}]

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotApiInterceptor.java:182
# args: msg.getUuids()
can\ not\ find\ volume\ uuid\ for\ snapshosts[uuid\:\ %s] = can not find volume uuid for snapshosts[uuid: {0}]

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotManagerImpl.java:521
# args: maxIncrementalSnapshotNum,vo.getVolumeUuid()
Unsupported\ maximum\ snapshot\ number\ (%d)\ for\ volume\ [uuid\:%s] = Unsupported maximum snapshot number ({0}) for volume [uuid:{1}]

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotManagerImpl.java:618
# args: vol.getUuid(),reply.getError()
cannot\ ask\ primary\ storage[uuid\:%s]\ for\ volume\ snapshot\ capability,\ see\ detail\ [%s] = cannot ask primary storage[uuid:{0}] for volume snapshot capability, see detail [{1}]

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotManagerImpl.java:814
# args: primaryStorageUuid,vol.getUuid()
primary\ storage[uuid\:%s]\ doesn't\ support\ volume\ snapshot;\ cannot\ create\ snapshot\ for\ volume[uuid\:%s] = primary storage[uuid:{0}] doesn't support volume snapshot; cannot create snapshot for volume[uuid:{1}]

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotManagerImpl.java:780
# args: vol.getPrimaryStorageUuid()
cannot\ find\ type\ for\ primaryStorage\ [%s] = cannot find type for primaryStorage [{0}]

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotManagerImpl.java:877
# args: uuid
cannot\ find\ snapshot\:\ %s = cannot find snapshot: {0}

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotTreeBase.java:153
# args: currentRoot.getUuid(),currentRoot.getName()
cannot\ find\ volume\ snapshot[uuid\:%s,\ name\:%s],\ it\ may\ have\ been\ deleted\ by\ previous\ operation = cannot find volume snapshot[uuid:{0}, name:{1}], it may have been deleted by previous operation

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotTreeBase.java:759
# args: failSnapshot.getUuid(),failSnapshot.getName(),evt
failed\ to\ change\ status\ of\ volume\ snapshot[uuid\:%s,\ name\:%s]\ by\ status\ event[%s] = failed to change status of volume snapshot[uuid:{0}, name:{1}] by status event[{2}]

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotTreeBase.java:1465
# args: volumeInventory.getUuid(),currentRoot.getUuid(),vmUuid,state
unable\ to\ reset\ volume[uuid\:%s]\ to\ snapshot[uuid\:%s],\ the\ vm[uuid\:%s]\ volume\ attached\ to\ is\ not\ in\ Stopped\ state,\ current\ state\ is\ %s = unable to reset volume[uuid:{0}] to snapshot[uuid:{1}], the vm[uuid:{2}] volume attached to is not in Stopped state, current state is {3}

# at: src/main/java/org/zstack/storage/snapshot/group/VolumeSnapshotGroupChecker.java:77
# args: String.join(", ", deletedSnapshotInfos)
snapshot(s)\ %s\ in\ the\ group\ has\ been\ deleted,\ can\ only\ revert\ one\ by\ one. = snapshot(s) {0} in the group has been deleted, can only revert one by one.

# at: src/main/java/org/zstack/storage/snapshot/group/VolumeSnapshotGroupChecker.java:81
# args: String.join(", ", detachedVolInfos)
volume(s)\ %s\ is\ no\ longer\ attached,\ can\ only\ revert\ one\ by\ one.\ If\ you\ need\ to\ group\ revert,\ please\ re-attach\ it. = volume(s) {0} is no longer attached, can only revert one by one. If you need to group revert, please re-attach it.

# at: src/main/java/org/zstack/storage/snapshot/group/VolumeSnapshotGroupChecker.java:89
# args: volInfos
new\ volume(s)\ %s\ attached\ after\ snapshot\ point,\ can\ only\ revert\ one\ by\ one.\ If\ you\ need\ to\ group\ revert,\ please\ detach\ it. = new volume(s) {0} attached after snapshot point, can only revert one by one. If you need to group revert, please detach it.

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:269
# args: 
Can't\ attach\ volume\ to\ VM,\ no\ qualified\ cluster = Can't attach volume to VM, no qualified cluster

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:137
# args: vol.getUuid(),vol.getStatus()
volume[uuid\:%s]\ is\ not\ in\ status\ Ready,\ current\ is\ %s,\ can't\ create\ snapshot = volume[uuid:{0}] is not in status Ready, current is {1}, can't create snapshot

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:113
# args: msg.getVolumeUuid(),type
volume[uuid\:%s,\ type\:%s],\ can't\ create\ snapshot = volume[uuid:{0}, type:{1}], can't create snapshot

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:127
# args: msg.getRootVolumeUuid()
volume[uuid\:%s]\ is\ root\ volume = volume[uuid:{0}] is root volume

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:131
# args: vmvo.getState().toString(),VmInstanceState.Running.toString(),VmInstanceState.Paused.toString()
Can\ not\ take\ memory\ snapshot,\ vm\ current\ state[%s],\ but\ expect\ state\ are\ [%s,\ %s] = Can not take memory snapshot, vm current state[{0}], but expect state are [{1}, {2}]

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:150
# args: msg.getVolumeUuid()
the\ volume[uuid\:%s]\ is\ not\ in\ status\ of\ deleted.\ This\ is\ operation\ is\ to\ recover\ a\ deleted\ data\ volume = the volume[uuid:{0}] is not in status of deleted. This is operation is to recover a deleted data volume

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:296
# args: vol.getUuid()
the\ volume[uuid\:%s]\ is\ in\ status\ of\ deleted,\ cannot\ do\ the\ operation = the volume[uuid:{0}] is in status of deleted, cannot do the operation

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:168
# args: msg.getImageUuid(),ImageMediaType.DataVolumeTemplate,type
image[uuid\:%s]\ is\ not\ %s,\ it's\ %s = image[uuid:{0}] is not {1}, it's {2}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:172
# args: img.getUuid(),img.getState()
image[uuid\:%s]\ is\ not\ Enabled,\ it's\ %s = image[uuid:{0}] is not Enabled, it's {1}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:176
# args: img.getUuid(),img.getStatus()
image[uuid\:%s]\ is\ not\ Ready,\ it's\ %s = image[uuid:{0}] is not Ready, it's {1}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:182
# args: 
DataVolumeFromVolumeTemplate\ not\ support\ Shareable = DataVolumeFromVolumeTemplate not support Shareable

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:197
# args: msg.getVolumeUuid()
volume[uuid\:%s]\ is\ Root\ volume,\ can\ not\ be\ attach\ to\ vm = volume[uuid:{0}] is Root volume, can not be attach to vm

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:204
# args: msg.getVolumeUuid(),state,VolumeState.Enabled
volume[uuid\:%s]\ is\ in\ state[%s],\ data\ volume\ can\ only\ be\ attached\ when\ state\ is\ %s = volume[uuid:{0}] is in state[{1}], data volume can only be attached when state is {2}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:209
# args: msg.getVolumeUuid(),status,VolumeStatus.Ready,VolumeStatus.NotInstantiated
volume[uuid\:%s]\ is\ in\ status[%s],\ data\ volume\ can\ only\ be\ attached\ when\ status\ is\ %s\ or\ %S = volume[uuid:{0}] is in status[{1}], data volume can only be attached when status is {2} or %S

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:216
# args: msg.getVolumeUuid()
data\ volume[uuid\:%s]\ is\ not\ attached\ to\ any\ vm,\ can't\ detach = data volume[uuid:{0}] is not attached to any vm, can't detach

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:220
# args: msg.getVolumeUuid()
to\ detach\ shareable\ data\ volume[uuid\:%s],\ vm\ uuid\ is\ needed. = to detach shareable data volume[uuid:{0}], vm uuid is needed.

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:225
# args: vol.getUuid(),vol.getName(),vol.getType()
the\ volume[uuid\:%s,\ name\:%s,\ type\:%s]\ can't\ detach\ it = the volume[uuid:{0}, name:{1}, type:{2}] can't detach it

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:282
# args: msg.getVmInstanceUuid(),msg.getVolumeUuid()
the\ vm[uuid\:%s]\ doesn't\ support\ to\ online\ attach\ volume[%s]\ on\ the\ basis\ of\ that\ the\ image\ platform\ type\ of\ the\ vm\ is\ other\  = the vm[uuid:{0}] doesn't support to online attach volume[{1}] on the basis of that the image platform type of the vm is other 

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:287
# args: vol.getUuid(),vol.getName()
the\ volume[uuid\:%s,\ name\:%s]\ is\ Root\ Volume,\ can't\ attach\ it = the volume[uuid:{0}, name:{1}] is Root Volume, can't attach it

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:292
# args: vol.getUuid()
data\ volume[uuid\:%s]\ is\ Disabled,\ can't\ attach = data volume[uuid:{0}] is Disabled, can't attach

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:300
# args: vol.getUuid()
data\ volume[uuid\:%s]\ has\ been\ attached\ to\ some\ vm,\ can't\ attach\ again = data volume[uuid:{0}] has been attached to some vm, can't attach again

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:305
# args: VolumeStatus.Ready,VolumeStatus.NotInstantiated,vol.getStatus()
data\ volume\ can\ only\ be\ attached\ when\ status\ is\ [%s,\ %s],\ current\ is\ %s = data volume can only be attached when status is [{0}, {1}], current is {2}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:313
# args: vol.getUuid(),vol.getFormat(),hvTypes,msg.getVmInstanceUuid(),hvType
data\ volume[uuid\:%s]\ has\ format[%s]\ that\ can\ only\ be\ attached\ to\ hypervisor[%s],\ but\ vm[uuid\:%s]\ has\ hypervisor\ type[%s].\ Can't\ attach = data volume[uuid:{0}] has format[{1}] that can only be attached to hypervisor[{2}], but vm[uuid:{3}] has hypervisor type[{4}]. Can't attach

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:326
# args: hvType,maxDataVolumeNum,count,msg.getVmInstanceUuid()
hypervisor[%s]\ only\ allows\ max\ %s\ data\ volumes\ to\ be\ attached\ to\ a\ single\ vm;\ there\ have\ been\ %s\ data\ volumes\ attached\ to\ vm[uuid\:%s] = hypervisor[{0}] only allows max {1} data volumes to be attached to a single vm; there have been {2} data volumes attached to vm[uuid:{3}]

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:338
# args: msg.getUuid()
it's\ not\ allowed\ to\ backup\ root\ volume,\ uuid\:%s = it's not allowed to backup root volume, uuid:{0}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:347
# args: 
unexpected\ disk\ size\ settings = unexpected disk size settings

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:365
# args: msg.getVolumeUuid(),type
volume[uuid\:%s,\ type\:%s]\ can't\ be\ deleted = volume[uuid:{0}, type:{1}] can't be deleted

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:370
# args: msg.getVolumeUuid()
volume[uuid\:%s]\ is\ already\ in\ status\ of\ deleted = volume[uuid:{0}] is already in status of deleted

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:384
# args: msg.getUuid()
it's\ not\ allowed\ to\ change\ state\ of\ root\ volume,\ uuid\:%s = it's not allowed to change state of root volume, uuid:{0}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:445
# args: msg.getVolumeUuid(),msg.getHostUuid(),hostStatus
can\ not\ attach\ volume[%s]\ to\ host[%s],\ because\ host[status\:%s]\ is\ not\ connected = can not attach volume[{0}] to host[{1}], because host[status:{2}] is not connected

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:467
# args: msg.getVolumeUuid(),msg.getHostUuid(),hostUuid
can\ not\ attach\ volume[%s]\ to\ host[%s],\ because\ volume\ is\ attaching\ to\ host[%s] = can not attach volume[{0}] to host[{1}], because volume is attaching to host[{2}]

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:471
# args: msg.getVolumeUuid(),msg.getHostUuid(),msg.getVolumeUuid(),mountPath,hostUuid
can\ not\ attach\ volume[%s]\ to\ host[%s],\ because\ the\ volume[%s]\ occupies\ the\ mount\ path[%s]\ on\ host[%s] = can not attach volume[{0}] to host[{1}], because the volume[{2}] occupies the mount path[{3}] on host[{4}]

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:481
# args: msg.getVolumeUuid(),msg.getHostUuid(),msg.getMountPath()
can\ not\ attach\ volume[%s]\ to\ host[%s],\ because\ the\ another\ volume\ occupies\ the\ mount\ path[%s] = can not attach volume[{0}] to host[{1}], because the another volume occupies the mount path[{2}]

# at: src/main/java/org/zstack/storage/volume/VolumeBase.java:687
# args: self.getUuid(),self.getName()
the\ volume[uuid\:%s,\ name\:%s]\ is\ not\ deleted\ yet,\ can't\ expunge\ it = the volume[uuid:{0}, name:{1}] is not deleted yet, can't expunge it

# at: src/main/java/org/zstack/storage/volume/VolumeManagerImpl.java:194
# args: template.getUuid(),template.getName()
the\ image[uuid\:%s,\ name\:%s]\ has\ been\ deleted\ on\ all\ backup\ storage = the image[uuid:{0}, name:{1}] has been deleted on all backup storage

# at: src/main/java/org/zstack/storage/volume/VolumeManagerImpl.java:211
# args: template.getUuid(),msg.getPrimaryStorageUuid()
cannot\ find\ a\ backup\ storage\ on\ which\ the\ image[uuid\:%s]\ is\ that\ satisfies\ all\ conditions\ of\:\ 1.\ has\ state\ Enabled\ 2.\ has\ status\ Connected.\ 3\ has\ attached\ to\ zone\ in\ which\ primary\ storage[uuid\:%s]\ is = cannot find a backup storage on which the image[uuid:{0}] is that satisfies all conditions of: 1. has state Enabled 2. has status Connected. 3 has attached to zone in which primary storage[uuid:{1}] is

# at: src/main/java/org/zstack/storage/volume/VolumeManagerImpl.java:695
# args: VolumeFactory.class.getSimpleName()
there\ should\ not\ be\ more\ than\ one\ %s\ implementation. = there should not be more than one {0} implementation.

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:77
# args: volumeUuid
volume[uuid\:%s]\ can\ not\ found = volume[uuid:{0}] can not found

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:84
# args: volumeUuid,volumeVOS.get(0).getUuid(),volumeVO.getVmInstanceUuid(),volumeVOS.get(0).getVmInstanceUuid()
not\ support\ take\ snapshots\ volume[uuid\:%s,\ uuid\:%s]\ on\ different\ vms[uuid\:%s,\ uuid\:%s] = not support take snapshots volume[uuid:{0}, uuid:{1}] on different vms[uuid:{2}, uuid:{3}]

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:91
# args: volumeUuid
volume[uuid\:%s]\ is\ not\ ready = volume[uuid:{0}] is not ready

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:106
# args: vmInstanceVO.getUuid(),vmInstanceVO.getState()
state\ of\ vm[uuid\:\ %s]\ is\ %s,\ not\ allowed\ to\ take\ snapshots = state of vm[uuid: {0}] is {1}, not allowed to take snapshots

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:142
# args: msg.getUuid()
volume[uuid\:%s]\ is\ not\ data\ volume = volume[uuid:{0}] is not data volume

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:162
# args: msg.getUuid()
volume[uuid\:%s]\ is\ not\ root\ volume = volume[uuid:{0}] is not root volume

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:174
# args: 
SharedVolume\ cannot\ be\ set\ bandwidth. = SharedVolume cannot be set bandwidth.

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:182
# args: vo.getType(),vo.getUuid()
Cannot\ shrink\ [%s]\ volume[uuid\:%s]'s\ size = Cannot shrink [{0}] volume[uuid:{1}]'s size

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:189
# args: 
Minimum\ increase\ size\ should\ be\ larger\ than\ 4MB = Minimum increase size should be larger than 4MB

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:213
# args: 
Expansion\ operation\ not\ allowed\ at\ all\ host\ disable = Expansion operation not allowed at all host disable

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:200
# args: 
Expansion\ operation\ not\ allowed\ at\ host\ disable = Expansion operation not allowed at host disable

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:239
# args: vo.getUuid(),notStoppedVmUuids
shared\ volume[uuid\:\ %s]\ has\ attached\ to\ not\ stopped\ vm\ instances[uuids\:\ %s] = shared volume[uuid: {0}] has attached to not stopped vm instances[uuids: {1}]

# at: src/main/java/org/zstack/tag/TagApiInterceptor.java:56
# args: msg.getResourceType()
no\ resource\ type[%s]\ found\ in\ tag\ system = no resource type[{0}] found in tag system

# at: src/main/java/org/zstack/tag/TagApiInterceptor.java:74
# args: msg.getUuid()
tag[uuid\:%s]\ is\ an\ inherent\ system\ tag,\ can\ not\ be\ removed = tag[uuid:{0}] is an inherent system tag, can not be removed

# at: src/main/java/org/zstack/tag/TagApiInterceptor.java:100
# args: 
The\ argument\ \:'resourceType'\ doesn't\ match\ uuid = The argument :'resourceType' doesn't match uuid

# at: src/main/java/org/zstack/tag/TagManagerImpl.java:207
# args: tag,type,resourceType,resourceUuid
Duplicated\ Tag[tag\:%s,\ type\:%s,\ resourceType\:%s,\ resourceUuid\:%s] = Duplicated Tag[tag:{0}, type:{1}, resourceType:{2}, resourceUuid:{3}]

# at: src/main/java/org/zstack/tag/TagManagerImpl.java:645
# args: tag,resourceType
no\ system\ tag\ matches[%s]\ for\ resourceType[%s] = no system tag matches[{0}] for resourceType[{1}]

# at: src/main/java/org/zstack/tag/TagManagerImpl.java:818
# args: tag
no\ system\ tag\ matches\ %s = no system tag matches {0}

# at: src/main/java/org/zstack/tag/TagManagerImpl.java:847
# args: tag
tag[%s]\ is\ only\ for\ admin = tag[{0}] is only for admin

# at: src/main/java/org/zstack/tag2/Tag2ApiInterceptor.java:85
# args: 
cannot\ update\ simple\ tag\ pattern\ format = cannot update simple tag pattern format

# at: src/main/java/org/zstack/tag2/Tag2ApiInterceptor.java:83
# args: 
you\ can\ only\ update\ token\ name = you can only update token name

# at: src/main/java/org/zstack/tag2/Tag2ApiInterceptor.java:95
# args: 
simple\ tag\ pattern\ has\ no\ tokens = simple tag pattern has no tokens

# at: src/main/java/org/zstack/tag2/Tag2ApiInterceptor.java:122
# args: sub
illegal\ tag\ uuids\ %s,\ tag\ type\ must\ be\ simple, = illegal tag uuids {0}, tag type must be simple,

# at: src/main/java/org/zstack/tag2/Tag2ApiInterceptor.java:133
# args: color
Invalid\ color\ specification[%s],\ must\ like\ #FF00FF = Invalid color specification[{0}], must like #FF00FF

# at: src/main/java/org/zstack/tag2/Tag2ApiInterceptor.java:139
# args: format
Get\ format[%s],\ format\ must\ like\ that\ name\:\:{tokenName1}\:\:{tokenName2}\ ...\ \:\:{tokenNameN}\ or\ {tokenName1}\:\:{tokenName2}\ ...\ \:\:{tokenNameN}\ Name\ cannot\ contain\ '{}\:' = Get format[{0}], format must like that name::'{tokenName1}'::'{tokenName2}' ... ::'{tokenNameN}' or '{tokenName1}'::'{tokenName2}' ... ::'{tokenNameN}' Name cannot contain ''{}':'

# at: src/main/java/org/zstack/tag2/Tag2ApiInterceptor.java:151
# args: formatTokens
all\ tokens\ %s\ must\ be\ specify = all tokens {0} must be specify

# at: src/main/java/org/zstack/tag2/Tag2ApiInterceptor.java:162
# args: invalidUuids,expectAccountUuid
resource[uuids\:%s]\ is\ not\ owned\ by\ account[uuid\:%s] = resource[uuids:{0}] is not owned by account[uuid:{1}]

# at: src/main/java/org/zstack/tag2/TagPatternBase.java:184
# args: resourceUuid,attachedCount
resource[uuid\:%s]\ has\ been\ attached\ %d\ tags,\ cannot\ attach\ any\ more = resource[uuid:{0}] has been attached {1} tags, cannot attach any more

# at: src/main/java/org/zstack/templateConfig/TemplateConfigFacadeImpl.java:88
# args: msg.getCategory(),msg.getName(),msg.getTemplateUuid()
Unable\ to\ find\ TemplateConfig[category\:\ %s,\ name\:\ %s,\ templateUuid\:\ %s] = Unable to find TemplateConfig[category: {0}, name: {1}, templateUuid: {2}]

# at: src/main/java/org/zstack/ticket/TicketBase.java:239
# args: self.getUuid(),self.getName(),self.getStatus()
ticket[uuid\:%s,\ name\:%s]\ can\ only\ be\ updated\ after\ being\ cancelled,\ current\ status\ is\ %s = ticket[uuid:{0}, name:{1}] can only be updated after being cancelled, current status is {2}

# at: src/main/java/org/zstack/ticket/TicketBase.java:293
# args: operator.operatorUuid
operation\ denied.\ the\ operator\ needs\ to\ be\ done\ by\ account/virtual\ ID[uuid\:%s] = operation denied. the operator needs to be done by account/virtual ID[uuid:{0}]

# at: src/main/java/org/zstack/ticket/api/TicketApiInterceptor.java:97
# args: msg.getFlowCollectionUuid()
Ticket\ flow\ collection[uuid\:%s]\ is\ invalid,\ contact\ admin\ to\ correct\ it = Ticket flow collection[uuid:{0}] is invalid, contact admin to correct it

# at: src/main/java/org/zstack/ticket/api/TicketApiInterceptor.java:102
# args: msg.getFlowCollectionUuid()
Ticket\ flow\ collection[uuid\:%s]\ is\ disable,\ can\ not\ be\ used = Ticket flow collection[uuid:{0}] is disable, can not be used

# at: src/main/java/org/zstack/ticket/api/TicketApiInterceptor.java:68
# args: msg.getAccountSystemType()
no\ accountSystemType[%s]\ defined\ in\ system = no accountSystemType[{0}] defined in system

# at: src/main/java/org/zstack/ticket/api/TicketApiInterceptor.java:74
# args: 
not\ matched\ ticket\ type\ found = not matched ticket type found

# at: src/main/java/org/zstack/ticket/api/TicketApiInterceptor.java:90
# args: msg.getFlowCollectionUuid(),ticketTypeUuid
Ticket\ flow\ collection[uuid\:%s]\ not\ matches\ ticket\ type[uuid\:%s] = Ticket flow collection[uuid:{0}] not matches ticket type[uuid:{1}]

# at: src/main/java/org/zstack/ticket/api/TicketApiInterceptor.java:83
# args: 
no\ matched\ ticket\ flow\ collection\ or\ no\ default\ ticket\ flow\ collection\ found,\ you\ must\ specify\ the\ flowCollectionUuid\ or\ create\ a\ default\ ticket\ flow\ collection\ in\ system = no matched ticket flow collection or no default ticket flow collection found, you must specify the flowCollectionUuid or create a default ticket flow collection in system

# at: src/main/java/org/zstack/ticket/api/TicketApiInterceptor.java:110
# args: req.apiName
invalid\ request.\ no\ API[%s]\ found = invalid request. no API[{0}] found

# at: src/main/java/org/zstack/ticket/api/TicketApiInterceptor.java:118
# args: clz,e.getMessage()
invalid\ request,\ cannot\ create\ API[%s]\ from\ apiBody,\ %s = invalid request, cannot create API[{0}] from apiBody, {1}

# at: src/main/java/org/zstack/ticket/entity/TicketStatus.java:48
# args: this,event
operation\ denied.\ the\ ticket\ is\ in\ status\ of\ %s,\ cannot\ do\ the\ operation[%s] = operation denied. the ticket is in status of {0}, cannot do the operation[{1}]

# at: src/main/java/org/zstack/ticket/executor/DefaultSingletonRequestExecutor.java:43
# args: request.apiName
No\ api\ class[name\:%s]\ is\ found = No api class[name:{0}] is found

# at: src/main/java/org/zstack/ticket/executor/DefaultSingletonRequestExecutor.java:70
# args: exception.getMessage()
failed\ to\ get\ value\ from\ event\:\ %s = failed to get value from event: {0}

# at: src/main/java/org/zstack/ticket/iam2/IAM2Ticket.java:44
# args: ctx.getVirtualIDUuid(),self.getUuid(),self.getName()
operation\ denied\ because\ the\ ticket\ submitter[uuid\:%s]\ has\ been\ deleted,\ the\ ticket[uuid\:%s,\ name\:%s]\ can\ only\ be\ deleted\ now = operation denied because the ticket submitter[uuid:{0}] has been deleted, the ticket[uuid:{1}, name:{2}] can only be deleted now

# at: src/main/java/org/zstack/ticket/iam2/IAM2Ticket.java:49
# args: ctx.getProjectUuid(),self.getUuid(),self.getName()
operation\ denied\ because\ the\ project[uuid\:%s]\ of\ the\ ticket\ has\ been\ deleted,\ the\ ticket[uuid\:%s,\ name\:%s]\ can\ only\ be\ deleted\ now = operation denied because the project[uuid:{0}] of the ticket has been deleted, the ticket[uuid:{1}, name:{2}] can only be deleted now

# at: src/main/java/org/zstack/ticket/iam2/IAM2Ticket.java:61
# args: 
operation\ denied\ because\ flow\ collection[uuid\:%s]\ it\ not\ belong\ the\ project[uuid\:%s] = operation denied because flow collection[uuid:{0}] it not belong the project[uuid:{1}]

# at: src/main/java/org/zstack/ticket/iam2/IAM2Ticket.java:73
# args: msg.getSession().getUserUuid(),self.getUuid(),self.getName()
the\ virtual\ ID[uuid\:%s]\ is\ not\ the\ owner\ of\ the\ ticket[uuid\:%s,\ name\:%s] = the virtual ID[uuid:{0}] is not the owner of the ticket[uuid:{1}, name:{2}]

# at: src/main/java/org/zstack/ticket/iam2/IAM2TicketManager.java:194
# args: 
approver\ is\ removed\ from\ project\ or\ deleted,\ flow\ collection\ changed\ to\ invalid,\ reject\ this\ ticket = approver is removed from project or deleted, flow collection changed to invalid, reject this ticket

# at: src/main/java/org/zstack/ticket/iam2/api/IAM2TicketApiInterceptor.java:118
# args: 
at\ least\ one\ flow\ is\ needed\ for\ create\ flow\ collection = at least one flow is needed for create flow collection

# at: src/main/java/org/zstack/ticket/iam2/api/IAM2TicketApiInterceptor.java:125
# args: flow.approverTitle,approveTitles
wrong\ approver\ title\ %s,\ valid\ value\ is\ %s = wrong approver title {0}, valid value is {1}

# at: src/main/java/org/zstack/ticket/iam2/api/IAM2TicketApiInterceptor.java:141
# args: flow.approverUuid
can\ not\ find\ IAM2VirtualIDVO[uuid\:%s] = can not find IAM2VirtualIDVO[uuid:{0}]

# at: src/main/java/org/zstack/ticket/iam2/api/IAM2TicketApiInterceptor.java:64
# args: 
name\ is\ needed\ when\ create\ a\ flow = name is needed when create a flow

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotTreeBase.java:427
# args: currentRoot.getPrimaryStorageUuid(),currentLeaf.getUuid(),Math.abs(requiredSize - primaryStorageVO.getCapacity().getAvailablePhysicalCapacity())
primaryStorage[uuid\:%s]\ has\ no\ enough\ space\ to\ rebase\ snapshot[uuid\:%s],\ please\ free\ more\ than\ %s\ bytes\ storage\ space = primaryStorage[uuid:{0}] has no enough space to rebase snapshot[uuid:{1}], please free more than {2} bytes storage space

# at: src/main/java/org/zstack/ticket/iam2/api/IAM2TicketApiInterceptor.java:81
# args: 
one\ ticket\ type\ can\ only\ have\ one\ matches\ flow\ collection = one ticket type can only have one matches flow collection

# at: src/main/java/org/zstack/ticket/iam2/api/IAM2TicketApiInterceptor.java:103
# args: 
admin\ is\ required\ as\ approver\ of\ the\ last\ flow = admin is required as approver of the last flow

# at: src/main/java/org/zstack/ticket/iam2/api/IAM2TicketApiInterceptor.java:129
# args: 
name\ cannot\ be\ null = name cannot be null

# at: src/main/java/org/zstack/ticket/iam2/api/IAM2TicketApiInterceptor.java:133
# args: 
approverUuid\ cannot\ be\ null = approverUuid cannot be null

# at: src/main/java/org/zstack/ticket/iam2/api/IAM2TicketApiInterceptor.java:148
# args: flow.approverUuid,projectUuid
virtual\ id[uuid\:%s]\ not\ belong\ to\ project[uuid\:%s] = virtual id[uuid:{0}] not belong to project[uuid:{1}]

# at: src/main/java/org/zstack/twoFactorAuthentication/TwoFactorAuthenticationManagerImpl.java:118
# args: 
two\ factor\ authenticator\ is\ not\ enabled = two factor authenticator is not enabled

# at: src/main/java/org/zstack/usbDevice/KvmUsbDeviceBackend/UsbDeviceKvmBackend.java:269
# args: usbInv.getHostUuid()
host[%s]\ has\ started\ more\ than\ 64\ usb\ redirect\ port = host[{0}] has started more than 64 usb redirect port

# at: src/main/java/org/zstack/usbDevice/KvmUsbDeviceBackend/UsbDeviceKvmBackend.java:274
# args: host.getUuid()
unable\ to\ start\ usb\ server\ on\ host[%s],\ because\ host\ is\ not\ connected = unable to start usb server on host[{0}], because host is not connected

# at: src/main/java/org/zstack/usbDevice/KvmUsbDeviceBackend/UsbDeviceKvmBackend.java:296
# args: usbInv.getHostUuid()
failed\ to\ start\ usbredirect\ server\ from\ host[uuid\:%s] = failed to start usbredirect server from host[uuid:{0}]

# at: src/main/java/org/zstack/usbDevice/UsbDeviceAllocatorFactory.java:83
# args: 
no\ candidate\ host\ with\ the\ usb\ device\ have\ enough\ cpu\ /\ memory\ or\ Enabled/Connected\ status = no candidate host with the usb device have enough cpu / memory or Enabled/Connected status

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:59
# args: msg.getUsbDeviceUuid(),usb.getVmInstanceUuid()
the\ usb\ device[uuid\:%s]\ has\ already\ been\ attached\ to\ another\ vm[uuid\:%s] = the usb device[uuid:{0}] has already been attached to another vm[uuid:{1}]

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:66
# args: msg.getUsbDeviceUuid(),UsbDeviceState.Enabled
the\ usb\ device[uuid\:%s]\ is\ not\ in\ attachable\ state\ of\ %s = the usb device[uuid:{0}] is not in attachable state of {1}

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:74
# args: msg.getVmInstanceUuid(),allowedVmInstanceAttachableState
the\ vm\ instance[uuid\:%s]\ is\ not\ in\ attachable\ state\ of\ %s\ for\ usb\ device = the vm instance[uuid:{0}] is not in attachable state of {1} for usb device

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:84
# args: usb.getHostUuid(),msg.getUsbDeviceUuid(),HostState.Enabled,HostStatus.Connected
the\ host\ that\ the\ usb\ device[uuid\:%s]\ pluged\ in\ is\ not\ in\ valid\ state[%s]\ or\ status[%s] = the host that the usb device[uuid:{0}] pluged in is not in valid state[{1}] or status[{2}]

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:97
# args: usb.getUuid(),vm.getUuid()
the\ usb\ device[uuid\:%s]\ has\ different\ hostUuid\ than\ devices\ that\ already\ attached\ to\ the\ vm\ instance[uuid\:%s] = the usb device[uuid:{0}] has different hostUuid than devices that already attached to the vm instance[uuid:{1}]

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:109
# args: usb.getUuid()
the\ usb\ device[uuid\:%s]\ is\ not\ attached\ to\ any\ vm\ instance. = the usb device[uuid:{0}] is not attached to any vm instance.

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:117
# args: usb.getUuid(),allowedVmInstanceDetachableState
the\ vm\ instance\ that\ the\ usb\ device[uuid\:%s]\ is\ attached\ to\ is\ not\ in\ detachable\ state\ of\ %s = the vm instance that the usb device[uuid:{0}] is attached to is not in detachable state of {1}

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:127
# args: vm.getUuid(),allowedVmInstanceAttachableState
vm\ instance[uuid\:%s]\ not\ in\ attachable\ state\ of\ %s\ for\ usb\ device = vm instance[uuid:{0}] not in attachable state of {1} for usb device

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:138
# args: msg.getUuid()
cannot\ disable\ usb\ device[uuid\:%s]\ when\ it's\ attached\ to\ a\ vm\ instance = cannot disable usb device[uuid:{0}] when it's attached to a vm instance

# at: src/main/java/org/zstack/usbDevice/UsbDeviceManager.java:711
# args: msg.getVmInstanceUuid()
cannot\ migrate\ vm[uuid\:%s]\ because\ there\ are\ pci\ devices\ attached = cannot migrate vm[uuid:{0}] because there are pci devices attached

# at: src/main/java/org/zstack/usbDevice/UsbDeviceManager.java:202
# args: UsbDeviceConstants.MAX_USB_1_DEVICE_PER_VM
You\ can\ attach\ at\ most\ %s\ USB\ 1.0\ devices\ to\ one\ vm\ instance. = You can attach at most {0} USB 1.0 devices to one vm instance.

# at: src/main/java/org/zstack/usbDevice/UsbDeviceManager.java:217
# args: UsbDeviceConstants.MAX_USB_2_DEVICE_PER_VM
You\ can\ attach\ at\ most\ %s\ USB\ 2.0\ devices\ to\ one\ vm\ instance. = You can attach at most {0} USB 2.0 devices to one vm instance.

# at: src/main/java/org/zstack/usbDevice/UsbDeviceManager.java:232
# args: UsbDeviceConstants.MAX_USB_3_DEVICE_PER_VM
You\ can\ attach\ at\ most\ %s\ USB\ 3.0\ devices\ to\ one\ vm\ instance. = You can attach at most {0} USB 3.0 devices to one vm instance.

# at: src/main/java/org/zstack/usbDevice/UsbDeviceManager.java:160
# args: 
PassThrough\ only\ support\ use\ on\ vm\ running\ host = PassThrough only support use on vm running host

# at: src/main/java/org/zstack/usbDevice/UsbDeviceManager.java:177
# args: msg.getUsbDeviceUuid(),msg.getVmInstanceUuid()
cannot\ attach\ the\ usb\ device[uuid\:%s]\ to\ vm[uuid\:%s]\ due\ to\ host\ allocation = cannot attach the usb device[uuid:{0}] to vm[uuid:{1}] due to host allocation

# at: src/main/java/org/zstack/usbDevice/UsbDeviceManager.java:647
# args: msg.getVmInstanceUuid()
vm[%s]\ cannot\ start\ because\ usb\ redirect\ host\ is\ not\ connected = vm[{0}] cannot start because usb redirect host is not connected

# at: src/main/java/org/zstack/usbDevice/UsbDeviceManager.java:660
# args: msg.getVmInstanceUuid()
cannot\ migrate\ vm[uuid\:%s]\ because\ there\ are\ usb\ devices\ attached\ by\ passthrough = cannot migrate vm[uuid:{0}] because there are usb devices attached by passthrough

# at: src/main/java/org/zstack/usbDevice/UsbDeviceManager.java:693
# args: msg.getVolumeUuid()
cannot\ migrate\ root\ volume[uuid\:%s]\ because\ there\ are\ usb\ devices\ attached = cannot migrate root volume[uuid:{0}] because there are usb devices attached

# at: src/main/java/org/zstack/v2v/CleanConversionVolumeCacheGC.java:43
# args: 
not\ the\ time\ to\ clean = not the time to clean

# at: src/main/java/org/zstack/v2v/CleanConversionVolumeCacheGC.java:48
# args: conversionHost.getUuid(),conversionHost.getHostUuid()
conversionHost[uuid\:%s,\ hostUuid\:%s]\ is\ not\ Connected = conversionHost[uuid:{0}, hostUuid:{1}] is not Connected

# at: src/main/java/org/zstack/v2v/ResumeConvertVmJobGC.java:126
# args: hostUuid
host[uuid\:%s]\ is\ not\ Connected = host[uuid:{0}] is not Connected

# at: src/main/java/org/zstack/v2v/ResumeConvertVmJobGC.java:130
# args: primaryStorageUuid
primaryStorage[uuid%s]\ is\ not\ Connected = primaryStorage[uuid{0}] is not Connected

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:186
# args: duplicateMac.get()
Not\ allowed\ same\ mac\ [%s] = Not allowed same mac [{0}]

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:205
# args: duplicateElements.get(0)
Can't\ add\ same\ uuid\ in\ the\ l3Network,uuid\:\ %s = Can't add same uuid in the l3Network,uuid: {0}

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:252
# args: msg.getZoneUuid()
zone[uuid\:%s]\ is\ specified\ but\ it's\ Disabled,\ can\ not\ create\ vm\ from\ it = zone[uuid:{0}] is specified but it's Disabled, can not create vm from it

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:262
# args: msg.getClusterUuid()
cluster[uuid\:%s]\ is\ specified\ but\ it's\ Disabled,\ can\ not\ create\ vm\ from\ it = cluster[uuid:{0}] is specified but it's Disabled, can not create vm from it

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:273
# args: msg.getHostUuid()
host[uuid\:%s]\ is\ specified\ but\ it's\ Disabled,\ can\ not\ create\ vm\ from\ it = host[uuid:{0}] is specified but it's Disabled, can not create vm from it

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:278
# args: msg.getHostUuid(),connectionState
host[uuid\:%s]\ is\ specified\ but\ it's\ connection\ status\ is\ %s,\ can\ not\ create\ vm\ from\ it = host[uuid:{0}] is specified but it's connection status is {1}, can not create vm from it

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:234
# args: msg.getDefaultL3NetworkUuid(),msg.getL3NetworkUuids()
defaultL3NetworkUuid[uuid\:%s]\ is\ not\ in\ l3NetworkUuids%s = defaultL3NetworkUuid[uuid:{0}] is not in l3NetworkUuids{1}

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:76
# args: msg.getHostUuid()
host[uuid\:%s]\ must\ be\ Enabled\ and\ Connected\ to\ be\ a\ conversion\ host = host[uuid:{0}] must be Enabled and Connected to be a conversion host

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:89
# args: 
v2v\ conversion\ host\ storage\ path\ must\ be\ absolute\ path = v2v conversion host storage path must be absolute path

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:112
# args: msg.getUrl()
invalid\ v2v\ url\:\ %s = invalid v2v url: {0}

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:123
# args: srcVmUuid
vm\ instance[uuid\:%s]\ does\ not\ exist\ or\ is\ not\ a\ vmware\ vm = vm instance[uuid:{0}] does not exist or is not a vmware vm

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:130
# args: 
conversionHostUuid\ should\ not\ be\ null = conversionHostUuid should not be null

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:136
# args: msg.getConversionHostUuid()
conversion\ host[uuid\:%s]\ should\ be\ Enabled = conversion host[uuid:{0}] should be Enabled

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:148
# args: msg.getConversionHostUuid()
underlying\ host\ of\ conversion\ host[uuid\:%s]\ should\ be\ Connected = underlying host of conversion host[uuid:{0}] should be Connected

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:164
# args: msg.getConversionHostUuid(),msg.getPrimaryStorageUuid()
conversion\ host[uuid\:%s]\ cannot\ connect\ to\ primary\ storage[uuid\:%s] = conversion host[uuid:{0}] cannot connect to primary storage[uuid:{1}]

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:197
# args: duplicateMacs
Duplicate\ mac\ address\ %s = Duplicate mac address {0}

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:289
# args: msg.getPrimaryStorageUuid()
primary\ storage[uuid\:%s]\ is\ not\ supported\ for\ v2v = primary storage[uuid:{0}] is not supported for v2v

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:292
# args: msg.getPrimaryStorageUuid()
primary\ storage[uuid\:%s]\ is\ neither\ Enabled\ nor\ Connected = primary storage[uuid:{0}] is neither Enabled nor Connected

# at: src/main/java/org/zstack/v2v/V2VManagerImpl.java:577
# args: l3Uuid
Unable\ to\ find\ L3Network[uuid\:%s]\ to\ start\ the\ current\ vm,\ it\ may\ have\ been\ deleted,\ Operation\ suggestion\:\ delete\ this\ vm,\ recreate\ a\ new\ vm = Unable to find L3Network[uuid:{0}] to start the current vm, it may have been deleted, Operation suggestion: delete this vm, recreate a new vm

# at: src/main/java/org/zstack/v2v/V2VManagerImpl.java:1150
# args: bandwidth
invalid\ network\ bandwidth[%s],\ it\ is\ not\ a\ number = invalid network bandwidth[{0}], it is not a number

# at: src/main/java/org/zstack/v2v/V2VManagerImpl.java:1145
# args: bandwidth
invalid\ network\ bandwidth[%s],\ it\ must\ be\ greater\ than\ or\ equal\ to\ 8192 = invalid network bandwidth[{0}], it must be greater than or equal to 8192

# at: src/main/java/org/zstack/v2v/V2VManagerImpl.java:1147
# args: 
networkInboundBandwidth\ execeds\ the\ max\ value\ 32G\ bps = networkInboundBandwidth execeds the max value 32G bps

# at: src/main/java/org/zstack/v2v/V2VManagerImpl.java:624
# args: msg.getUrl()
can\ not\ find\ type\ for\ src\ vm[url\:%s] = can not find type for src vm[url:{0}]

# at: src/main/java/org/zstack/v2v/V2VManagerImpl.java:638
# args: msg.getUrl(),msg.getType()
can\ not\ find\ factory\ for\ src\ vm[url\:%s,\ v2vType\:%s] = can not find factory for src vm[url:{0}, v2vType:{1}]

# at: src/main/java/org/zstack/v2v/V2VManagerImpl.java:898
# args: msg.getHostUuid()
there\ has\ been\ a\ v2v\ conversion\ host\ with\ hostUuid\ %s = there has been a v2v conversion host with hostUuid {0}

# at: src/main/java/org/zstack/v2v/V2VManagerImpl.java:1139
# args: 
invalid\ v2v\ qos\ systemtag = invalid v2v qos systemtag

# at: src/main/java/org/zstack/v2v/kvm/KVMV2VBase.java:863
# args: srcVmUuid
No\ root\ volume\ found\ for\ VM\:\ %s = No root volume found for VM: {0}

# at: src/main/java/org/zstack/v2v/vmware/VMwareV2VBase.java:189
# args: job.getUuid()
v2v\ job[uuid\:%s]\ is\ running = v2v job[uuid:{0}] is running

# at: src/main/java/org/zstack/v2v/vmware/VMwareV2VBase.java:788
# args: srcVmUrl
failed\ to\ get\ virt-v2v\ uri\ for\ %s = failed to get virt-v2v uri for {0}

# at: src/main/java/org/zstack/v2v/vmware/VMwareV2VBase.java:953
# args: urlBuilder.toString()
Failed\ to\ parse\ url\ %s = Failed to parse url {0}

# at: src/main/java/org/zstack/v2v/vmware/VMwareV2VBase.java:1231
# args: NOT_SUPPORTED_SPECIAL_CHARACTER
Target\ vm\ name\ can\ not\ contain\ those\ characters\ %s = Target vm name can not contain those characters {0}

# at: src/main/java/org/zstack/v2v/vmware/VMwareV2VFactory.java:120
# args: jobUuid,msg.getUrl()
There\ is\ already\ a\ long\ job[uuid\:%s]\ convert\ vm\ from\ %s = There is already a long job[uuid:{0}] convert vm from {1}

# at: src/main/java/org/zstack/v2v/vmware/VMwareV2VFactory.java:145
# args: 
Failed\ to\ update\ conversion\ host\ dependency = Failed to update conversion host dependency

# at: src/main/java/org/zstack/vmware/ESXHost.java:151
# args: 
host\ is\ not\ connected = host is not connected

# at: src/main/java/org/zstack/vmware/ESXHost.java:329
# args: vmUuid,self.getUuid()
vmUuid\ [%s]\ not\ found\ in\ ESX\ host\ [%s] = vmUuid [{0}] not found in ESX host [{1}]

# at: src/main/java/org/zstack/vmware/ESXHost.java:673
# args: vmUuid
VM\ not\ found\:\ %s = VM not found: {0}

# at: src/main/java/org/zstack/vmware/ESXHost.java:602
# args: vmUuid,VMwareHelper.exStr(ex)
failed\ to\ suspend\ VM\ [%s]\:\ %s = failed to suspend VM [{0}]: {1}

# at: src/main/java/org/zstack/vmware/ESXHost.java:598
# args: t.getTaskInfo().getError().getLocalizedMessage()
failed\ to\ suspend\ VM,\ task\ status\:\ %s = failed to suspend VM, task status: {0}

# at: src/main/java/org/zstack/vmware/ESXHost.java:636
# args: vmUuid,VMwareHelper.exStr(ex)
failed\ to\ resume\ VM\ [%s]\:\ %s = failed to resume VM [{0}]: {1}

# at: src/main/java/org/zstack/vmware/ESXHost.java:632
# args: t.getTaskInfo().getError().getLocalizedMessage()
failed\ to\ resume\ VM,\ task\ status\:\ %s = failed to resume VM, task status: {0}

# at: src/main/java/org/zstack/vmware/ESXHost.java:704
# args: vmUuid,VMwareHelper.exStr(ex)
failed\ to\ shutdown\ guest\:\ %s,\ %s = failed to shutdown guest: {0}, {1}

# at: src/main/java/org/zstack/vmware/ESXHost.java:1314
# args: vmInv.getInstanceOfferingUuid()
instance\ uuid\ [%s]\ not\ found = instance uuid [{0}] not found

# at: src/main/java/org/zstack/vmware/ESXHost.java:1324
# args: vmInv.getImageUuid()
Image\ [%s]\ not\ found = Image [{0}] not found

# at: src/main/java/org/zstack/vmware/ESXHost.java:1423
# args: vmUuid
VM\ [%s]\ not\ found\ in\ vCenter = VM [{0}] not found in vCenter

# at: src/main/java/org/zstack/vmware/ESXHost.java:1592
# args: t.getTaskInfo().getError().getLocalizedMessage()
failed\ to\ power\ on\ VM,\ task\ status\:\ %s = failed to power on VM, task status: {0}

# at: src/main/java/org/zstack/vmware/VCenterApiInterceptor.java:47
# args: 
vCenter\ login\ name\ expected. = vCenter login name expected.

# at: src/main/java/org/zstack/vmware/VCenterApiInterceptor.java:51
# args: msg.getDomainName()
domainName[%s]\ is\ neither\ an\ IPv4\ address\ nor\ a\ valid\ hostname = domainName[{0}] is neither an IPv4 address nor a valid hostname

# at: src/main/java/org/zstack/vmware/VCenterApiInterceptor.java:57
# args: msg.getDomainName()
vCenter\ [domainName\:%s]\ has\ been\ added = vCenter [domainName:{0}] has been added

# at: src/main/java/org/zstack/vmware/VCenterApiInterceptor.java:94
# args: clusterUuid,l2uuid
Cluster[uuid\:%s]\ and\ L2[uuid\:%s]\ belongs\ to\ different\ DCs = Cluster[uuid:{0}] and L2[uuid:{1}] belongs to different DCs

# at: src/main/java/org/zstack/vmware/VCenterApiInterceptor.java:106
# args: clusterUuid
No\ hosts\ found\ within\ cluster\:\ %s = No hosts found within cluster: {0}

# at: src/main/java/org/zstack/vmware/VCenterApiInterceptor.java:139
# args: phyinf,phyinf
vSwitch/dvSwitch\ not\ found\:\ %s,\ or\ vSwitch\:\ %s\ on\ different\ ESX\ host\ doesn't\ has\ same\ portgroup = vSwitch/dvSwitch not found: {0}, or vSwitch: {1} on different ESX host doesn't has same portgroup

# at: src/main/java/org/zstack/vmware/VCenterApiInterceptor.java:153
# args: l2uuid,vcvo.getUuid(),clusterUuid
L2[uuid\:%s]\ doesn't\ belong\ to\ vCenter[uuid\:%s]\ cluster[uuid\:%s] = L2[uuid:{0}] doesn't belong to vCenter[uuid:{1}] cluster[uuid:{2}]

# at: src/main/java/org/zstack/vmware/VCenterBackupStorage.java:60
# args: bsUuid
No\ data-store\ attached\ to\ %s = No data-store attached to {0}

# at: src/main/java/org/zstack/vmware/VCenterBackupStorage.java:65
# args: bsUuid
Data-store\ not\ found\ for\ %s = Data-store not found for {0}

# at: src/main/java/org/zstack/vmware/VCenterBackupStorage.java:93
# args: url.getProtocol()
unexpected\ protocol\:\ %s = unexpected protocol: {0}

# at: src/main/java/org/zstack/vmware/VCenterBackupStorage.java:99
# args: iinv.getName()
%s\ already\ exists = {0} already exists

# at: src/main/java/org/zstack/vmware/VCenterBackupStorage.java:138
# args: 
vcenter\ backup\ storage\ do\ not\ support\ to\ cancel\ download\ image = vcenter backup storage do not support to cancel download image

# at: src/main/java/org/zstack/vmware/VCenterBackupStorage.java:188
# args: 
image\ not\ found\ in\ BS = image not found in BS

# at: src/main/java/org/zstack/vmware/VCenterBackupStorage.java:200
# args: 
not\ supported\ yet = not supported yet

# at: src/main/java/org/zstack/vmware/VCenterHostAllocatorFilterExtensionPoint.java:357
# args: 
no\ candidate\ host\ for\ vcenter\ vm = no candidate host for vcenter vm

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:1031
# args: nNic.getMac(),nVm.getUuid(),nVm.getName(),eVM.getUuid(),eVM.getName(),VCENTER_MAC_CONFLICT_STRATEGY_STRICT
Duplicated\ mac\ address[%s]\ on\ VM[uuid\:\ %s,\ name\:\ %s]\ and\ VM[uuid\:\ %s,\ name\:\ %s],\ and\ current\ mac\ address\ conflicting\ strategy\ is\:\ %s. = Duplicated mac address[{0}] on VM[uuid: {1}, name: {2}] and VM[uuid: {3}, name: {4}], and current mac address conflicting strategy is: {5}.

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:1804
# args: 
can't\ sync\ before\ datastores\ are\ separated = can't sync before datastores are separated

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:2858
# args: msg.getVCenterUuid()
VCenter[uuid\:%s]\ not\ found\:\  = VCenter[uuid:{0}] not found: 

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:2974
# args: 
Login\ failed,\ please\ check\ your\ login\ parameters. = Login failed, please check your login parameters.

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:2978
# args: msg.getDomainName(),ex.getMessage()
connect\ %s\ failed\:\ %s = connect {0} failed: {1}

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:2984
# args: msg.getDomainName(),msg.getUsername()
Login\ to\ vCenter\ [%s]\ failed\ with\ user\ [%s],please\ check\ your\ network\ connection\ and\ credential. = Login to vCenter [{0}] failed with user [{1}],please check your network connection and credential.

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:2991
# args: msg.getDomainName(),msg.getPort() == null ? 443 : msg.getPort()
Parse\ response\ failed\ from\ vCenter\ [%s],please\ check\ the\ port\ number[%d]. = Parse response failed from vCenter [{0}],please check the port number[{1}].

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:3070
# args: 
No\ clustered\ compute\ resource\ found = No clustered compute resource found

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:3074
# args: 
No\ dvSwitch\ or\ qualified\ vSwitch\ found = No dvSwitch or qualified vSwitch found

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:3255
# args: dsMorVal,vcUuid
Datastore\ %s\ not\ found\ for\ vCenter\ %s = Datastore {0} not found for vCenter {1}

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:3627
# args: 
Missing\ host\ UUID\ in\ message = Missing host UUID in message

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:3725
# args: 
Missing\ destination\ host\ uuid. = Missing destination host uuid.

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:3730
# args: 
Destination\ host\ is\ not\ ESX\ host. = Destination host is not ESX host.

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:3768
# args: vm.getConfig().getName(),hvo.getManagementIp()
Checking\ compatibility\ with\ vm\ %s\ failed\ on\ host\ %s = Checking compatibility with vm {0} failed on host {1}

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:3765
# args: 
HOST\ CPU/software\ NOT\ compatible = HOST CPU/software NOT compatible

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:3993
# args: 
Can't\ detach\ nic\ because\ the\ nic\ not\ supported\ to\ hot\ plugin\ in\ vcenter = Can't detach nic because the nic not supported to hot plugin in vcenter

# at: src/main/java/org/zstack/vmware/VCenterPrimaryStorageBase.java:204
# args: 
No\ virtual\ disk\ manager = No virtual disk manager

# at: src/main/java/org/zstack/vmware/VCenterPrimaryStorageBase.java:211
# args: 
No\ file\ manager = No file manager

# at: src/main/java/org/zstack/vmware/VCenterPrimaryStorageBase.java:220
# args: 
No\ file\ Datacenter = No file Datacenter

# at: src/main/java/org/zstack/vmware/VCenterPrimaryStorageBase.java:324
# args: vm.getName()
failed\ to\ get\ VM[%s]\ root\ disk\ usage = failed to get VM[{0}] root disk usage

# at: src/main/java/org/zstack/vmware/VCenterPrimaryStorageBase.java:320
# args: msg.getInstallPath()
failed\ to\ get\ VM\ from\ installPath\:\ %s = failed to get VM from installPath: {0}

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:230
# args: vCenterUrl,ex.getMessage()
failed\ to\ connect\ to\ vCenter\:\ %s\:\ %s = failed to connect to vCenter: {0}: {1}

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:362
# args: installPath
vdisk\ not\ found\:\ %s = vdisk not found: {0}

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:437
# args: getVcDomainName(si)
list\ storage\ failed\ for\ %s = list storage failed for {0}

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:457
# args: vm.getName()
No\ datastore\ found\ for\ VM\:\ %s = No datastore found for VM: {0}

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:511
# args: info.getName(),info.getInstanceUuid()
failed\ to\ set\ ESX\ VM\ uuid\ [%s\:%s] = failed to set ESX VM uuid [{0}:{1}]

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:592
# args: zsImageUuid
template\ [%s]\ not\ found = template [{0}] not found

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:669
# args: host.getName()
failed\ to\ search\ resource\ pool\ for\ host\ %s = failed to search resource pool for host {0}

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:665
# args: host.getName()
No\ resource\ pool\ found\ for\ host\ %s = No resource pool found for host {0}

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:2105
# args: installPath
No\ unit\ number\ available\ for\ data\ disk\ %s = No unit number available for data disk {0}

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1245
# args: vm.getName()
guest\ tools\ not\ installed\ or\ running\ for\ VM\:\ %s = guest tools not installed or running for VM: {0}

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1280
# args: vm.getName()
upload\ file\ failed\ for\ VM\:\ %s = upload file failed for VM: {0}

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1368
# args: vcvo.getName()
list\ dvSwitch\ failed\ for\ %s = list dvSwitch failed for {0}

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1630
# args: clusterUuid
get\ vCenter\ cluster[%s]\ name\ failed = get vCenter cluster[{0}] name failed

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1739
# args: dvSwitch
dvSwitch\ name\ [%s]\ not\ unique = dvSwitch name [{0}] not unique

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1797
# args: hvo.getName()
create\ portgroup\ failed\ for\ host\ %s = create portgroup failed for host {0}

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1794
# args: hvo.getName(),((OperationFailureException) ex).getErrorCode().getDetails()
create\ portgroup\ failed\ for\ host\ %s\:\ because\ %s = create portgroup failed for host {0}: because {1}

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1761
# args: hvo.getName(),hvo.getUuid()
Host[%s\:%s]\ not\ found\ on\ vCenter = Host[{0}:{1}] not found on vCenter

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1773
# args: pgLabel,hvo.getName(),vlanId
portgroup[%s]\ already\ exists\ on\ host[%s]\ but\ with\ different\ vlanId(%d) = portgroup[{0}] already exists on host[{1}] but with different vlanId({2})

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1833
# args: hvo.getName()
portgroup[%s]\ already\ exists\ on\ host[%s],please\ create\ again\ with\ other\ name\ or\ delete\ portgroup\ manually\ and\ attach\ to\ cluster\ again = portgroup[%s] already exists on host[%s],please create again with other name or delete portgroup manually and attach to cluster again

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1836
# args: vcvo.getName()
create\ dvPortGroup\ failed\ for\ %s = create dvPortGroup failed for {0}

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1831
# args: dvSwitchName,vcvo.getName()
dvSwitch\ [%s]\ not\ found\ on\ vCenter\ [%s] = dvSwitch [{0}] not found on vCenter [{1}]

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:2026
# args: ds.getName()
no\ dataCenter\ found\ for\ datastore = no dataCenter found for datastore

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:2031
# args: 
virtual\ disk\ manager\ unavailable = virtual disk manager unavailable

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:2042
# args: installPath,mf.getLocalizedMessage()
delete\ vdisk[%s]\ failed\:\ %s = delete vdisk[{0}] failed: {1}

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:2171
# args: dvSwitch.getName(),task.getTaskInfo().getError().getLocalizedMessage()
create\ dvPortGroup\ failed\ for\ dvSwitch\ [%s],\ %s = create dvPortGroup failed for dvSwitch [{0}], {1}

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:2275
# args: me.getName(),mor.val,ex.getMessage()
failed\ to\ set\ ZStack\ uuid\ to\ VCenter\ ManagedEntity\ [name\:%s,\ mor\:%s]\ because\ %s = failed to set ZStack uuid to VCenter ManagedEntity [name:{0}, mor:{1}] because {2}

# at: src/main/java/org/zstack/vmware/VncPortAllocatorImpl.java:162
# args: 
No\ VNC\ ports\ available = No VNC ports available

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:225
# args: l3NetworkVO.getUuid()
no\ ip\ ranges\ attached\ with\ l3\ network[uuid\:%s] = no ip ranges attached with l3 network[uuid:{0}]

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:167
# args: l3NetworkVO.getUuid(),vmInstanceVO.getUuid(),vipPeerVOs.stream().map( n -> n.getVipUuid()).collect(Collectors.toList())
l3\ network[uuid\:%s]\ can\ not\ detach\ from\ vpc\ vrouter[uuid\:%s]\ since\ network\ services\ attached\ vips[%s]\ still\ used\ in\ l3 = l3 network[uuid:{0}] can not detach from vpc vrouter[uuid:{1}] since network services attached vips[{2}] still used in l3

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:183
# args: l3NetworkVO.getUuid(),vmInstanceVO.getUuid(),vmNicVOS.stream().map( n -> n.getUuid()).collect(Collectors.toList())
vpc\ l3\ network[uuid\:%s]\ can\ not\ detach\ from\ vpc\ vrouter[uuid\:%s]\ since\ vm\ nics[%s]\ still\ used\ in\ l3 = vpc l3 network[uuid:{0}] can not detach from vpc vrouter[uuid:{1}] since vm nics[{2}] still used in l3

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:193
# args: msg.getVirtualRouterOfferingUuid()
virtual\ router\ offering[uuid\:\ %s]\ is\ not\ enabled = virtual router offering[uuid: {0}] is not enabled

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:218
# args: 
only\ vpc\ l3\ network\ can\ attach\ to\ vpc\ vrouter = only vpc l3 network can attach to vpc vrouter

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:249
# args: vip.getL3NetworkUuid(),vip.getUuid(),vip.getIp(),msg.getL3NetworkUuid(),vmInstanceVO.getUuid()
public\ network[uuid\:\ %s]\ vip[uuid\:\ %s,\ ip\:\ %s]\ peer\ with\ l3network[uuid\:\ %s]\ not\ on\ vpc\ vr[uuid\:\ %s] = public network[uuid: {0}] vip[uuid: {1}, ip: {2}] peer with l3network[uuid: {3}] not on vpc vr[uuid: {4}]

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:261
# args: gateway,msg.getL3NetworkUuid()
the\ gateway[ip\:%s]\ of\ l3[uuid\:%s]\ has\ been\ occupied = the gateway[ip:{0}] of l3[uuid:{1}] has been occupied

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:272
# args: msg.getStaticIp(),gateway,l3NetworkVO.getUuid()
the\ static\ ip[%s]\ specified\ in\ message\ not\ equals\ to\ gateway\ ip[%s]\ of\ l3\ network[uuid\:%s] = the static ip[{0}] specified in message not equals to gateway ip[{1}] of l3 network[uuid:{2}]

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:284
# args: vipL3Uuid
l3\ network\ [uuid\:%s]\ must\ be\ attached\ first,\ because\ there\ is\ vip\ on\ that\ l3\ network = l3 network [uuid:{0}] must be attached first, because there is vip on that l3 network

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:335
# args: msg.getDns()
dns[%s]\ is\ not\ a\ IP\ address = dns[{0}] is not a IP address

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:296
# args: msg.getDns(),msg.getUuid()
dns\ address\ [%s]\ is\ not\ added\ to\ vpc\ router\ [uuid\:%s] = dns address [{0}] is not added to vpc router [uuid:{1}]

# at: src/main/java/org/zstack/vpc/VpcManagerImpl.java:1056
# args: 
chrony\ server\ not\ configured! = chrony server not configured!

# at: src/main/java/org/zstack/vpc/VpcManagerImpl.java:314
# args: msg.getUuid()
can\ not\ get\ connections\ of\ distributed\ routing\ to\ virtual\ router\ %s = can not get connections of distributed routing to virtual router {0}

# at: src/main/java/org/zstack/vpc/VpcManagerImpl.java:351
# args: vrinv.getUuid()
can\ not\ set\ state\ of\ distributed\ routing\ to\ virtual\ router\ %s = can not set state of distributed routing to virtual router {0}

# at: src/main/java/org/zstack/vpc/VpcManagerImpl.java:595
# args: vrinv.getUuid()
can\ not\ get\ state\ of\ distributed\ routing\ to\ virtual\ router\ %s = can not get state of distributed routing to virtual router {0}

# at: src/main/java/org/zstack/vpc/VpcManagerImpl.java:469
# args: msg.getNetworkService(),msg.getUuid()
not\ support\ to\ get\ the\ service\ %s\ state\ to\ virtual\ router\ %s = not support to get the service {0} state to virtual router {1}

# at: src/main/java/org/zstack/vpc/VpcManagerImpl.java:613
# args: msg.getNetworkService(),msg.getUuid()
not\ support\ to\ update\ the\ service\ %s\ state\ to\ virtual\ router\ %s = not support to update the service {0} state to virtual router {1}

# at: src/main/java/org/zstack/vpc/VpcManagerImpl.java:1004
# args: 
vpc\ l3\ network\ must\ attach\ a\ vpc\ vrouter\ first\ before\ do\ anything\ related\ to\ vrouter(like\ start/stop\ vm,\ create\ lb,\ etc.) = vpc l3 network must attach a vpc vrouter first before do anything related to vrouter(like start/stop vm, create lb, etc.)

# at: src/main/java/org/zstack/vpc/VpcManagerImpl.java:1281
# args: msg.getDns(),msg.getVpcRouterUuid()
dns\ address\ [%s]\ has\ bean\ added\ to\ vpc\ router\ [uuid\:%s] = dns address [{0}] has bean added to vpc router [uuid:{1}]

# at: src/main/java/org/zstack/vpc/VpcVRouterFactory.java:161
# args: vpc.getUuid()
can\ not\ detach\ nic\ from\ vpc\ vr[uuid\:%s] = can not detach nic from vpc vr[uuid:{0}]

# at: src/main/java/org/zstack/vpc/VpcVRouterFactory.java:289
# args: ipRange.getUuid()
can\ not\ detach\ nic\ from\ vpc\ during\ delete\ ip\ range[uuid\:%s] = can not detach nic from vpc during delete ip range[uuid:{0}]

# at: src/main/java/org/zstack/vpc/VpcVRouterFactory.java:342
# args: gateway,l3.getUuid(),vm.getUuid()
the\ gateway[ip\:%s]\ of\ l3[uuid\:%s]\ has\ been\ occupied\ on\ vpc\ vr[uuid\:\ %s] = the gateway[ip:{0}] of l3[uuid:{1}] has been occupied on vpc vr[uuid: {2}]

# at: src/main/java/org/zstack/vpc/VpcVyosDeployZsnAgentFlow.java:130
# args: mgmtNicIp
unable\ to\ ssh\ in\ to\ the\ vyos[%s],\ the\ ssh\ port\ seems\ not\ open = unable to ssh in to the vyos[{0}], the ssh port seems not open

# at: src/main/java/org/zstack/vpc/ha/VpcHaGroupApiInterceptor.java:164
# args: msg.getVmInstanceUuid()
there\ is\ no\ master\ router\ of\ router\ [uuid\:%s] = there is no master router of router [uuid:{0}]

# at: src/main/java/org/zstack/vpc/ha/VpcHaGroupApiInterceptor.java:115
# args: ip
invalid\ monitor\ ip\ address\ [%s] = invalid monitor ip address [{0}]

# at: src/main/java/org/zstack/vpc/ha/VpcHaGroupApiInterceptor.java:152
# args: vpcHaUuid
vpcHaRouter\ [uuid\:%s]\ is\ deleted = vpcHaRouter [uuid:{0}] is deleted

# at: src/main/java/org/zstack/vpc/ha/VpcHaGroupApiInterceptor.java:182
# args: haUuid
there\ are\ more\ than\ 2\ vpc\ routers\ attached\ to\ haGroup\ [uuid\:%s] = there are more than 2 vpc routers attached to haGroup [uuid:{0}]

# at: src/main/java/org/zstack/vpc/ha/VpcHaGroupApiInterceptor.java:211
# args: l3Uuids,offeringL3Uuids
ha\ group\ management\ l3\ and\ public\ l3\ networks[uuid\:%s]\ are\ different\ from\ offering\ l3\ networks\ [uuid\:%s] = ha group management l3 and public l3 networks[uuid:{0}] are different from offering l3 networks [uuid:{1}]

# at: src/main/java/org/zstack/vpc/ha/VpcHaGroupApiInterceptor.java:267
# args: vpcL3Uuids,vpcHaGroupL3Uuids
vpc\ router\ l3\ networks\ [uuid\:%s]\ are\ different\ from\ ha\ group\ l3\ networks\ [uuid\:%s],\ !!!\ please\ delete\ this\ router\ and\ recreate\ it = vpc router l3 networks [uuid:{0}] are different from ha group l3 networks [uuid:{1}], !!! please delete this router and recreate it

# at: src/main/java/org/zstack/vpc/ha/VpcHaGroupApiInterceptor.java:275
# args: oldHaUuid
vpc\ router\ has\ been\ attached\ to\ ha\ group\ [uuid\:%s] = vpc router has been attached to ha group [uuid:{0}]

# at: src/main/java/org/zstack/vpc/ha/VpcHaGroupApiInterceptor.java:279
# args: haUuid
vpc\ ha\ group\ [uuid\:%s]\ is\ not\ existed = vpc ha group [uuid:{0}] is not existed

# at: src/main/java/org/zstack/vpc/ha/VpcHaGroupApiInterceptor.java:283
# args: haUuid
there\ are\ more\ than\ 1\ vpc\ routers\ attached\ to\ haGroup\ [uuid\:%s] = there are more than 1 vpc routers attached to haGroup [uuid:{0}]

# at: src/main/java/org/zstack/vpc/ha/VpcHaGroupApiInterceptor.java:288
# args: haUuid
vpc\ router\ [uuid\:%s]\ can\ not\ be\ upgraded\ to\ ha\ router\ because\ it\ public\ network\ is\ same\ to\ management\ network = vpc router [uuid:{0}] can not be upgraded to ha router because it public network is same to management network

# at: src/main/java/org/zstack/vpc/ha/VpcHaGroupManagerImpl.java:571
# args: ha.getName()
create\ affinityGroup\ for\ ha\ group\ [uuid\:%s]\ failed = create affinityGroup for ha group [uuid:{0}] failed

# at: src/main/java/org/zstack/vpc/ha/vyos/vyosVpcHaRouterBackendManagerImpl.java:137
# args: vrUuid,ret.getError()
failed\ to\ enable\ ha\ on\ virtual\ router[uuid\:%s],\ %s = failed to enable ha on virtual router[uuid:{0}], {1}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:291
# args: ips
operation\ failure,\ ip\ format\ only\ supports\ ipv4/iprange/cidr,\ but\ find\ %s = operation failure, ip format only supports ipv4/iprange/cidr, but find {0}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:317
# args: protocol
illegal\ protocol\ type\ %s = illegal protocol type {0}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:342
# args: msg.getRuleSetUuid(),msg.getRuleNumber()
RuleSet[%s]\ already\ has\ a\ rule\ with\ rule\ number\ %s. = RuleSet[{0}] already has a rule with rule number {1}.

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:372
# args: 
only\ tcp\ or\ udp\ protocol\ can\ use\ port = only tcp or udp protocol can use port

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:88
# args: 
can\ not\ detach\ system\ default\ ruleSet = can not detach system default ruleSet

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:110
# args: msg.getUuid()
can\ not\ delete\ ruleSet[%s]\ because\ it\ still\ attached\ to\ nic = can not delete ruleSet[{0}] because it still attached to nic

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:114
# args: 
can\ not\ delete\ system\ default\ ruleSet = can not delete system default ruleSet

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:125
# args: 
can\ not\ delete\ system\ default\ rule = can not delete system default rule

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:150
# args: msg.getVpcUuid()
VPC\ Router[uuid\:%s]\ already\ has\ a\ firewall. = VPC Router[uuid:{0}] already has a firewall.

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:157
# args: msg.getUuid()
can\ not\ update\ default\ rule[%s] = can not update default rule[{0}]

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:377
# args: 
only\ tcp\ protocol\ can\ use\ tcp\ flag = only tcp protocol can use tcp flag

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:381
# args: 
only\ icmp\ protocol\ can\ use\ icmp\ type = only icmp protocol can use icmp type

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:221
# args: msg.getUuid()
Rule\ [%s]\ not\ support\ update\ state = Rule [{0}] not support update state

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:227
# args: 
Default\ ruleSet\ can\ not\ be\ attached\ to\ other\ nic = Default ruleSet can not be attached to other nic

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:231
# args: 
Only\ out\ direction\ support\ attach\ ruleSet = Only out direction support attach ruleSet

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:239
# args: msg.getL3Uuid(),msg.getForward()
L3[%s]\ forward[%s]\ already\ attached\ a\ ruleSet = L3[{0}] forward[{1}] already attached a ruleSet

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:302
# args: e.getMessage()
Invalid\ rule\ expression,\ the\ detail\:\ %s = Invalid rule expression, the detail: {0}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:284
# args: ips
operation\ failure,\ duplicate/overlap\ ip\ entry\ in\ %s = operation failure, duplicate/overlap ip entry in {0}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:295
# args: startIp,endIp,NetworkUtils.longToIpv4String(r.lowerEndpoint()),NetworkUtils.longToIpv4String(r.upperEndpoint())
operation\ failure,\ there\ are\ overlap\ ip\ range[start\ ip\:%s,\ end\ ip\:\ %s\ and\ start\ ip\:%s,\ end\ ip\:\ %s] = operation failure, there are overlap ip range[start ip:{0}, end ip: {1} and start ip:{2}, end ip: {3}]

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:309
# args: port
operation\ failure,\ port\ format\ only\ supports\ port/portRange,\ but\ find\ %s = operation failure, port format only supports port/portRange, but find {0}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallApiInterceptor.java:331
# args: state
protocol\ state\ only\ support\ new/established/invalid/related,but\ found\ %s = protocol state only support new/established/invalid/related,but found {0}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallBackend.java:290
# args: rsp.getError()
sync\ firewall\ config\ failed,because\ %s = sync firewall config failed,because {0}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallBackend.java:441
# args: rsp.getError()
update\ firewall\ ruleSet\ action\ failed,\ because\ %s = update firewall ruleSet action failed, because {0}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallBackend.java:516
# args: cmd.getRule().getRuleNumber(),rsp.getError()
create\ firewall\ rule[%s]\ failed,\ because\ %s = create firewall rule[{0}] failed, because {1}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallBackend.java:591
# args: vRouterUuid,re.getError().getCause()
delete\ firewall\ on\ vRouter[%s],because\ %s = delete firewall on vRouter[{0}],because {1}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallBackend.java:664
# args: cmd.getRuleSet().getName(),re.getError().getCause()
create\ firewall\ ruleSet[%s]\ failed,\ because\ %s = create firewall ruleSet[{0}] failed, because {1}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallBackend.java:744
# args: vRouterUuid,rsp.getError()
delete\ firewall\ rule\ failed\ on\ vRouter[%s],\ because\ %s = delete firewall rule failed on vRouter[{0}], because {1}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallBackend.java:822
# args: vRouterUuid,rsp.getError()
change\ firewall\ rule\ state\ on\ vRouter[%s]\ failed,\ because\ %s = change firewall rule state on vRouter[{0}] failed, because {1}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallBackend.java:996
# args: struct.getL3Uuid(),vRouterUuid
Can\ not\ find\ l3[%]\ related\ mac\ on\ vRouter[%s] = Can not find l3[%] related mac on vRouter[{0}]

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallBackend.java:921
# args: cmd.getRef().getRuleSetName(),re.getError()
attach\ firewall\ ruleSet[%s]\ failed,\ because\ %s = attach firewall ruleSet[{0}] failed, because {1}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallBackend.java:956
# args: 
detach\ ruleSet\ failed,\ maybe\ it\ has\ been\ deleted = detach ruleSet failed, maybe it has been deleted

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallBackend.java:1024
# args: cmd.getRef().getRuleSetName(),re.getError().getCause()
detach\ firewall\ ruleSet[%s]\ failed,because\ %s = detach firewall ruleSet[{0}] failed,because {1}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallBackend.java:1102
# args: cmd.getRuleSetName(),re.getError().getCause()
delete\ firewall\ ruleSet[%s]\ failed,because\ %s = delete firewall ruleSet[{0}] failed,because {1}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallBase.java:129
# args: msg.getRuleSetUuid(),msg.getL3Uuid(),errorCode.getCause()
attach\ firewall\ ruleSet[%s]\ to\ l3[%s]\ failed,because\ %s = attach firewall ruleSet[{0}] to l3[{1}] failed,because {2}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallBase.java:156
# args: msg.getL3Uuid(),errorCode.getCause()
detach\ firewall\ ruleSet\ from\ l3[%s]\ failed,because\ %s = detach firewall ruleSet from l3[{0}] failed,because {1}

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallManagerImpl.java:83
# args: msg.getVpcFirewallUuid()
cannot\ find\ vpcFirewall[uuid\:%s],\ it\ may\ have\ been\ deleted = cannot find vpcFirewall[uuid:{0}], it may have been deleted

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallManagerImpl.java:104
# args: vo.getVpcFirewallUuid()
cannot\ find\ vpcFirewall[uuid\:%s]\ related\ vRouter = cannot find vpcFirewall[uuid:{0}] related vRouter

# at: src/main/java/org/zstack/vpcfirewall/VpcFirewallManagerImpl.java:99
# args: msg.getVpcFirewallRuleUuid()
cannot\ find\ vpcFirewallRule[uuid\:%s],\ it\ may\ have\ been\ deleted = cannot find vpcFirewallRule[uuid:{0}], it may have been deleted

# at: src/main/java/org/zstack/vrouterRoute/VRouterRouteManagerImpl.java:466
# args: msg.getUuid()
cannot\ find\ the\ route\ table\ [uuid\:%s] = cannot find the route table [uuid:{0}]

# at: src/main/java/org/zstack/xdragon/XDragonHostFactory.java:34
# args: msg.getClusterUuid(),XDragonConstant.HYPERVISOR_TYPE
cluster[uuid\:%s]\ hypervisorType\ is\ not\ %s = cluster[uuid:{0}] hypervisorType is not {1}

# at: src/main/java/org/zstack/xdragon/XDragonFilterExtensionPoint.java:30
# args:
xdragon\ host\ not\ support\ create\ vm\ using\ an\ iso\ image. = xdragon host not support create vm using an iso image.

# at: src/main/java/org/zstack/yunshan/util/YunshanClient.java:46
# args: 
the\ url\ is\ null,\ please\ config\ the\ YunShan\ NSP. = the url is null, please config the YunShan NSP.

# at: src/main/java/org/zstack/zql/ast/visitors/OrderByVisitor.java:13
# args: node.getDirection()
invalid\ order\ by\ clause,\ expect\ direction[asc,desc]\ but\ got\ %s = invalid order by clause, expect direction[asc,desc] but got {0}

# at: src/main/java/org/zstack/zql/ast/visitors/OrderByVisitor.java:19
# args: m.simpleInventoryName(),node.getField()
invalid\ order\ by\ clause,\ inventory[%s]\ doesn't\ have\ field[%s] = invalid order by clause, inventory[{0}] doesn't have field[{1}]

# at: src/main/java/org/zstack/zql/ast/visitors/plugin/SumPlugin.java:31
# args: 
the\ field\ to\ sum\ must\ be\ specified = the field to sum must be specified

# at: src/main/java/org/zstack/zwatch/ZQLReturnWithExtension.java:125
# args: clz.getName()
resource[%s]\ doesn't\ support\ zwatch\ return\ with\ clause = resource[{0}] doesn't support zwatch return with clause

# at: src/main/java/org/zstack/zwatch/ZQLReturnWithExtension.java:270
# args: paramName,normalizedExpr
unknown\ parameter[%s]\ in\ zwatch\ return\ with\ clause,\ %s = unknown parameter[{0}] in zwatch return with clause, {1}

# at: src/main/java/org/zstack/zwatch/ZQLReturnWithExtension.java:279
# args: expr,e.getMessage()
invalid\ zwatch\ return\ with\ clause\:\ %s,\ %s = invalid zwatch return with clause: {0}, {1}

# at: src/main/java/org/zstack/zwatch/ZWatchManagerImpl.java:571
# args: eventData.getDataUuid(),t.getMessage()
update\ eventData[dataUuid\=%s]\ failed,\ %s = update eventData[dataUuid={0}] failed, {1}

# at: src/main/java/org/zstack/zwatch/ZWatchManagerImpl.java:694
# args: alarmData.getDataUuid(),t.getMessage()
update\ alarmData[dataUuid\=%s]\ failed,\ %s = update alarmData[dataUuid={0}] failed, {1}

# at: src/main/java/org/zstack/zwatch/ZWatchManagerImpl.java:705
# args: 
Some\ messages\ have\ expired.\ The\ expired\ messages\ are\ not\ allowed\ to\ be\ modified.\ The\ system\ will\ automatically\ clean\ up\ the\ expired\ messages.\ Please\ operate\ later = Some messages have expired. The expired messages are not allowed to be modified. The system will automatically clean up the expired messages. Please operate later

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:83
# args: msg.getActionUuid(),msg.getSubscriptionUuid()
the\ action[uuid\:%s]\ already\ attached\ to\ the\ event\ subscription[uuid\:%s] = the action[uuid:{0}] already attached to the event subscription[uuid:{1}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:107
# args: msg.getKey()
event\ doesn't\ have\ label[%s] = event doesn't have label[{0}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:112
# args: msg.getKey()
the\ event\ subscription\ already\ has\ the\ label[%s] = the event subscription already has the label[{0}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:155
# args: msg.getNamespace()
namespace[%s]\ not\ found = namespace[{0}] not found

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:129
# args: ns.getName(),msg.getEventName()
namespace[%s]\ doesn't\ have\ the\ event[%s] = namespace[{0}] doesn't have the event[{1}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:137
# args: msg.getEventName(),l.getKey()
event[%s]\ doesn't\ have\ the\ label[%s] = event[{0}] doesn't have the label[{1}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:197
# args: k,l
duplicate\ key[%s]\ with\ values%s = duplicate key[{0}] with values{1}

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:164
# args: msg.getMetricName()
Period\ field\ is\ not\ supported\ for\ metric\ [name\:%s] = Period field is not supported for metric [name:{0}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:161
# args: msg.getMetricName()
Period\ field\ can\ not\ be\ null\ for\ metric\ [name\:%s] = Period field can not be null for metric [name:{0}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:172
# args: msg.getNamespace(),msg.getMetricName()
namespace[%s]\ doesn't\ have\ the\ metric[%s] = namespace[{0}] doesn't have the metric[{1}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:178
# args: msg.getMetricName()
the\ metric[%s]\ is\ admin\ only,\ not\ available\ for\ current\ user = the metric[{0}] is admin only, not available for current user

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:186
# args: msg.getMetricName(),l.getKey()
the\ metric[%s]\ doesn't\ have\ the\ label[%s] = the metric[{0}] doesn't have the label[{1}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:209
# args: actionType
invalid\ action\ type[%s] = invalid action type[{0}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:214
# args: actionUuid,actionType
action[uuid\:%s,\ type\:%s]\ not\ found = action[uuid:{0}, type:{1}] not found

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:222
# args: msg.getActionUuid(),msg.getActionType(),msg.getAlarmUuid()
duplicated\ action[uuid\:%s,\ type\:%s]\ for\ the\ alarm[uuid\:%s] = duplicated action[uuid:{0}, type:{1}] for the alarm[uuid:{2}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:232
# args: msg.getKey(),msg.getOperator(),msg.getValue(),msg.getAlarmUuid()
duplicate\ label[key\:%s,\ operator\:%s,\ value\:%s]\ for\ the\ alarm[uuid\:%s] = duplicate label[key:{0}, operator:{1}, value:{2}] for the alarm[uuid:{3}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmManagerImpl.java:110
# args: msg.getSubscriptionUuid()
cannot\ find\ the\ event\ subscription[uuid\:%s],\ it\ may\ have\ been\ deleted = cannot find the event subscription[uuid:{0}], it may have been deleted

# at: src/main/java/org/zstack/zwatch/alarm/AlarmManagerImpl.java:119
# args: msg.getAlarmUuid()
cannot\ find\ the\ alarm[uuid\:%s],\ it\ may\ have\ been\ deleted = cannot find the alarm[uuid:{0}], it may have been deleted

# at: src/main/java/org/zstack/zwatch/alarm/AlarmManagerImpl.java:576
# args: alarmVO.getMetricName()
the\ metric[%s]\ repeatInterval\ value\ cannot\ be\ less\ than\ 1h = the metric[{0}] repeatInterval value cannot be less than 1h

# at: src/main/java/org/zstack/zwatch/alarm/AlarmStatus.java:16
# args: 
InsufficientData = InsufficientData

# at: src/main/java/org/zstack/zwatch/alarm/AlarmStatus.java:14
# args: 
Alarm = Alarm

# at: src/main/java/org/zstack/zwatch/alarm/AlarmStatus.java:12
# args: 
OK = OK

# at: src/main/java/org/zstack/zwatch/alarm/sns/SNSActionFactory.java:55
# args: actionUuid
cannot\ find\ the\ topic[uuid\:%s] = cannot find the topic[uuid:{0}]

# at: src/main/java/org/zstack/zwatch/alarm/sns/SNSActionFactory.java:96
# args: msg.getAlarmTextTemplateUuid()
cannot\ find\ SNSTextTemplate[uuid\:%s],\ it\ may\ have\ been\ deleted = cannot find SNSTextTemplate[uuid:{0}], it may have been deleted

# at: src/main/java/org/zstack/zwatch/alarm/sns/SNSTextTemplateApiInterceptor.java:73
# args: msg.getApplicationPlatformType()
invalid\ application\ platform\ type[%s] = invalid application platform type[{0}]

# at: src/main/java/org/zstack/zwatch/alarm/sns/SNSTextTemplateApiInterceptor.java:159
# args: String.join(",\n", errorParams),String.join(",\n", AbstractTextTemplate.defaultSupportedParams)
parameters\:\n\ %s\ are\ not\ supported\ by\ ZStack,\ available\ values\ are\:\n\ %s = parameters:\n {0} are not supported by ZStack, available values are:\n {1}

# at: src/main/java/org/zstack/zwatch/alarm/sns/SNSTextTemplateApiInterceptor.java:78
# args: msg.getApplicationPlatformType()
application\ platform/endpoint\ [%s]\ doesn't\ support\ user-defined\ template = application platform/endpoint [{0}] doesn't support user-defined template

# at: src/main/java/org/zstack/zwatch/alarm/sns/SNSTextTemplateApiInterceptor.java:91
# args: sign,sign.length()
The\ length\ of\ aliyun\ sms\ sign\ should\ between\ 2\ to\ 12\ characters.\ Got\ sign\:\ [%s]\ with\ [%d]\ characters. = The length of aliyun sms sign should between 2 to 12 characters. Got sign: [{0}] with [{1}] characters.

# at: src/main/java/org/zstack/zwatch/alarm/sns/SNSTextTemplateApiInterceptor.java:96
# args: alarmTemplateCode,alarmTemplateCode.length()
Sms\ template\ code\ is\ a\ string\ with\ 13\ characters.\ Got\ alarm\ template\ code\:\ [%s]\ with\ [%d]\ characters. = Sms template code is a string with 13 characters. Got alarm template code: [{0}] with [{1}] characters.

# at: src/main/java/org/zstack/zwatch/alarm/sns/SNSTextTemplateApiInterceptor.java:101
# args: eventTemplateCode,eventTemplateCode.length()
Sms\ template\ code\ is\ a\ string\ with\ 13\ characters.\ Got\ event\ template\ code\:\ [%s]\ with\ [%d]\ characters. = Sms template code is a string with 13 characters. Got event template code: [{0}] with [{1}] characters.

# at: src/main/java/org/zstack/zwatch/alarm/system/SystemAlarmManagerImpl.java:587
# args: DATA_DIR_CAPACITY_ALARM_UUID
alarm[uuid\:%s]\ is\ a\ system\ alarm\ which\ cannot\ be\ deleted = alarm[uuid:{0}] is a system alarm which cannot be deleted

# at: src/main/java/org/zstack/zwatch/alarm/system/SystemAlarmManagerImpl.java:598
# args: SNSSystemAlarmTopicManager.SYSTEM_ALARM_TOPIC_UUID,DATA_DIR_CAPACITY_ALARM_UUID
removing\ system\ topic[uuid\:%s]\ from\ system\ alarm[uuid\:%s]\ is\ forbidden = removing system topic[uuid:{0}] from system alarm[uuid:{1}] is forbidden

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:203
# args: l.getKey(),AuditDataV2.queryableLoginLabels
invalid\ label[%s],\ valid\ queryable\ labels\ are\ %s = invalid label[{0}], valid queryable labels are {1}

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:250
# args: msg.getStartTime(),msg.getEndTime()
startTime[%s]\ is\ greater\ than\ endTime[%s] = startTime[{0}] is greater than endTime[{1}]

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:114
# args: 
dataUuid\ cannot\ be\ missed = dataUuid cannot be missed

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:120
# args: 
dataStartTime\ and\ dataEndTime\ cannot\ be\ missed = dataStartTime and dataEndTime cannot be missed

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:124
# args: msg.getDataStartTime(),msg.getDataEndTime()
dataStartTime[%s]\ is\ greater\ than\ dataEndTime[%s] = dataStartTime[{0}] is greater than dataEndTime[{1}]

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:142
# args: Namespace.ZSTACK_NAMESPACE_PREFIX
namespace\ name\ cannot\ start\ with\ %s\ that\ is\ reserved = namespace name cannot start with {0} that is reserved

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:153
# args: msg.getNamespace()
cannot\ find\ namespace[%s] = cannot find namespace[{0}]

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:161
# args: msg.getMetricName(),msg.getNamespace()
cannot\ find\ metric[%s]\ in\ namespace[%s] = cannot find metric[{0}] in namespace[{1}]

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:174
# args: msg.getMetricName(),metric.getLabelNames(),l.getKey()
metric[%s]'s\ labels[%s]\ does\ not\ include\ [%s] = metric[{0}]'s labels[{1}] does not include [{2}]

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:186
# args: msg.getMetricName(),l.getValue()
metric[%s]\ does\ not\ has\ filter[%s] = metric[{0}] does not has filter[{1}]

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:229
# args: AuditDataV2.TAG_RESOURCE_UUID
label[%s]\ must\ be\ specified = label[{0}] must be specified

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:271
# args: end,msg.getEndTime(),start,msg.getStartTime()
endTime[%s,\ %sms]\ must\ not\ be\ before\ startTime[%s,\ %sms] = endTime[{0}, {1}ms] must not be before startTime[{2}, {3}ms]

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:289
# args: msg.getNamespace()
no\ namespace[%s]\ defined\ in\ the\ system = no namespace[{0}] defined in the system

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:293
# args: msg.getNamespace(),msg.getMetricName()
the\ namespace[%s]\ has\ no\ metric[%s] = the namespace[{0}] has no metric[{1}]

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:322
# args: msg.getSession().getAccountUuid(),opt.get().getValue()
account[uuid\:\ %s]\ has\ no\ access\ to\ the\ resource[uuid\:\ %s] = account[uuid: {0}] has no access to the resource[uuid: {1}]

# at: src/main/java/org/zstack/zwatch/datatype/EmergencyLevel.java:19
# args: 
Normal = Normal

# at: src/main/java/org/zstack/zwatch/datatype/EmergencyLevel.java:17
# args: 
Important = Important

# at: src/main/java/org/zstack/zwatch/datatype/EmergencyLevel.java:15
# args: 
Emergent = Emergent

# at: src/main/java/org/zstack/zwatch/datatype/Function.java:106
# args: expr,e.getMessage()
invalid\ function\:\ %s,\ %s = invalid function: {0}, {1}

# at: src/main/java/org/zstack/zwatch/datatype/Function.java:110
# args: expr
invalid\ expression\:\ %s,\ no\ function\ found = invalid expression: {0}, no function found

# at: src/main/java/org/zstack/zwatch/datatype/Label.java:57
# args: str
the\ label\ string[%s]\ contains\ no\ valid\ operator = the label string[{0}] contains no valid operator

# at: src/main/java/org/zstack/zwatch/datatype/Label.java:72
# args: JSONObjectUtil.toJsonString(this)
invalid\ label,\ 'key'\ field\ cannot\ be\ null.\ %s = invalid label, 'key' field cannot be null. {0}

# at: src/main/java/org/zstack/zwatch/datatype/Label.java:75
# args: JSONObjectUtil.toJsonString(this)
invalid\ label,\ 'op'\ field\ is\ null\ or\ something\ another\ than\ Regex\ and\ Equal.\ %s = invalid label, 'op' field is null or something another than Regex and Equal. {0}

# at: src/main/java/org/zstack/zwatch/datatype/Label.java:78
# args: JSONObjectUtil.toJsonString(this)
invalid\ label,\ 'value'\ field\ cannot\ be\ null.\ %s = invalid label, 'value' field cannot be null. {0}

# at: src/main/java/org/zstack/zwatch/function/ArgumentChecker.java:30
# args: value,name
invalid\ value[%s]\ of\ the\ argument[%s] = invalid value[{0}] of the argument[{1}]

# at: src/main/java/org/zstack/zwatch/function/LimitFunction.java:21
# args: v
value[%s]\ is\ not\ a\ Integer\ number = value[{0}] is not a Integer number

# at: src/main/java/org/zstack/zwatch/function/LimitFunction.java:18
# args: v
invalid\ argument[limit\:%s],\ it\ can't\ be\ a\ negative\ number = invalid argument[limit:{0}], it can't be a negative number

# at: src/main/java/org/zstack/zwatch/function/MetricFunction.java:46
# args: name
missing\ required\ argument[%s] = missing required argument[{0}]

# at: src/main/java/org/zstack/zwatch/function/MetricFunction.java:59
# args: k
duplicate\ argument[%s] = duplicate argument[{0}]

# at: src/main/java/org/zstack/zwatch/function/MetricFunction.java:68
# args: func.getName()
unknown\ function[%s] = unknown function[{0}]

# at: src/main/java/org/zstack/zwatch/function/SortFunction.java:41
# args: arg.name
unknown\ argument[%s] = unknown argument[{0}]

# at: src/main/java/org/zstack/zwatch/influxdb/InfluxDBEventDatabaseDriver.java:153
# args: name
cannot\ find\ EventFamily[name\:%s] = cannot find EventFamily[name:{0}]

# at: src/main/java/org/zstack/zwatch/influxdb/InfluxDBEventDatabaseDriver.java:175
# args: name,namespace
cannot\ find\ EventFamily[name\:%s,\ namespace\:%s] = cannot find EventFamily[name:{0}, namespace:{1}]

# at: src/main/java/org/zstack/zwatch/influxdb/InfluxDBEventDatabaseDriver.java:632
# args: label.getKey(),names
invalid\ query\ label[%s].\ Allowed\ label\ names\ are\ %s = invalid query label[{0}]. Allowed label names are {1}

# at: src/main/java/org/zstack/zwatch/influxdb/InfluxDBEventDatabaseDriver.java:666
# args: name.getValue(),InfluxEventDataV2.FIELD_NAMESPACE
there\ are\ multiple\ EventFamily\ with\ the\ name[%s],\ you\ must\ specify\ the\ label[%s] = there are multiple EventFamily with the name[{0}], you must specify the label[{1}]

# at: src/main/java/org/zstack/zwatch/influxdb/InfluxDatabaseCreator.java:58
# args: ret.getError()
unable\ to\ query\ influxdb,\ %s = unable to query influxdb, {0}

# at: src/main/java/org/zstack/zwatch/influxdb/InfluxDatabaseCreator.java:102
# args: JSONObjectUtil.toJsonString(ret)
invalid\ influxdb\ response\:\ %s,\ no\ name\ found\ in\ columns = invalid influxdb response: {0}, no name found in columns

# at: src/main/java/org/zstack/zwatch/influxdb/InfluxDatabaseCreator.java:88
# args: retention,res.getError()
failed\ to\ create\ influxdb\ retention\ '%s',\ %s = failed to create influxdb retention '{0}', {1}

# at: src/main/java/org/zstack/zwatch/influxdb/InfluxDatabaseCreator.java:81
# args: retention,res.getError()
failed\ to\ alter\ influxdb\ retention\ '%s',\ %s = failed to alter influxdb retention '{0}', {1}

# at: src/main/java/org/zstack/zwatch/influxdb/InfluxDatabaseCreator.java:120
# args: defaultUserName,res.getError()
failed\ to\ create\ influxdb\ default\ user\ '%s',\ %s = failed to create influxdb default user '{0}', {1}

# at: src/main/java/org/zstack/zwatch/mysql/MysqlDatabaseDriver.java:51
# args: qo.getNamespaceName()
no\ mysql\ namespace[%s]\ found = no mysql namespace[{0}] found

# at: src/main/java/org/zstack/zwatch/namespace/AbstractNamespace.java:46
# args: getName(),queryObject.getMetricName()
namespace[%s]\ has\ no\ metric[%s] = namespace[{0}] has no metric[{1}]

# at: src/main/java/org/zstack/zwatch/namespace/AbstractNamespace.java:52
# args: m.getName(),getName(),l.getKey()
metric[%s]\ of\ the\ namespace[%s]\ has\ no\ label\ named\ %s = metric[{0}] of the namespace[{1}] has no label named {2}

# at: src/main/java/org/zstack/zwatch/namespace/NamespaceEventManagerImpl.java:406
# args: 
error\ happened\ but\ reason\ not\ specified = error happened but reason not specified

# at: src/main/java/org/zstack/zwatch/namespace/SystemNamespace.java:31
# args: d,Platform.getManagementServerIp()
folder[%s]\ not\ found\ on\ the\ management\ server[%s] = folder[{0}] not found on the management server[{1}]

# at: src/main/java/org/zstack/compute/vm/InstantiateVirtIODriverFlow.java:148
# args: filepath,Platform.getManagementServerIp()
fail\ to\ attach\ virtio\ driver\ because\ of\ invalid\ md5\ of\ file[%s]\ in\ mn[uuid\:%s] = fail to attach virtio driver because of invalid MD5sum of file[{0}] in management server[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/InstantiateVirtIODriverFlow.java:154
# args: filepath,Platform.getManagementServerIp(),cause
fail\ to\ attach\ virtio\ driver\ because\ read\ md5\ of\ file[%s]\ fail\ in\ mn[uuid\:%s]\:\ %s = fail to attach virtio driver because read MD5sum of file[{0}] fail in management server[uuid:{1}]: {2}

# at: src/main/java/org/zstack/compute/vm/InstantiateVirtIODriverFlow.java:142
# args: filepath,Platform.getManagementServerIp()
fail\ to\ attach\ virtio\ driver\ because\ read\ md5\ of\ file[%s]\ fail\ in\ mn[uuid\:%s]\:\ file\ not\ found\ on\ classpath = fail to attach virtio driver because read MD5sum of file[{0}] fail in management server[uuid:{1}]: file is not exist on class path

# at: src/main/java/org/zstack/zwatch/ruleengine/ComparisonOperator.java:35
# args: 
LessThanOrEqualTo = LessThanOrEqualTo

# at: src/main/java/org/zstack/zwatch/ruleengine/ComparisonOperator.java:33
# args: 
LessThan = LessThan

# at: src/main/java/org/zstack/zwatch/ruleengine/ComparisonOperator.java:31
# args: 
GreaterThan = GreaterThan

# at: src/main/java/org/zstack/zwatch/ruleengine/ComparisonOperator.java:29
# args: 
GreaterThanOrEqualTo = GreaterThanOrEqualTo

# at: src/test/java/org/zstack/test/aop/ManInTheMiddleService.java:40
# args: 
unit\ test\ asks\ it\ to\ fail = unit test asks it to fail

# at: src/test/java/org/zstack/test/compute/hostallocator/HostAllocateExtension.java:22
# args: 
On\ purpose = On purpose

# at: src/test/java/org/zstack/test/kvm/KVMPingAgentExtensionForTest.java:27
# args: 
on\ purpose = on purpose

# at: src/test/crypto/org/zstack/crypto/auth/CryptoAuthenticationManagerImpl.java:162
# args: 
could\ not\ enable\ two-factor\ authentication\ when\ CCS\ certificate\ authentication\ is\ enabled = could not enable crypto UKey authentication when other two-factor authentication is enabled

# at: src/test/crypto/org/zstack/crypto/auth/CryptoAuthenticationManagerImpl.java:170
# args: 
could\ not\ enable\ CCS\ certificate\ authentication\ when\ two-factor\ authentication\ is\ enabled = could not enable two-factor authentication when crypto UKey authentication is enabled

# at: src/test/crypto/org/zstack/crypto/ccs/CCSCertificateManagerImpl.java:209
# args: certificate.uuid
certificate[uuid\=%s]\ not\ found = CCS certificate[uuid:{0}] does not exist

# at: src/test/crypto/org/zstack/crypto/ccs/CCSCertificateManagerImpl.java:224
# args: 
CCS\ certificate\ authentication\ disabled = CCS certificate authentication disabled. Please check whether the current secret resource pool is enabled

# at: src/test/crypto/org/zstack/crypto/ccs/CCSCertificateManagerImpl.java:230
# args: expectCryptoAuthenticationType, actualCryptoAuthenticationType
wrong\ crypto\ authentication\ type,\ expect[%s],\ actual[%s] = wrong crypto authentication type in UKey system tag, expect[{0}], actual[{1}]. Please check out your UKey system tag in API parameter

# at: src/test/crypto/org/zstack/crypto/ccs/CCSCertificateManagerImpl.java:242
# args: 
failed\ to\ decrypt\ cipher\ text = failed to decrypt cipher text in UKey system tag. Please check out your UKey system tag in API parameter

# at: src/test/crypto/org/zstack/crypto/ccs/CCSCertificateManagerImpl.java:247
# args: 
wrong\ credential = wrong credential. Please check out your UKey system tag in API parameter

# at: src/test/crypto/org/zstack/crypto/ccs/CCSCertificateManagerImpl.java:298
# args: certificate.uuid
certificate[uuid\=%s]\ is\ not\ within\ the\ valid\ period = the CCS certificate[uuid:{0}] is not within the valid period

# at: src/test/crypto/org/zstack/crypto/ccs/CCSCertificateInterceptor.java:158
# args: certificate.uuid
user[uuid\=%s]\ not\ found = user[uuid:{0}] does not exist

# at: src/test/crypto/org/zstack/crypto/ccs/CCSCertificateInterceptor.java:162
# args: 
certificate\ uuid\ is\ empty\ and\ UKey\ system\ tag\ does\ not\ exist = bad API request: certificate UUID and UKey system tag cannot be empty at the same time. Please check out your UKey system tag in API parameter

# at: src/test/crypto/org/zstack/crypto/ccs/CCSCertificateInterceptor.java:167
# args: user.uuid
user[uuid\=%s]\ does\ not\ have\ any\ CCS\ certificate\ attached = user[uuid:{0}] does not have any CCS certificate attached

# at: src/test/crypto/org/zstack/crypto/ccs/CCSCertificateInterceptor.java:172
# args: user.uuid, certificate.uuid
user[uuid\=%s]\ already\ has\ the\ certificate[uuid\=%s]\ attached = user[uuid:{0}] already has the certificate[uuid:{1}] attached
