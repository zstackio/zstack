# at: src/main/java/org/zstack/aliyun/account/AliyunAccountManagerImpl.java:67
# args: msg.getAccountUuid()
key\ is\ existed\ by\ [account\:%s],\ if\ you\ still\ want\ to\ create\ this\ key,\ please\ delete\ it\ first = 

# at: src/main/java/org/zstack/aliyun/core/AliyunClient.java:26
# args: 
regionId,\ accessKey\ and\ keySecret\ must\ be\ set = 

# at: src/main/java/org/zstack/aliyun/core/AliyunSdkImpl.java:854
# args: 
cannot\ find\ any\ VSwitch,\ please\ check\ it! = 

# at: src/main/java/org/zstack/aliyun/core/AliyunSdkImpl.java:908
# args: 
no\ identity\ zones\ can\ be\ used\ now = 

# at: src/main/java/org/zstack/aliyun/core/AliyunSdkImpl.java:968
# args: 
cannot\ find\ any\ SecurityGroup,\ please\ check\ it! = 

# at: src/main/java/org/zstack/aliyun/core/AliyunSdkImpl.java:1031
# args: 
cannot\ find\ any\ Vpc,\ please\ check\ it! = 

# at: src/main/java/org/zstack/aliyun/core/AliyunSdkImpl.java:1068
# args: request.getRegionId()
regionId[%s]\ is\ invalid\ by\ aliyun! = 

# at: src/main/java/org/zstack/aliyun/ecs/CheckEcsImageExistPublicFlow.java:48
# args: 
image\ has\ bee\ deleted! = 

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:61
# args: osType
valid\ OSType\:[%s]\ for\ aliyun\ image\ import,\ valid\ value\ are\:\ [linux,\ windows] = 

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:66
# args: platform,EcsImageConstant.ECS_IMAGE_PLATFORM.getValid()
valid\ platform\:[%s]\ for\ aliyun\ image\ import,\ valid\ value\ are\:\ [%s] = 

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:96
# args: evo.getAvailableIpAddressCount()
vSwitch\ availableIpAddress\ is\ not\ enough,\ now\ is\ (%d) = 

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:100
# args: privateIp,cidr
%s\ is\ not\ in\ cidr\ range\:\ %s = 

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:106
# args: msg.getIdentityZoneUuid()
not\ valid\ izone\:[%s]\ in\ aliyun = 

# at: src/main/java/org/zstack/aliyun/ecs/EcsInstanceManagerImpl.java:191
# args: rly1.getVncUrl()
decode\ url\ failed\:\ %s = 

# at: src/main/java/org/zstack/aliyun/network/AliyunNetworkServiceBase.java:72
# args: dcUuid
no\ such\ dataCenterUuid\ [%s] = 

# at: src/main/java/org/zstack/aliyun/network/AliyunNetworkServiceBase.java:201
# args: msg.getIdentityZoneUuid()
no\ such\ identityZone\ [%s] = 

# at: src/main/java/org/zstack/aliyun/network/AliyunNetworkServiceBase.java:314
# args: msg.getEcsVpcUuid()
No\ such\ vpcUuid\:\ %s = 

# at: src/main/java/org/zstack/aliyun/network/DescribeVSwitchFlow.java:98
# args: dcUuid
dataCenterUuid\ [%s]\ couldn't\ be\ found = 

# at: src/main/java/org/zstack/aliyun/network/DescribeVSwitchFlow.java:40
# args: dcUuid
couldn't\ find\ any\ VPCs\ in\ dataCenterUuid\:\ %s = 

# at: src/main/java/org/zstack/aliyun/oss/EcsOssManagerImpl.java:117
# args: msg.getDataCenterUuid()
another\ OssBucket\ has\ been\ attached\ to\ dataCenter\:\ %s = 

# at: src/main/java/org/zstack/apimediator/ApiValidator.java:60
# args: hostname,newBS
More\ than\ one\ BackupStorage\ on\ the\ same\ host\ identified\ by\ hostname.\ There\ has\ been\ a\ SftpBackupStorage\ [hostname\:%s]\ existing.\ The\ BackupStorage\ type\ to\ be\ added\ is\ %s.\  = 超过一个相同的备份存储类型在认证的物理机上，这事发生在Sftp存储上 [机器名:{0}] 已存在. 这个类型的备份存储已经被添加{1}

# at: src/main/java/org/zstack/apimediator/ApiValidator.java:68
# args: hostname,newBS
More\ than\ one\ BackupStorage\ on\ the\ same\ host\ identified\ by\ hostname.\ There\ has\ been\ an\ ImageStoreBackupStorage\ [hostname\:%s]\ existing.\ The\ BackupStorage\ type\ to\ be\ added\ is\ %s.\  = 超过一个相同的备份存储类型在认证的物理机上，这事发生在镜像仓库上 [机器名:{0}] 已存在. 这个类型的备份存储已经被添加{1}

# at: src/main/java/org/zstack/appliancevm/ApplianceVmBase.java:126
# args: self.getUuid(),getSelf().getStatus(),msg.getPath()
appliance\ vm[uuid\:%s]\ is\ in\ status\ of\ %s\ that\ cannot\ make\ http\ call\ to\ %s = 系统虚拟机[uuid:{0}]处于{1}状态，无法对[{2}]执行HTTP RPC调用

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:40
# args: 
the\ start\ date\ must\ be\ greater\ than\ the\ end\ date = 开始时间必须大于结束时间

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:88
# args: 
the\ minimal\ resource\ unit\ is\ megabyte,\ cannot\ be\ byte = 资源的最小单位必须为mb，而不是kb

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:96
# args: 
price\ must\ be\ 0\ and\ 9999.99 = 价格必须在0和9999.99之间

# at: src/main/java/org/zstack/compute/allocator/BackupStorageSelectPrimaryStorageAllocatorFlow.java:97
# args: spec.getRequiredBackupStorageUuid(),bsType
the\ backup\ storage[uuid\:%s,\ type\:%s]\ requires\ bound\ primary\ storage,\ however,\ the\ primary\ storage\ has\ not\ been\ added = 无法找到跟备份存储[uuid:{0}, type:{1}]配对的主存储。一些备份存储必须跟配对的主存储共同使用，例如Ceph备份存储只能搭配Ceph主存储使用。请检查你主存储的设置。

# at: src/main/java/org/zstack/compute/allocator/BackupStorageSelectPrimaryStorageAllocatorFlow.java:90
# args: spec.getImage().getUuid(),spec.getRequiredBackupStorageUuid(),type,psUuids
The\ image[uuid\:%s]\ is\ on\ the\ backup\ storage[uuid\:%s,\ type\:%s]\ that\ requires\ to\ work\ with\ primary\ storage[uuids\:%s],however,\ no\ host\ found\ suitable\ to\ work\ with\ those\ primary\ storage = 镜像[uuid:{0}]所在的备份存储[uuid:{1}, type:{2}]必须跟主存储[uuid:{3}]配对使用，但无法找到可以跟满足条件并可以访问该主存储的物理机

# at: src/main/java/org/zstack/compute/allocator/BackupStorageSelectPrimaryStorageAllocatorFlow.java:80
# args: spec.getImage().getUuid(),spec.getImage().getType(),spec.getRequiredBackupStorageUuid(),type,possiblePrimaryStorageTypes
The\ image[uuid\:%s,\ type\:%s]\ is\ on\ the\ backup\ storage[uuid\:%s,\ type\:%s]\ that\ requires\ to\ work\ with\ primary\ storage[types\:%s],however,\ no\ host\ found\ suitable\ to\ work\ with\ those\ primary\ storage = 

# at: src/main/java/org/zstack/compute/allocator/HostAllocatorApiInterceptor.java:56
# args: 
either\ volumeUuid\ or\ volumeSnapshotUuid\ must\ be\ set = 盘uuid或者快照uuid必须被设置

# at: src/main/java/org/zstack/compute/allocator/HostAllocatorApiInterceptor.java:75
# args: 
zoneUuids,\ clusterUuids,\ hostUuids\ must\ at\ least\ have\ one\ be\ none-empty\ list,\ or\ all\ is\ set\ to\ true = 区域uuid，集群uuid,物理机uuid必须有一个不为空，或者全部都填写

# at: src/main/java/org/zstack/compute/allocator/ImageBackupStorageAllocatorFlow.java:85
# args: spec.getImage().getUuid(),spec.getImage().getName()
the\ image[uuid\:%s,\ name\:%s]\ is\ deleted\ on\ all\ backup\ storage = 镜像[uuid:{0}, name:{1}]已经从所有备份存储上删除，无法执行相应操作

# at: src/main/java/org/zstack/compute/host/HostApiInterceptor.java:84
# args: msg.getManagementIp()
there\ has\ been\ a\ host\ having\ managementIp[%s] = 该物理机已经存在在管理节点[{0}]中

# at: src/main/java/org/zstack/compute/host/HostApiInterceptor.java:78
# args: msg.getManagementIp()
managementIp[%s]\ is\ neither\ an\ IPv4\ address\ nor\ a\ valid\ hostname = 管理节点[{0}]既不是有效的IPv4地址也不是有效的物理机名

# at: src/main/java/org/zstack/compute/host/HostApiInterceptor.java:94
# args: msg.getHostUuid()
can\ not\ maintain\ host[uuid\:%s]which\ is\ connecting = 不能对Connecting状态的物理机[uuid:{0}]进行维护操作

# at: src/main/java/org/zstack/compute/host/HostBase.java:104
# args: self.getUuid(),self.getName(),self.getState()
host[uuid\:%s,\ name\:%s]\ is\ in\ state[%s],\ cannot\ perform\ required\ operation = 物理机[uuid:{0}, name:{1}]处于状态[{2}]中，不能处理该请求

# at: src/main/java/org/zstack/compute/host/HostBase.java:420
# args: 
cannot\ change\ the\ state\ of\ disconnected\ host\ into\ maintain\  = 失连状态的物理机不能进入维护模式

# at: src/main/java/org/zstack/compute/host/HostBase.java:566
# args: 
host\ is\ connecting = 物理机正在连接

# at: src/main/java/org/zstack/compute/host/HostManagerImpl.java:275
# args: vo.getName(),vo.getManagementIp()
after\ connecting,\ host[name\:%s,\ ip\:%s]\ returns\ a\ null\ os\ version = 在连接操作后，物理机[name:{0}, ip:{1}]没有返回操作系统版本

# at: src/main/java/org/zstack/compute/host/HostManagerImpl.java:314
# args: vo.getClusterUuid(),currentVersion,vo.getName(),vo.getManagementIp(),mineVersion
cluster[uuid\:%s]\ already\ has\ host\ with\ os\ version[%s],\ but\ new\ added\ host[name\:%s\ ip\:%s]\ has\ host\ os\ version[%s] = 集群[uuid:{0}]中物理机使用的操作系统版本是[{1}]，但是新的物理机[name:{2} ip:{3}]的操作系统版本是 [{4}]

# at: src/main/java/org/zstack/compute/vm/AbstractVmInstance.java:149
# args: currentState,msg.getMessageName(),checker.getStatesForOperation(msg.getMessageName())
current\ vm\ instance\ state[%s]\ doesn't\ allow\ to\ proceed\ message[%s],\ allowed\ states\ are\ %s = 虚拟机状态[{0}]不允许支持的消息[{1}]，允许的状态是{2}

# at: src/main/java/org/zstack/compute/vm/ChangeVmPasswordFlow.java:50
# args: 
not\ dest\ host\ found\ in\ db,\ can't\ send\ change\ password\ cmd\ to\ the\ host! = 没有在物理机上发现数据库，不能发送更改密码的指令到这个物理机上

# at: src/main/java/org/zstack/compute/vm/ChangeVmPasswordFlow.java:51
# args: 
not\ system\ tag\ found\ on\ vm,\ vm\ must\ have\ the\ following\ system\ tag\:\ qemuga,\ if\ you\ installed\ qemu-ga\ yourself,\ please\ use\ CreateSystemTag\ first. = 没有发现系统标签在云主机上，云主机必须有系统标签：qemuga。如果你已经安装了qemu-ga，请先使用 CreateSystemTag

# at: src/main/java/org/zstack/compute/vm/ChangeVmPasswordFlow.java:54
# args: 
not\ account\ preference\ found,\ \ send\ change\ password\ cmd\ to\ the\ host! = 没有优先级账户去发送改变密码的指令到物理机

# at: src/main/java/org/zstack/compute/vm/DeleteVmGC.java:43
# args: hostUuid
the\ host[uuid\:%s]\ is\ not\ connected = 物理机[uuid:{0}]不是Connected状态

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:337
# args: 
direction\ must\ be\ set\ to\ in\ or\ out = 方法必须设置in或者out

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:498
# args: amsg.getVmInstanceUuid()
not\ dest\ host\ found\ in\ db\ by\ uuid\:\ %s,\ can't\ send\ change\ password\ cmd\ to\ the\ host! = 没有在物理机{0}上发现数据库，不能发送更改密码的指令到这个物理机上

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:519
# args: 
state\ is\ not\ correct\ while\ change\ password. = 该状态不支持修改密码

# at: src/main/java/org/zstack/compute/vm/VmDownloadIsoFlow.java:64
# args: iso.getUuid(),host.getZoneUuid(),spec.getVmInventory().getName(),spec.getVmInventory().getUuid()
cannot\ find\ the\ iso[uuid\:%s]\ in\ any\ connected\ backup\ storage\ attached\ to\ the\ zone[uuid\:%s].\ check\ below\:\
1.\ if\ the\ backup\ storage\ is\ attached\ to\ the\ zone\ where\ the\ VM[name\:\ %s,\ uuid\:%s]\ is\ running\
2.\ if\ the\ backup\ storage\ is\ in\ connected\ status,\ if\ not,\ try\ reconnecting\ it = 不能发现iso[uuid:{0}]在任何已经挂载到集群[uuid:{1}]上的并且处于Connected状态备份的备份存储。可以进行对以下选项的检查：1. 备份存储是否已经挂载到区域中的任何运行状态的云主机[name: {2}, uuid:{3}]上；2. 如果备份存储不是处于连接状态，请尝试重连

# at: src/main/java/org/zstack/compute/vm/VmImageSelectBackupStorageFlow.java:85
# args: imageUuid,spec.getVmInventory().getName(),spec.getVmInventory().getUuid()
cannot\ find\ the\ image[uuid\:%s]\ in\ any\ connected\ backup\ storage.\ check\ below\:\
1.\ if\ the\ backup\ storage\ is\ attached\ to\ the\ zone\ where\ the\ VM[name\:\ %s,\ uuid\:%s]\ is\ in\
2.\ if\ the\ backup\ storage\ is\ in\ connected\ status,\ if\ not,\ try\ reconnecting\ it = 不能发现镜像[uuid:{0}]在任何处于Connected状态备份的备份存储。可以进行对以下选项的检查：1. 备份存储是否已经过载到区域中的云主机[name: {1}, uuid:{2}]中；2. 如果备份存储不是处于连接状态，请尝试重连

# at: src/main/java/org/zstack/compute/vm/VmImageSelectBackupStorageFlow.java:79
# args: imageUuid,spec.getVmInventory().getZoneUuid(),spec.getVmInventory().getName(),spec.getVmInventory().getUuid()
cannot\ find\ the\ image[uuid\:%s]\ in\ any\ connected\ backup\ storage\ attached\ to\ the\ zone[uuid\:%s].\ check\ below\:\
1.\ if\ the\ backup\ storage\ is\ attached\ to\ the\ zone\ where\ the\ VM[name\:\ %s,\ uuid\:%s]\ is\ in\
2.\ if\ the\ backup\ storage\ is\ in\ connected\ status,\ if\ not,\ try\ reconnecting\ it = 不能发现镜像[uuid:{0}]在任何已经挂载到集群[uuid:{1}]上的并且处于Connected状态备份的备份存储。可以进行对以下选项的检查：1. 备份存储是否已经过载到区域中的云主机[name: {2}, uuid:{3}]中；2. 如果备份存储不是处于Connected状态，请尝试重连

# at: src/main/java/org/zstack/compute/vm/VmImageSelectBackupStorageFlow.java:107
# args: zoneUuid,isoImageUuid
no\ backup\ storage\ attached\ to\ the\ zone[uuid\:%s]\ contains\ the\ ISO[uuid\:%s] = 没有备份存储挂载到区域[uuid:{0}]包含着ISO[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:127
# args: 
the\ host\ doesn't\ have\ enough\ capacity = 物理机没有足够的容量

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:136
# args: 
either\ l3NetworkUuids\ or\ imageUuid\ must\ be\ set = L3网络的uuid们或者镜像的uuid必须被设置

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:180
# args: msg.getVmInstanceUuid()
vm[uuid\:%s]\ can\ only\ create\ scheduler\ when\ state\ is\ not\ Destroyed = 云主机[uuid:{0}]只能在不是删除状态下创建定时计划

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:187
# args: msg.getIp()
%s\ is\ not\ a\ valid\ IPv4\ address = {0}不是有效的IPv4地址

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:204
# args: msg.getVmInstanceUuid(),msg.getL3NetworkUuid()
the\ VM[uuid\:%s]\ has\ no\ nic\ on\ the\ L3\ network[uuid\:%s] = 云主机[uuid:{0}]毛医生camile

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:215
# args: o,msg.getBootOrder()
invalid\ boot\ device[%s]\ in\ boot\ order%s = 在启动列表{1}中的设备[{0}]启动失败

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:231
# args: msg.getVmInstanceUuid(),isoUuid
VM[uuid\:%s]\ already\ has\ an\ ISO[uuid\:%s]\ attached = 云主机[uuid:{0}]已经挂载了ISO[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:243
# args: type
unable\ to\ attach\ a\ L3\ network.\ The\ vm[uuid\:\ %s]\ is\ not\ a\ user\ vm = 不能挂载L3网络，云主机[uuid: {0}]不是用户虚拟机

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:315
# args: msg.getVmInstanceUuid(),state
unable\ to\ detach\ a\ L3\ network.\ The\ vm[uuid\:\ %s]\ is\ not\ Running\ or\ Stopped;\ the\ current\ state\ is\ %s = 不能挂载L3网络，云主机[uuid: {0}]不是运行状态或者暂停状态，状态为{1}

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:255
# args: msg.getL3NetworkUuid(),msg.getVmInstanceUuid()
unable\ to\ attach\ a\ L3\ network.\ The\ L3\ network[uuid\:%s]\ is\ already\ attached\ to\ the\ vm[uuid\:\ %s] = 不能挂载L3网络，l3网络[uuid:{0}]已经挂载到云主机[uuid: {1}]上了

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:266
# args: msg.getL3NetworkUuid()
unable\ to\ attach\ a\ L3\ network.\ The\ L3\ network[uuid\:%s]\ is\ disabled = 不能挂载L3网络，因为该L3网络[uuid:{0}]处于未启动状态

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:269
# args: msg.getL3NetworkUuid()
unable\ to\ attach\ a\ L3\ network.\ The\ L3\ network[uuid\:%s]\ is\ a\ system\ network = 不能挂载L3网络，该L3网络[uuid:{0}] 是系统网络

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:279
# args: msg.getStaticIp(),msg.getL3NetworkUuid()
the\ static\ IP[%s]\ is\ not\ in\ any\ IP\ range\ of\ the\ L3\ network[uuid\:%s] = 该静态IP[{0}]不在L3网络[uuid:{1}]的任何IP段

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:295
# args: msg.getStaticIp(),msg.getL3NetworkUuid()
the\ static\ IP[%s]\ has\ been\ occupied\ on\ the\ L3\ network[uuid\:%s] = 该静态IP[{0}]已经存在在L3网络[uuid:{1}]中

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:311
# args: msg.getVmInstanceUuid()
unable\ to\ detach\ a\ L3\ network.\ The\ vm[uuid\:\ %s]\ is\ not\ a\ user\ vm = 不能挂载L3网络，云主机[uuid: {0}]不是用户云主机

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:339
# args: msg.getVmInstanceUuid(),state
vm[uuid\:%s]\ can\ only\ attach\ volume\ when\ state\ is\ Running\ or\ Stopped,\ current\ state\ is\ %s = 云主机[uuid:{0}]挂载盘时状态只能是运行或者暂停状态，而现在的状态是{1}

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:349
# args: msg.getInstanceOfferingUuid()
instance\ offering[uuid\:%s]\ is\ Disabled,\ can't\ create\ vm\ from\ it = 计算规格[uuid:{0}]没有被启用，不能根据该规格创建云主机

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:358
# args: msg.getImageUuid()
image[uuid\:%s]\ is\ Disabled,\ can't\ create\ vm\ from\ it = 镜像[uuid:{0}]没被启用，不能根据该镜像创建云主机

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:355
# args: msg.getImageUuid(),imgFormat
image[uuid\:%s]\ is\ of\ mediaType\:\ %s,\ only\ RootVolumeTemplate\ and\ ISO\ can\ be\ used\ to\ create\ vm = 镜像[uuid:{0}] 类型为{1}，该镜像只能用来创建根云盘或者用来创建云主机

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:359
# args: 
rootDiskOfferingUuid\ cannot\ be\ null\ when\ image\ mediaType\ is\ ISO = 根云盘规格不能为空在镜像类型为ISO时

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:364
# args: msg.getImageUuid()
image[uuid\:%s]\ is\ system\ image,\ can't\ be\ used\ to\ create\ user\ vm = 镜像[uuid:{0}] 是系统镜像，不能使用它创建用户虚拟机

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:398
# args: diskUuids
disk\ offerings[uuids\:%s]\ are\ Disabled,\ can\ not\ create\ vm\ from\ it = 磁盘规格[uuids:{0}]没有被启用，不能使用它创建云主机

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:407
# args: duplicateElements.get(0)
Can't\ add\ same\ uuid\ in\ the\ l3Network,uuid\:\ %s = 不能添加相同的uuid{0}在L3网络中

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:417
# args: l3Uuid
l3Network[uuid\:%s]\ is\ Disabled,\ can\ not\ create\ vm\ on\ it = L3网络[uuid:{0}]没有被启用，不能从这个L3网络创建云主机

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:421
# args: l3Uuid
l3Network[uuid\:%s]\ is\ system\ network,\ can\ not\ create\ user\ vm\ on\ it = L3网络[uuid:{0}]是系统网络，不能在这上面创建云主机

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:439
# args: msg.getZoneUuid()
zone[uuid\:%s]\ is\ specified\ but\ it's\ Disabled,\ can\ not\ create\ vm\ from\ it = 区域[uuid:{0}]虽然被指定了但是处于未启用状态，不能从这上面创建云主机

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:449
# args: msg.getClusterUuid()
cluster[uuid\:%s]\ is\ specified\ but\ it's\ Disabled,\ can\ not\ create\ vm\ from\ it = 集群[uuid:{0}]虽然被指定了但是处于未启用状态，不能从这上面创建云主机

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:460
# args: msg.getHostUuid()
host[uuid\:%s]\ is\ specified\ but\ it's\ Disabled,\ can\ not\ create\ vm\ from\ it = 物理机[uuid:{0}]虽然被指定了但是处于未启用状态，不能从这上面创建云主机

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:465
# args: msg.getHostUuid(),connectionState
host[uuid\:%s]\ is\ specified\ but\ it's\ connection\ status\ is\ %s,\ can\ not\ create\ vm\ from\ it = 物理机[uuid:{0}]虽然被指定了但是它的连接状态是{1}，不能从这上面创建云主机

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:464
# args: msg.getDefaultL3NetworkUuid(),msg.getL3NetworkUuids()
defaultL3NetworkUuid[uuid\:%s]\ is\ not\ in\ l3NetworkUuids%s = 默认L3网络的uuid是[uuid:{0}]，不在L3网络uuid们中{1}

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:460
# args: 
there\ are\ more\ than\ one\ L3\ network\ specified\ in\ l3NetworkUuids,\ but\ defaultL3NetworkUuid\ is\ null = 在L3网络uuid们中有很多L3网络被指定了，但是默认L3网络的uuid是空的

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:482
# args: 
The\ console\ password\ cannot\ start\ with\ 'password'\ which\ may\ trigger\ a\ VNC\ security\ issue = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:221
# args: vo.getUuid(),vo.getName()
vm[uuid\:%s,\ name\:%s]\ has\ been\ deleted = 云主机[uuid:{0}, name:{1}]已经被卸载了

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:529
# args: self.getUuid(),l3Uuid
the\ vm[uuid\:%s]\ has\ no\ nic\ on\ the\ L3\ network[uuid\:%s] = 云主机[uuid:{0}] 没有网卡在L3网络[uuid:{1}]上

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:877
# args: 
the\ vm\ has\ been\ deleted = 云主机已经被卸载了

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:1214
# args: 
cannot\ get\ target\ migration\ host\ without\ any\ nics\ on\ vm = 不能在云主机上通过网卡获取目标迁移物理机地址

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:2869
# args: isoUuid,psUuid,self.getName(),self.getUuid()
the\ ISO[uuid\:%s]\ is\ on\ backup\ storage\ that\ is\ not\ compatible\ of\ the\ primary\ storage[uuid\:%s]\ where\ the\ VM[name\:%s,\ uuid\:%s]\ is\ on = ISO[uuid:{0}]在备份存储上，这个ISO不能兼容主存储[uuid:{1}]在云主机[name:{2}, uuid:{3}]上

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:3085
# args: self.getUuid(),self.getState(),StringUtils.join(list(VmInstanceState.Running, VmInstanceState.Stopped), ",")
The\ state\ of\ vm[uuid\:%s]\ is\ %s.\ Only\ these\ state[%s]\ is\ allowed. = 虚拟机[uuid:{0}]的状态是{1}。仅状态为[{2}]的才被允许进行当前操作

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:3680
# args: self.getUuid()
unable\ to\ start\ the\ vm[uuid\:%s].\ It\ doesn't\ have\ any\ nic,\ please\ attach\ a\ nic\ and\ try\ again = 无法启动虚拟机[uuid:{0}]。该虚拟机没有网卡，请添加网卡后再试

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:41
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceStartNewCreatedVmExtensionPoint[%s]\ refuses\ to\ create\ vm[uuid\:%s]\ because\ %s = VmInstanceStartNewCreatedVmExtensionPoint[{0}] 因为{2} 拒绝创建虚拟机[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:83
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceStopVmExtensionPoint[%s]\ refuses\ to\ stop\ vm[uuid\:%s]\ because\ %s = VmInstanceStopVmExtensionPoint[{0}] 因为{2} 拒绝创建虚拟机[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:125
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceRebootExtensionPoint[%s]\ refuses\ to\ reboot\ vm[uuid\:%s]\ because\ %s = VmInstanceRebootExtensionPoint[{0}] 因为{2} 拒绝重启虚拟机[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:167
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceDestroyVmExtensionPoint[%s]\ refuses\ to\ destroy\ vm[uuid\:%s]\ because\ %s = VmInstanceDestroyVmExtensionPoint[{0}] 因为{2} 拒绝删除虚拟机[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:208
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceStartExtensionPoint[%s]\ refuses\ to\ start\ vm[uuid\:%s]\ because\ %s = VmInstanceStartExtensionPoint[{0}] 因为{2} 拒绝启动虚拟机[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:404
# args: msg.getImageUuid(),msg.getZoneUuid()
the\ image[uuid\:%s]\ is\ not\ on\ any\ backup\ storage\ that\ has\ been\ attached\ to\ the\ zone[uuid\:%s] = 镜像[uuid:{0}]不在任何加载到区域[uuid:{1}]的备份存储上

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:467
# args: image.getName(),image.getUuid()
the\ image[name\:%s,\ uuid\:%s]\ is\ an\ ISO,\ rootDiskOfferingUuid\ must\ be\ set = 镜像[name:{0}, uuid:{1}]是一个IOS, 必须设置根云盘规格

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:507
# args: image.getName(),image.getUuid()
zoneUuid\ must\ be\ set\ because\ the\ image[name\:%s,\ uuid\:%s]\ is\ on\ multiple\ backup\ storage = zoneUuid必须被设置，因为image[name:{0}, uuid:{1}]在多个备份存储上

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:877
# args: hostname,tag
hostname[%s]\ specified\ in\ system\ tag[%s]\ is\ not\ a\ valid\ domain\ name = 在系统标签[{1}]中特别声明的主机名[{0}]不是一个有效的域名

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:889
# args: hostnameCount
only\ one\ hostname\ system\ tag\ is\ allowed,\ but\ %s\ got = 只允许通过系统标签设置一个主机名，但是实际上有{0}

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:906
# args: l3Uuid,sysTag
L3\ network[uuid\:%s]\ not\ found.\ Please\ correct\ your\ system\ tag[%s]\ of\ static\ IP = 找不到L3网络[uuid:0]。请修改你关于静态IP的系统标签

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:912
# args: ip,sysTag
%s\ is\ not\ a\ valid\ IPv4\ address.\ Please\ correct\ your\ system\ tag[%s]\ of\ static\ IP = {0}不是一个有效的IPv4地址。请修改你关于静态IP的系统标签

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:940
# args: ip,l3Uuid
IP[%s]\ is\ not\ available\ on\ the\ L3\ network[uuid\:%s] = 在L3网络[uuid:{1}]中，IP[{0}]不可达

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:946
# args: tag,sameTag.getResourceUuid(),hostname,l3Uuid
conflict\ hostname\ in\ system\ tag[%s];\ there\ has\ been\ a\ VM[uuid\:%s]\ having\ hostname[%s]\ on\ L3\ network[uuid\:%s] = 系统标签的主机名存在冲突[{0}]；已经存在以一个主机名为[{2}]的VM[uuid:{1}]出现在L3网络[uuid:{3}]中

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:977
# args: o,order
invalid\ boot\ device[%s]\ in\ boot\ order[%s] = 在引导顺序[{1}]中存在无效的引导设备[{0}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1959
# args: ref.getResourceUuid()
the\ resource[uuid\:%s]\ is\ a\ ROOT\ volume,\ you\ cannot\ change\ its\ owner,\ instead,change\ the\ owner\ of\ the\ VM\ the\ root\ volume\ belongs\ to = 当前资源[uuid:{0}]是一个根云盘，你不能改变它的所有者，但是你能够修改对应VM的所有者

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:39
# args: 
either\ uuid\ or\ account\ or\ password\ must\ be\ set = uuid或者账户或者密码需要被设置

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:47
# args: msg.getDirection()
direction\ must\ be\ set\ in\ (in,\ out),\ but\ was\ %s = 方向必须设置在(in, out)，但是输入的是{0}

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:53
# args: 
outboundBandwidth\ and\ inboundBandwidth\ must\ be\ set\ at\ lease\ one. = 上行带宽和下行带宽至少有一个需要被设置

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:62
# args: msg.getUuid()
nic\ id\:\ %s\ does\ not\ exist... = 网卡id: {0}不存在

# at: src/main/java/org/zstack/configuration/ConfigurationApiInterceptor.java:76
# args: msg.getAllocatorStrategy()
unsupported\ host\ allocation\ strategy[%s] = 不被支持的主机分配策略[{0}]

# at: src/main/java/org/zstack/configuration/ConfigurationApiInterceptor.java:80
# args: msg.getType()
unsupported\ instance\ offering\ type[%s] = 不被支持的计算规格类型[{0}]

# at: src/main/java/org/zstack/configuration/ConfigurationApiInterceptor.java:84
# args: msg.getCpuNum()
cpu\ num[%s]\ is\ less\ than\ 1 = cpu数量[{0}]少于1

# at: src/main/java/org/zstack/configuration/ConfigurationApiInterceptor.java:88
# args: msg.getMemorySize()
memory\ size[%s\ bytes]\ is\ less\ than\ 16M,\ no\ modern\ operating\ system\ is\ likely\ able\ to\ boot\ with\ such\ small\ memory\ size = 内存大小[{0} bytes]少于16M，没有一个现代操作系统能够在如此小的内存里被引导

# at: src/main/java/org/zstack/configuration/ConfigurationApiInterceptor.java:94
# args: msg.getAllocationStrategy()
unsupported\ primary\ storage\ allocation\ strategy[%s] = 不被支持的主存储分配策略[{0}]

# at: src/main/java/org/zstack/console/AbstractConsoleProxyBackend.java:101
# args: 
the\ console\ agent\ is\ not\ connected;\ it's\ mostly\ like\ the\ management\ node\ just\ starts,\ please\ wait\ for\ the\ console\ agent\ connected. = 控制台代理失联，很有可能管理节点刚刚启动，请等待控制台代理的连接

# at: src/main/java/org/zstack/console/AbstractConsoleProxyBackend.java:122
# args: vm.getUuid()
cannot\ find\ host\ IP\ of\ the\ vm[uuid\:%s],\ is\ the\ vm\ running??? = 无法找到vm[uuid:{0}]的主机IP，请确认该vm是否在运行？？？

# at: src/main/java/org/zstack/console/ConsoleApiInterceptor.java:48
# args: msg.getVmInstanceUuid(),state
Console\ is\ only\ available\ when\ the\ VM[uuid\:%s]\ is\ Running,\ but\ the\ current\ state\ is\ %s = 控制台仅仅当VM[uuid:{0}]处于运行状态才可用，但是现在的状态为{1}

# at: src/main/java/org/zstack/console/ConsoleProxyBase.java:140
# args: ret.getError()
unable\ to\ check\ console\ proxy\ availability,\ because\ %s = 无法检查控制台代理是否可用，因为{0}

# at: src/main/java/org/zstack/console/ManagementServerConsoleProxyBackend.java:303
# args: uuid
invalid\ management\ node\ UUID[%s] = 非法的管理节点UUID[{0}]

# at: src/main/java/org/zstack/core/ansible/SshFolderMd5Checker.java:107
# args: srcFolder,srcRes.getStdout(),srcRes.getStderr()
cannot\ check\ md5sum\ of\ files\ in\ the\ folder[%s].\nstdout\:%s\nstderr\:%s = 无法检查文件夹[{0}]下文件的md5sum.\nstdout:{1}\nstderr:{2}

# at: src/main/java/org/zstack/core/ansible/SshFolderMd5Checker.java:122
# args: dstFolder,hostname,dstRes.getStdout(),dstRes.getStderr()
cannot\ check\ md5sum\ of\ files\ in\ the\ folder[%s]\ on\ the\ host[ip\:%s].\nstdout\:%s\nstderr\:%s = 无法检查主机[ip:{1}]的文件夹[{0}]下文件的md5sum.\nstdout:{2}\nstderr:{3}

# at: src/main/java/org/zstack/core/cloudbus/CloudBusImpl2.java:686
# args: errMsg
message\ is\ not\ in\ corrected\ JSON\ mediaType,\ %s = 消息是错误的JSON格式，{0}

# at: src/main/java/org/zstack/core/config/GlobalConfigFacadeImpl.java:71
# args: msg.getCategory(),msg.getName()
unable\ to\ find\ GlobalConfig[category\:%s,\ name\:%s] = 无法找到全局变量[category:{0}, name:{1}]

# at: src/main/java/org/zstack/core/config/GlobalConfigFacadeImpl.java:101
# args: msg.getCategory(),msg.getName()
Unable\ to\ find\ GlobalConfig[category\:\ %s,\ name\:\ %s] = 无法找到全局变量[category:{0}, name:{1}]

# at: src/main/java/org/zstack/core/gc/GarbageCollectorManagerImpl.java:210
# args: vo.getUuid(),vo.getName()
cannot\ trigger\ a\ finished\ GC\ job[uuid\:%s,\ name\:%s] = 无法触发一个完成过的GC任务

# at: src/main/java/org/zstack/core/progress/ProgressReportService.java:92
# args: processType
not\ supported\ processType\:\ %s = 不被支持的处理类型。

# at: src/main/java/org/zstack/core/progress/ProgressReportService.java:173
# args: 
not\ supported\ null\ uuid = 

# at: src/main/java/org/zstack/core/rest/RESTFacadeImpl.java:454
# args: url,rsp.getStatusCode(),rsp.getBody()
failed\ to\ post\ to\ %s,\ status\ code\:\ %s,\ response\ body\:\ %s = 发送消息到{0}失败，状态码: {1}, 返回: {2}

# at: src/main/java/org/zstack/core/rest/RESTFacadeImpl.java:495
# args: url,timeout
unable\ to\ echo\ %s\ in\ %sms = 无法在{1}ms内返回{0}

# at: src/main/java/org/zstack/core/retry/Retry.java:73
# args: __name__,times,interval
an\ operation[%s]\ fails\ after\ retrying\ %s\ times\ with\ the\ interval\ %s\ seconds = 在重试{1}次间隔时间为{2}后操作[{0}]失败

# at: src/main/java/org/zstack/core/salt/SaltRunner.java:297
# args: stateName,targetIp,retry
failed\ to\ run\ salt\ state[%s]\ on\ system[%s],\ failed\ after\ %s\ retries = 重试{2}次之后，在系统[{1}]上运行加盐状态[{0}]失败

# at: src/main/java/org/zstack/core/scheduler/SchedulerApiInterceptor.java:79
# args: 
can\ not\ enable\ a\ Enabled\ scheduler = 无法启用一个已经启用的定时任务

# at: src/main/java/org/zstack/core/scheduler/SchedulerApiInterceptor.java:82
# args: 
can\ not\ disable\ a\ Disabled\ scheduler = 不能够停用一个已经停用的定时任务

# at: src/main/java/org/zstack/core/scheduler/SchedulerApiInterceptor.java:120
# args: 
stopTime\ out\ of\ mysql\ timestamp\ range = 定时任务停止时间超出mysql的timestamp的范围

# at: src/main/java/org/zstack/core/scheduler/SchedulerApiInterceptor.java:116
# args: 
duration\ time\ out\ of\ range = 任务需要的时间超出范围

# at: src/main/java/org/zstack/core/scheduler/SchedulerApiInterceptor.java:98
# args: 
interval\ must\ be\ positive\ integer = 间隔时间必须是正整数

# at: src/main/java/org/zstack/core/scheduler/SchedulerApiInterceptor.java:95
# args: 
interval\ must\ be\ set\ when\ use\ simple\ scheduler\ when\ repeat\ forever = 当简单定时任务永远重复的时，必须设置间隔时间

# at: src/main/java/org/zstack/core/scheduler/SchedulerApiInterceptor.java:92
# args: 
interval\ must\ be\ set\ when\ use\ simple\ scheduler\ when\ repeat\ more\ than\ once = 当简单定时任务执行超过一次时，必须设置间隔时间

# at: src/main/java/org/zstack/core/scheduler/SchedulerApiInterceptor.java:108
# args: 
startTime\ out\ of\ range = 开始时间超出范围

# at: src/main/java/org/zstack/core/scheduler/SchedulerApiInterceptor.java:104
# args: 
startTime\ must\ be\ positive\ integer\ or\ 0 = 开始时间必须是正整数或者0

# at: src/main/java/org/zstack/core/scheduler/SchedulerApiInterceptor.java:102
# args: 
startTime\ must\ be\ set\ when\ use\ simple\ scheduler = 必须设置简单定时任务的开始时间

# at: src/main/java/org/zstack/core/scheduler/SchedulerApiInterceptor.java:112
# args: 
repeatCount\ must\ be\ positive\ integer = 重复次数必须为正整数

# at: src/main/java/org/zstack/core/scheduler/SchedulerApiInterceptor.java:118
# args: 
cron\ must\ be\ set\ when\ use\ cron\ scheduler = 当使用定时器任务时，必须设置cron

# at: src/main/java/org/zstack/core/scheduler/SchedulerApiInterceptor.java:121
# args: 
cron\ task\ must\ follow\ format\ like\ this\ \:\ \"0\ 0/3\ 17-23\ *\ *\ ?\"\  = 定时器任务必须符合以下格式：\"0 0/3 17-23 * * ?\" 

# at: src/main/java/org/zstack/core/scheduler/SchedulerApiInterceptor.java:124
# args: 
cron\ scheduler\ only\ need\ to\ specify\ cron\ task = 

# at: src/main/java/org/zstack/ha/HaKvmHostSiblingChecker.java:153
# args: struct.getHostUuid(),struct.getHostIp(),errors
hosts\ failed\ to\ port\ scan\ the\ failure\ host[uuid\:%s,\ ip\:%s],\ errors\ are\ %s = 扫描物理机失败[uuid:{0}, ip:{1}]，错误原因是 {2}

# at: src/main/java/org/zstack/ha/HaKvmWorker.java:63
# args: self.getName(),self.getUuid()
cannot\ find\ the\ host\ of\ the\ vm[name\:%s,\ uuid\:%s],\ hostUuid\ is\ null = 找不到vm[name:{0}, uuid:{1}]的物理机, 因为hostUuid为null

# at: src/main/java/org/zstack/ha/HaKvmWorker.java:70
# args: 
no\ HaHostChecker\ found,\ cannot\ do\ HA = 找不到HaHostChecker，无法执行HA

# at: src/main/java/org/zstack/ha/HaManagementNodeChecker.java:46
# args: 
the\ management\ node\ fails\ to\ scan\ the\ host = 管理节点扫描物理机失败。

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:90
# args: newValue
the\ value[%s]\ is\ lesser\ than\ 0 = 值[{0}]比0小

# at: src/main/java/org/zstack/hybrid/account/HybridAccountApiInterceptor.java:41
# args: 
parameters\ [accountUuid]\ only\ can\ be\ used\ by\ admin\ user! = 

# at: src/main/java/org/zstack/identity/AccountBase.java:299
# args: group.getUuid(),msg.getAccountUuid()
the\ user\ group[uuid\:%s]\ does\ not\ belong\ to\ the\ account[uuid\:%s] = 这个用户组[uuid:{0}]不属于当前账户[uuid:{1}]

# at: src/main/java/org/zstack/identity/AccountBase.java:401
# args: msg.getName(),msg.getIdentityUuid()
cannot\ find\ Quota[name\:\ %s]\ for\ the\ account[uuid\:\ %s] = 无法为当前账户[uuid: {1}]找到Quota

# at: src/main/java/org/zstack/identity/AccountBase.java:460
# args: vo.getUuid(),ruuid
the\ account[uuid\:\ %s]\ doesn't\ have\ a\ resource[uuid\:\ %s] = 账户[uuid: {0}]没有资源[uuid: {1}]

# at: src/main/java/org/zstack/identity/AccountBase.java:497
# args: user.getUuid(),msg.getAccountUuid()
the\ user[uuid\:%s]\ does\ not\ belong\ to\ the\ account[uuid\:%s] = 当前用户[uuid:{0}]不属于当前账户[uuid:{1}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:149
# args: resourceUuid
cannot\ find\ the\ resource[uuid\:%s];\ wrong\ resourceUuid\ or\ the\ resource\ is\ admin\ resource = 无法找到资源[uuid:{0}]：错误的资源uuid或者资源是管理员资源

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:339
# args: msg.getUserUuid()
the\ user\ specified\ by\ the\ userUuid[%s]\ does\ not\ belong\ to\ the\ current\ account,\ and\ the\ current\ account\ is\ not\ an\ admin\ account,\ so\ it\ has\ no\ permission\ to\ check\ the\ user'spermissions = 当前通过userUuid获得的user不属于当前账户，而且当前账户不是管理员账户。

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:371
# args: apiName
%s\ is\ not\ an\ API = {0}不是一个API

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:452
# args: msg.getAccountName()
account[%s]\ not\ found = 没有找到账户[{0}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1014
# args: accountUuid
cannot\ find\ the\ account[uuid\:%s] = 找不到账户[uuid:{0}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1509
# args: 
accountName\ and\ accountUuid\ cannot\ both\ be\ null,\ you\ must\ specify\ at\ least\ one = 账户名和账户Uuid不能同时为空，您必须定义至少一个

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1520
# args: msg.getName(),msg.getAccountUuid()
unable\ to\ create\ a\ group.\ A\ group\ called\ %s\ is\ already\ under\ the\ account[uuid\:%s] = 不能创建用户组，用户组“{0}”已经在账户“{0}”下了

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1530
# args: msg.getName(),msg.getAccountUuid()
unable\ to\ create\ a\ user.\ A\ user\ called\ %s\ is\ already\ under\ the\ account[uuid\:%s] = 不能创建用户，用户“{0}”已经在账户“{0}”下了

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1539
# args: msg.getName()
unable\ to\ create\ an\ account.\ An\ account\ already\ called\ %s = 不能创建账户，“{0}”已经被使用

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1545
# args: 
unable\ to\ delete\ an\ account.\ The\ account\ is\ an\ admin\ account = 不能删除账户，这个账户是一个管理者账户

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1553
# args: 
the\ current\ session\ is\ an\ account\ session.\ You\ need\ to\ specify\ the\ field\ 'uuid'\ of\ the\ user\ you\ want\ to\ update = 当前会话是一个账户会话，你需要定义一个'uuid'字段来指定你要更新的用户

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1564
# args: msg.getUuid()
your\ are\ login\ as\ a\ user,\ you\ cannot\ another\ user[uuid\:%s] = 你已经登录为一个用户，不能成为另一个用户[uuid:{0}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1572
# args: 
all\ is\ set\ to\ false,\ accountUuids\ cannot\ be\ null\ or\ empty = all参数被设为false时，账户uuid不能为空

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1580
# args: 
toPublic\ is\ set\ to\ false,\ accountUuids\ cannot\ be\ null\ or\ empty = toPublic参数被设为false时，账户uuid不能为空

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1629
# args: policy.getName(),policy.getUuid(),msg.getSession().getAccountUuid()
policy[name\:\ %s,\ uuid\:\ %s]\ doesn't\ belong\ to\ the\ account[uuid\:\ %s] = 策略[名称: {0}, uuid: {1}]不属于账户[uuid: {2}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1643
# args: user.getName(),user.getUuid(),msg.getSession().getAccountUuid()
user[name\:\ %s,\ uuid\:\ %s]\ doesn't\ belong\ to\ the\ account[uuid\:\ %s] = 用户[名称: {0}, uuid: {1}]不属于账户[uuid: {2}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1647
# args: group.getName(),group.getUuid(),msg.getSession().getAccountUuid()
group[name\:\ %s,\ uuid\:\ %s]\ doesn't\ belong\ to\ the\ account[uuid\:\ %s] = 用户组[名称: {0}, uuid: {1}]不属于账户[uuid: {2}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1655
# args: JSONObjectUtil.toJsonString(s)
a\ statement\ must\ have\ effect\ field.\ Invalid\ statement[%s] = 声明必须含有'effect'字段。 无效的声明

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1658
# args: JSONObjectUtil.toJsonString(s)
a\ statement\ must\ have\ action\ field.\ Invalid\ statement[%s] = 声明必须含有'action'字段。 无效的声明

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1661
# args: JSONObjectUtil.toJsonString(s)
a\ statement\ must\ have\ a\ non-empty\ action\ field.\ Invalid\ statement[%s] = 声明必须含有不为空的'action'字段。 无效的声明

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1717
# args: 
the\ name\ of\ admin\ account\ cannot\ be\ updated = 不能更改管理员账户名称

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1727
# args: account.getUuid(),account.getName(),msg.getUuid()
account[uuid\:\ %s,\ name\:\ %s]\ is\ a\ normal\ account,\ it\ cannot\ reset\ the\ password\ of\ another\ account[uuid\:\ %s] = [uuid: {0}, 名称: {1}]是一个普通账户，不能被其他普通账户重设密码

# at: src/main/java/org/zstack/image/BackupStorageDeleteBitGC.java:35
# args: backupStorageUuid,bsStatus
the\ backup\ storage[uuid\:%s]\ is\ not\ in\ status\ of\ Connected,\ current\ status\ is\ %s = 镜像存储[uuid:{0}]不是Connected状态，当前状态为{1}

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:74
# args: vol.getUuid(),vol.getStatus()
volume[uuid\:%s]\ is\ not\ Ready,\ it's\ %s = 云盘[uuid:{0}]未Ready，它现在为{1}

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:78
# args: vol.getUuid(),vol.getState()
volume[uuid\:%s]\ is\ not\ Enabled,\ it's\ %s = 云盘[uuid:{0}]未Enabled，它现在为{1}

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:87
# args: vol.getUuid(),vol.getVmInstanceUuid(),state
volume[uuid\:%s]\ is\ attached\ to\ vm[uuid\:%s];\ the\ vm\ is\ not\ Stopped,\ it's\ %s = 云盘[uuid:{0}]被挂载到一个未Stopped的云主机[uuid:{1}]，云盘状态为{2}

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:122
# args: 
ISO\ cannot\ be\ used\ as\ system\ image = ISO不能被作为一个系统标签

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:128
# args: msg.getFormat()
unknown\ format[%s] = 未知格式[{0}]

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:132
# args: msg.getType()
unsupported\ image\ type[%s] = 不支持的镜像类型[{0}]

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:154
# args: msg.getBackupStorageUuids(),BackupStorageStatus.Connected,BackupStorageState.Enabled
no\ backup\ storage\ specified\ in\ uuids%s\ is\ available\ for\ adding\ this\ image;\ they\ are\ not\ in\ status\ %s\ or\ not\ in\ state\ %s,\ or\ the\ uuid\ is\ invalid\ backup\ storage\ uuid = 镜像存储uuids{0}不满足添加镜像的条件；它们的状态不同时满足{1}和{2},亦或者是无效的uuid

# at: src/main/java/org/zstack/image/ImageBase.java:146
# args: self.getUuid(),self.getName()
the\ image[uuid\:%s,\ name\:%s]\ is\ not\ on\ any\ backup\ storage = 镜像[uuid:{0}, 名称:{1}]不在任一镜像存储上

# at: src/main/java/org/zstack/image/ImageBase.java:156
# args: self.getUuid(),self.getName()
No\ connected\ backup\ storage\ found\ for\ image[uuid\:%s,\ name\:%s] = 没有Connected状态的镜像存储来搜索镜像[uuid:{0}, name:{1}]

# at: src/main/java/org/zstack/image/ImageBase.java:531
# args: self.getUuid(),self.getName(),bsUuid
the\ image[uuid\:%s,\ name\:%s]\ is\ not\ on\ the\ backup\ storage[uuid\:%s] = 镜像[uuid:{0}, 名称:{1}]不在镜像存储[uuid:{2}]上

# at: src/main/java/org/zstack/image/ImageBase.java:473
# args: self.getUuid(),self.getName(),ref.getStatus(),bsUuid
the\ image[uuid\:%s,\ name\:%s]'s\ status[%s]\ is\ not\ Deleted\ on\ the\ backup\ storage[uuid\:%s] = 镜像[uuid:{0}, 名称:{1}]的状态[{2}]在镜像存储[uuid:{3}]上不是Deleled

# at: src/main/java/org/zstack/image/ImageBase.java:518
# args: self.getUuid(),self.getName()
the\ image[uuid\:%s,\ name\:%s]\ is\ not\ deleted\ on\ any\ backup\ storage = 镜像[uuid:{0}, 名称:{1}]未在任一镜像存储上被删除

# at: src/main/java/org/zstack/image/ImageBase.java:536
# args: self.getUuid(),self.getName(),bsUuid
the\ image[uuid\:%s,\ name\:%s]\ is\ not\ deleted\ on\ the\ backup\ storage[uuid\:%s] = 镜像[uuid:{0}, 名称:{1}]未在镜像存储[uuid:{}]上被删除

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:286
# args: msg.getBackupStorageUuids(),JSONObjectUtil.toJsonString(errs)
failed\ to\ allocate\ all\ backup\ storage[uuid\:%s],\ a\ list\ of\ error\:\ %s = 镜像存储[uuid:{0}]分配失败，错误清单:{1}

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:378
# args: msg.getVolumeUuid(),msg.getBackupStorageUuids()
failed\ to\ create\ data\ volume\ template\ from\ volume[uuid\:%s]\ on\ all\ backup\ storage%s.\ See\ cause\ for\ one\ of\ errors = 在所有镜像存储[uuid:{1}]上创建云盘[uuid:{0}]的云盘模版失败，查看错误原因

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:695
# args: msg.getBackupStorageUuids(),JSONObjectUtil.toJsonString(errs)
unable\ to\ allocate\ backup\ storage\ specified\ by\ uuids%s,\ list\ errors\ are\:\ %s = 不能根据[uuids:{0}]分配镜像存储，错误清单为：{1}

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:792
# args: msg.getRootVolumeUuid()
failed\ to\ create\ image\ from\ root\ volume[uuid\:%s]\ on\ all\ backup\ storage,\ see\ cause\ for\ one\ of\ errors = 在所有镜像存储上从根云盘[uuid:{0}]创建镜像失败，查看错误原因

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:1006
# args: ivo.getUuid()
image\ [uuid\:%s]\ has\ been\ deleted = 

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:43
# args: msg.getVipUuid(),vip.getUseFor()
the\ vip[uuid\:%s]\ has\ been\ used\ for\ %s = 虚拟IP[uuid:{0}]已经被{1}使用

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:47
# args: msg.getPeerAddress()
the\ peerAddress[%s]\ cannot\ be\ the\ same\ to\ the\ VIP\ address = 对端地址[{0}]不能和虚拟IP地址相同

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:54
# args: msg.getVipUuid()
the\ vip[uuid\:%s]\ has\ been\ used\ by\ another\ IPsec\ connection = 虚拟地址[uuid:{0}]已经被另一个IPsec连接使用

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:59
# args: msg.getPeerAddress()
the\ peerAddress[%s]\ is\ not\ an\ IPv4\ address = 对端地址[{0}]不是一个IPv4地址

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:69
# args: inv.getUuid(),inv.getName()
there\ has\ been\ a\ connection[uuid\:%s,\ name\:%s]\ has\ the\ same\ L3NetworkUuid,\ peerAddress,\ and\ peerCidrs = 已经存在一个连接[uuid:{0}, 名称:{1}]拥有相同的三层网络、对端地址和对端CIDR

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:79
# args: msg.getL3NetworkUuid()
the\ L3\ network[uuid\:%s]\ doesn't\ have\ any\ IP\ range = 三层网络[uuid:{0}]没有IP地址范围

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:85
# args: localCidr,rcidr,msg.getL3NetworkUuid()
the\ local\ CIDR[%s]\ of\ the\ L3\ network[uuid\:%s]\ overlaps\ with\ the\ peerCidr[%s] = 三层网络[uuid:{1}]的本地CIDR[{0}]与对端CIDR[{2}]重叠

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:93
# args: 
the\ authKey\ cannot\ contain\ white\ space\ and\ special\ characters\ of\ '\"`\\ = 验证码不能包含空格和以下字符:'\"`\\

# at: src/main/java/org/zstack/ipsec/vyos/VyosIPsecBackend.java:211
# args: 
vyos\ doesn't\ support\ aes-192\ as\ IkeEncryptionAlgorithm,\ available\ options\ aes-128,\ aes-256,\ 3des = vyos不支持aes-192作为密钥交换加密算法，可用选择为aes-128, aes-256, 3des

# at: src/main/java/org/zstack/ipsec/vyos/VyosIPsecBackend.java:217
# args: 
vyos\ doesn't\ support\ aes-192\ as\ PolicyEncryptionAlgorithm,\ available\ options\ aes-128,\ aes-256,\ 3des = vyos不支持aes-192作为加密算法协议，可用选择为aes-128, aes-256, 3des

# at: src/main/java/org/zstack/kvm/KVMApiInterceptor.java:36
# args: msg.getManagementIp()
there\ has\ been\ a\ kvm\ host\ having\ management\ ip[%s] = 已经存在一个拥有管理节点IP[{0}]的物理机

# at: src/main/java/org/zstack/kvm/KVMConnectExtensionForL2Network.java:125
# args: l2.getType()
KVMConnectExtensionForL2Network\ wont's\ support\ L2Network[type\:%s] = 物理机二层网络连接插件不支持二层网络[类型:{0}]

# at: src/main/java/org/zstack/kvm/KVMHost.java:414
# args: self.getManagementIp(),getSelf().getUsername(),getSelf().getPort(),result.getExitErrorMessage()
unable\ to\ connect\ to\ KVM[ip\:%s,\ username\:%s,\ sshPort\:%d\ ]\ to\ do\ DNS\ check,\ please\ check\ if\ username/password\ is\ wrong;\ %s = 无法连接物理机[ip:{0}, 用户名:{1}, ssh端口:{2} ]做DNS检查，请检查用户名密码是否正确；{3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:486
# args: self.getUuid(),self.getStatus()
the\ host[uuid\:%s,\ status\:%s]\ is\ not\ Connected = 物理机[uuid:{0}, 状态:{1}]不是Connected状态

# at: src/main/java/org/zstack/kvm/KVMHost.java:861
# args: volume.getUuid(),state
cannot\ do\ volume\ snapshot\ merge\ when\ vm[uuid\:%s]\ is\ in\ state\ of\ %s.\ The\ operation\ is\ only\ allowed\ when\ vm\ is\ Running\ or\ Stopped = 当云主机[uuid:{0}]处于{1}状态的时候不能做云盘快照合并。此操作只能在云主机处在Running和Stopped状态时进行

# at: src/main/java/org/zstack/kvm/KVMHost.java:868
# args: KVMConstant.MIN_LIBVIRT_LIVE_BLOCK_COMMIT_VERSION,libvirtVersion
live\ volume\ snapshot\ merge\ needs\ libvirt\ version\ greater\ than\ %s,\ current\ libvirt\ version\ is\ %s.\ Please\ stop\ vm\ and\ redo\ the\ operation\ or\ detach\ the\ volume\ if\ it's\ data\ volume = 实时云盘快照合并需要libvirt版本高于{0}，现在libvirt版本为{1}。请停止云主机后重试或卸载云盘（仅当为数据云盘时）

# at: src/main/java/org/zstack/kvm/KVMHost.java:943
# args: msg.getVmUuid(),vmState
vm[uuid\:%s]\ is\ not\ Running\ or\ Stopped,\ current\ state[%s] = 云主机[uuid:{0}]未处在Runing或Stopped状态all参数被设为false时，账户uuid不能为空，现在状态为[{1}]

# at: src/main/java/org/zstack/kvm/KVMHost.java:1250
# args: msg.getNicInventory().getUuid(),msg.getNicInventory().getVmInstanceUuid(),self.getUuid(),self.getManagementIp(),ret.getError()
failed\ to\ attach\ nic[uuid\:%s,\ vm\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],because\ %s = 在物理机[uuid:{3},IP:{3}]上加载网卡[uuid:{0},云主机:{1}]失败，因为:{4}

# at: src/main/java/org/zstack/kvm/KVMHost.java:1328
# args: vol.getUuid(),vol.getInstallPath(),vm.getUuid(),vm.getName(),getSelf().getUuid(),getSelf().getManagementIp(),ret.getError()
failed\ to\ detach\ data\ volume[uuid\:%s,\ installPath\:%s]\ from\ vm[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = 

# at: src/main/java/org/zstack/kvm/KVMHost.java:1424
# args: vol.getUuid(),vol.getInstallPath(),vm.getUuid(),vm.getName(),getSelf().getUuid(),getSelf().getManagementIp(),ret.getError()
failed\ to\ attach\ data\ volume[uuid\:%s,\ installPath\:%s]\ to\ vm[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = 

# at: src/main/java/org/zstack/kvm/KVMHost.java:1482
# args: vminv.getUuid(),vminv.getName(),self.getUuid(),self.getManagementIp(),e.getMessage()
failed\ to\ destroy\ vm[uuid\:%s\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = 

# at: src/main/java/org/zstack/kvm/KVMHost.java:1648
# args: vminv.getUuid(),vminv.getName(),self.getUuid(),self.getManagementIp(),e.getMessage()
failed\ to\ stop\ vm[uuid\:%s\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = 停止在物理机[uuid:{2}, ip:{3}]上的云主机[uuid:{0} 名称:{1}]失败，因为:{4}

# at: src/main/java/org/zstack/kvm/KVMHost.java:1886
# args: spec.getVmInventory().getUuid(),spec.getVmInventory().getName(),self.getUuid(),self.getManagementIp(),e.getMessage()
failed\ to\ start\ vm[uuid\:%s\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = 启动在物理机[uuid:{2}, ip:{3}]上的云主机[uuid:{0} 名称:{1}]失败，因为:{4}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2126
# args: rsp.getError(),msg.getPhysicalInterface(),context.getInventory().getUuid(),context.getInventory().getManagementIp()
%s,\ failed\ to\ check\ physical\ network\ interfaces[names\ \:\ %s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s] = {0}，检查在物理机[uuid:{2}, ip:{3}]上的物理网络[名称 : {1}]失败

# at: src/main/java/org/zstack/kvm/KVMHost.java:2305
# args: self.getUuid(),self.getManagementIp(),connectPath,rsp.getError()
unable\ to\ connect\ to\ kvm\ host[uuid\:%s,\ ip\:%s,\ url\:%s],\ because\ %s = 连接物理机[uuid:{0}, ip:{1}，url:{2}]失败，因为:{3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2445
# args: checkList
failed\ to\ ping\ all\ DNS/IP\ in\ %s;\ please\ check\ /etc/resolv.conf\ to\ make\ sure\ your\ host\ is\ able\ to\ reach\ public\ internet = 在{0}中的所有DNS/IP都ping失败了，请检查 /etc/resolv.conf 来确保你的主机能连接到公网

# at: src/main/java/org/zstack/kvm/KVMHost.java:2443
# args: self.getManagementIp(),getSelf().getUsername(),getSelf().getPort(),ret.getExitErrorMessage()
unable\ to\ connect\ to\ KVM[ip\:%s,\ username\:%s,\ sshPort\:\ %d,\ ]\ to\ do\ DNS\ check,\ please\ check\ if\ username/password\ is\ wrong;\ %s = 无法连接物理机[ip:{0}, 用户名:{1}, ssh端口:{2} ]做DNS检查，请检查用户名密码是否正确；{3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2473
# args: self.getManagementIp(),Platform.getManagementServerIp(),ret.getStderr(),ret.getExitErrorMessage()
the\ KVM\ host[ip\:%s]\ cannot\ access\ the\ management\ node's\ callback\ url.\ It\ seems\ that\ the\ KVM\ host\ cannot\ reach\ the\ management\ IP[%s].\ %s\ %s = 物理机[ip:{0}] 不能连接到管理节点 。 看起来是这个物理机不能查找到管理节点的IP [{1}]. {2} {3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2470
# args: self.getManagementIp(),getSelf().getUsername(),getSelf().getPort(),ret.getExitErrorMessage()
unable\ to\ connect\ to\ KVM[ip\:%s,\ username\:%s,\ sshPort\:%d]\ to\ check\ the\ management\ node\ connectivity,please\ check\ if\ username/password\ is\ wrong;\ %s = 不能连接到物理机[ip:{0}, username:{1}, sshPort:%d] 去检查与管理节点是否连通  ,请检查您的用户名或者密码是否有误; {2}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2564
# args: self.getUuid(),self.getManagementIp(),ret.getExecutionLog()
unable\ to\ get\ kvm\ host[uuid\:%s,\ ip\:%s]\ facts\ by\ ansible\n%s = 不能获取物理机[uuid:{0}, ip:{1}]的配置管理器\n{2}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2570
# args: ret.getStdout()
unrecognized\ ansible\ facts\ mediaType,\ %s = 

# at: src/main/java/org/zstack/kvm/KVMHost.java:2577
# args: ret.getStdout()
unrecognized\ ansible\ facts\ mediaType,\ cannot\ find\ field\ 'ansible_facts',\ %s = 未授权的配置管理器类型，不能发现'ansible_facts', {0}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2608
# args: 
cannot\ find\ either\ 'vmx'\ or\ 'svm'\ in\ /proc/cpuinfo,\ please\ make\ sure\ you\ have\ enabled\ virtualization\ in\ your\ BIOS\ setting = 不能发现以下任意一个  'vmx' or 'svm' 在路径 /proc/cpuinfo 里, 请检查你是否在你的BIOS设置里开启了virtualization选项

# at: src/main/java/org/zstack/kvm/KVMRealizeL2NoVlanNetworkBackend.java:69
# args: cmd.getBridgeName(),l2Network.getUuid(),l2Network.getType(),hostUuid,rsp.getError()
failed\ to\ create\ bridge[%s]\ for\ l2Network[uuid\:%s,\ type\:%s]\ on\ kvm\ host[uuid\:%s],\ because\ %s = 

# at: src/main/java/org/zstack/kvm/KVMRealizeL2NoVlanNetworkBackend.java:120
# args: cmd.getBridgeName(),l2Network.getUuid(),l2Network.getName(),hostUuid,rsp.getError()
failed\ to\ check\ bridge[%s]\ for\ l2NoVlanNetwork[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:\ %s],\ %s = 在L2网络[uuid:{1}中检查网桥[{0}]失败，名字为[{2}]在物理机t[uuid: {3}]上, {4}

# at: src/main/java/org/zstack/kvm/KVMRealizeL2VlanNetworkBackend.java:72
# args: cmd.getBridgeName(),l2Network.getUuid(),l2Network.getType(),l2vlan.getVlan(),hostUuid,rsp.getError()
failed\ to\ create\ bridge[%s]\ for\ l2Network[uuid\:%s,\ type\:%s,\ vlan\:%s]\ on\ kvm\ host[uuid\:%s],\ because\ %s = 创建L2网络[uuid:{1}中的网桥[{0}]失败 , 类型为：{2}, vlan:{3}] 在物理机[uuid:{4}]上, 原因： {5}

# at: src/main/java/org/zstack/kvm/KVMRealizeL2VlanNetworkBackend.java:124
# args: cmd.getBridgeName(),l2vlan.getUuid(),l2vlan.getName(),hostUuid,rsp.getError()
failed\ to\ check\ bridge[%s]\ for\ l2VlanNetwork[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:%s],\ %s = 检查在物理机[uuid:{3}]上L2网络[uuid:{1}, name:{2}]中的网桥[{0}]失败, {4}

# at: src/main/java/org/zstack/kvm/KVMSecurityGroupBackend.java:97
# args: hto.getHostUuid(),rsp.getError()
failed\ to\ apply\ rules\ of\ security\ group\ rules\ to\ kvm\ host[uuid\:%s],\ because\ %s = 不能应用安全组规则在物理机t[uuid:{0}]上, 因为 {1}

# at: src/main/java/org/zstack/kvm/KvmVmSyncPingTask.java:90
# args: host.getUuid(),host.getManagementIp(),ret.getError()
unable\ to\ do\ vm\ sync\ on\ host[uuid\:%s,\ ip\:%s]\ because\ %s = 不能做vm同步在物理机[uuid:{0}, ip:{1}]上 ，因为{2}

# at: src/main/java/org/zstack/mediator/ApiValidator.java:94
# args: vm.getName(),vm.getUuid(),StringUtils.join(pfStr, ",")
the\ vm[name\:%s,\ uuid\:%s]\ already\ has\ some\ port\ forwarding\ rules%s\ attached = 云主机[name:{0}, uuid:{1}] 已经设置了一些端口转发规则{2}

# at: src/main/java/org/zstack/mediator/ApiValidator.java:115
# args: vm.getName(),vm.getUuid(),StringUtils.join(eipStr, ",")
the\ vm[name\:%s,\ uuid\:%s]\ already\ has\ some\ EIPs%s\ attached = 云主机[name:{0}, uuid:{1}] 已经配置了弹性IP{2}

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:223
# args: psType
for\ shareable\ volume,\ the\ only\ supported\ primary\ storage\ type\ is\ ceph,\ current\ is\ %s = 共享数据盘只支持ceph类型的主存储{0}

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:438
# args: bandwidth
invalid\ network\ bandwidth[%s],\ it\ is\ not\ a\ number = 错误的网络带宽[{0}]，这不是数字

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:435
# args: bandwidth
invalid\ network\ bandwidth[%s],\ it\ must\ be\ greater\ than\ 0 = 错误的网络带宽[{0}]，这个数字必须超过0

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:456
# args: bandwidth
invalid\ volume\ bandwidth[%s]\ is\ not\ a\ number = 错误的磁盘带宽 ，[{0}] 这个不是数字

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:453
# args: bandwidth
invalid\ volume\ bandwidth[%s],\ it\ must\ be\ greater\ than\ 0 = 错误的磁盘带宽 ，[{0}] 这个数字必须超过0

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:474
# args: bandwidth
invalid\ volume\ IOPS[%s]\ is\ not\ a\ number = 错误的磁盘每秒读写速度[{0}]，它应该是个数字

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:471
# args: bandwidth
invalid\ volume\ IOPS[%s],\ it\ must\ be\ greater\ than\ 0 = 错误的磁盘每秒读写速度[{0}]，它应该大于0

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:488
# args: hostUuid,distro,version
the\ host[uuid\:%s]'s\ operating\ system\ %s\ %s\ is\ too\ old,\ the\ QEMU\ doesn't\ support\ QoS\ of\ network\ or\ disk\ IO.\ Please\ choose\ another\ instance\ offering\ with\ no\ QoS\ configuration = 物理机[uuid:{0}] 的操作系统{1} {2} 过老,  QEMU 不支持磁盘的QOS IO设置 。 请选择别的没有Qos的计算规格

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:595
# args: newValue
invalid\ value[%s],\ it's\ not\ a\ double = 错误的值[{0}]，这个不是双精度值

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:571
# args: newValue
invalid\ value[%s],\ it\ must\ be\ a\ double\ greater\ than\ 0 = 错误的值[{0}]，必须是一个大于0的双精度值

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:592
# args: newValue
invalid\ value[%s],\ it\ must\ be\ a\ double\ between\ (0,\ 1] = 错误的值[{0}]，这个必须在0~1之间的双精度值

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:604
# args: newValue
invalid\ value[%s],\ ZStack\ doesn't\ have\ such\ host\ allocator\ type = 错误值[{0}]，Zstack没有这样的分配器类型

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1361
# args: volume.getUuid(),vm.getUuid()
Shareable\ Volume[uuid\:%s]\ has\ already\ been\ attached\ to\ VM[uuid\:%s] = 共享云盘[uuid:{0}]已经挂载到云主机[uuid:{1}]上

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1379
# args: 
shareable\ disk\ only\ support\ virtio-scsi\ type\ for\ now = 目前共享盘只支持virtio-scsi

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:245
# args: msg.getVolume().getUuid(),msg.getVmInstanceUuid()
failed\ to\ detach\ shareable\ volume[uuid\:%s]\ from\ VmInstance[uuid\:%s] = 不能卸载云主机[uuid:{1}]上的共享盘[uuid:{0}]

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:257
# args: StringUtils.join(errors, "\n\n")
failed\ to\ detach\ shareable\ volume\ from\ VmInstance\:[\n%s] = 不能卸载云主机[uuid:{0}]上的共享盘

# at: src/main/java/org/zstack/network/l2/L2NetworkApiInterceptor.java:66
# args: msg.getL2NetworkUuid(),msg.getClusterUuid()
l2Network[uuid\:%s]\ has\ attached\ to\ cluster[uuid\:%s],\ can't\ attach\ again = 不能再次挂载l2网络[uuid:{0}]，因为已经挂载到集群[uuid:{1}]上了

# at: src/main/java/org/zstack/network/l2/L2NetworkApiInterceptor.java:113
# args: vl2.getUuid(),vl2.getName(),msg.getClusterUuid(),vl2.getPhysicalInterface(),vl2.getVlan(),tl2.getUuid()
There\ has\ been\ a\ L2VlanNetwork[uuid\:%s,\ name\:%s]\ attached\ to\ cluster[uuid\:%s]\ that\ has\ physical\ interface[%s],\ vlan[%s].\ Failed\ to\ attach\ L2VlanNetwork[uuid\:%s] = L2网络挂载失败[uuid:{5}]：L2网络[uuid:{0}, name:{1}]的物理接口[{3}], vlan[{4}]已经挂载到集群[uuid:{2}]上

# at: src/main/java/org/zstack/network/l2/L2NetworkApiInterceptor.java:90
# args: l2.getUuid(),l2.getName(),msg.getClusterUuid(),l2.getPhysicalInterface(),tl2.getUuid()
There\ has\ been\ a\ l2Network[uuid\:%s,\ name\:%s]\ attached\ to\ cluster[uuid\:%s]\ that\ has\ physical\ interface[%s].\ Failed\ to\ attach\ l2Network[uuid\:%s] = L2网络挂载失败[uuid:{4}]：L2网络[uuid:{0}, name:{1}]的物理接口[{3}]]已经挂载到集群[uuid:{2}]上

# at: src/main/java/org/zstack/network/l2/L2NetworkApiInterceptor.java:127
# args: msg.getL2NetworkUuid(),msg.getClusterUuid()
l2Network[uuid\:%s]\ has\ not\ attached\ to\ cluster[uuid\:%s] = L2网络[uuid:{0}]没有挂载到集群上[uuid:{1}]

# at: src/main/java/org/zstack/network/l2/L2NetworkApiInterceptor.java:141
# args: msg.getType()
unsupported\ l2Network\ type[%s] = 不支持的网络类型[{0}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:85
# args: msg.getIp()
invalid\ IP[%s] = 错误的IP值[{0}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:91
# args: 
ipRangeUuid\ and\ l3NetworkUuid\ cannot\ both\ be\ null;\ you\ must\ set\ either\ one. = IP段和L3的uuid不能都为空，您必须选择一个填上

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:118
# args: msg.getNetworkCidr()
%s\ is\ not\ a\ valid\ network\ cidr = {0}不是有效的无类别域间路由

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:115
# args: msg.getNetworkCidr()
%s\ is\ not\ an\ allowed\ network\ cidr,\ because\ it\ doesn't\ have\ usable\ ip\ range = {0}是不允许的无类别域间路由，因为它不支持可用的IP段

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:138
# args: 
ipRangeUuids,\ L3NetworkUuids,\ zoneUuids\ must\ have\ at\ least\ one\ be\ none-empty\ list,\ or\ all\ is\ set\ to\ true = ipRangeUuids, L3NetworkUuids, zoneUuids 至少一个不是为空列表，或者全部不为空

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:159
# args: msg.getType()
unsupported\ l3network\ type[%s] = 不支持的L3网络类型[{0}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:165
# args: msg.getDnsDomain()
%s\ is\ not\ a\ valid\ domain\ name = {0}不是有效的域名

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:191
# args: ipr.getStartIp(),ipr.getEndIp()
the\ IP\ range[%s\ ~\ %s]\ contains\ D\ class\ addresses\ which\ are\ for\ multicast = 这个IP段[{0} ~ {1}]包含了D类的多播地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:195
# args: ipr.getStartIp(),ipr.getEndIp()
the\ IP\ range[%s\ ~\ %s]\ contains\ E\ class\ addresses\ which\ are\ reserved = 这个IP段[{0} ~ {1}]包含了E类的保留地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:199
# args: ipr.getStartIp(),ipr.getEndIp()
the\ IP\ range[%s\ ~\ %s]\ contains\ link\ local\ addresses\ which\ are\ reserved = 这个IP段[{0} ~ {1}]包含了本地的保留地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:205
# args: ipr.getGateway(),ipr.getStartIp(),ipr.getNetmask()
the\ gateway[%s]\ is\ not\ in\ the\ subnet\ %s/%s = 网关[{0}]不在子网{1}/{2}

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:209
# args: ipr.getStartIp()
start\ ip[%s]\ is\ not\ a\ IPv4\ address = 开始的ip[{0}] 不是IPV4的地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:213
# args: ipr.getEndIp()
end\ ip[%s]\ is\ not\ a\ IPv4\ address = 结束的ip[{0}] 不是IPV4的地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:217
# args: ipr.getGateway()
gateway[%s]\ is\ not\ a\ IPv4\ address = 网关[{0}]不是IPV4的地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:221
# args: ipr.getNetmask()
netmask[%s]\ is\ not\ a\ netmask,\ and\ the\ IP\ range\ netmask\ cannot\ be\ 0.0.0.0 = 子网掩码[{0}]不是子网掩码，并且IP段的子网掩码不能是0.0.0.0

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:225
# args: 
ip\ allocation\ can\ not\ contain\ network\ address\ or\ broadcast\ address = ip 地址分配不能包含网络地址或广播的地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:233
# args: ipr.getStartIp(),ipr.getEndIp()
start\ ip[%s]\ is\ behind\ end\ ip[%s] = 起始ip[{0}]在尾ip[{1}]后

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:238
# args: ipr.getGateway(),ipr.getStartIp(),ipr.getEndIp()
gateway[%s]\ can\ not\ be\ part\ of\ range[%s,\ %s] = 网关[{0}]不能是IP段[{1}, {2}]的一部分

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:247
# args: r.getUuid(),r.getStartIp(),r.getEndIp()
overlap\ with\ ip\ range[uuid\:%s,\ start\ ip\:%s,\ end\ ip\:\ %s] = 重叠的IP段[uuid:{0}, 起始ip:{1}, 尾ip: {2}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:252
# args: ipr.getUuid(),rcidr,cidr
multiple\ CIDR\ on\ the\ same\ L3\ network\ is\ not\ allowed.\ There\ has\ been\ a\ IP\ range[uuid\:%s,\ CIDR\:%s],\ the\ new\ IP\ range[CIDR\:%s]\ is\ not\ in\ the\ CIDR\ with\ the\ existing\ one = 多个无类别域间路由在想通的L3网络上是不允许的，这发生在原有IP范围 [uuid: {0}，CIDR: {1}]。新的IP范围 [CIDR: {2}] 不在现有的一个CIDR

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:266
# args: msg.getDns()
DNS[%s]\ is\ not\ a\ IPv4\ address = DNS[{0}]不是一个IPv4地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:308
# args: msg.getDns(),msg.getL3NetworkUuid()
there\ has\ been\ a\ DNS[%s]\ on\ L3\ network[uuid\:%s] = 这个发生在L3网络[uuid:{1}]的DNS[{0}]上

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:66
# args: msg.getSecurityGroupUuid(),msg.getL3NetworkUuid()
security\ group[uuid\:%s]\ has\ not\ attached\ to\ l3Network[uuid\:%s],\ can't\ detach = 不能卸载安全组[uuid:{0}]到L3[uuid:{1}]网络上，因为已经挂载了

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:114
# args: msg.getSecurityGroupUuid(),msg.getL3NetworkUuid()
security\ group[uuid\:%s]\ has\ attached\ to\ l3Network[uuid\:%s],\ can't\ attach\ again = 不能再次挂载安全组[uuid:{0}]到L3[uuid:{1}]网络上，因为已经挂载了

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:122
# args: msg.getL3NetworkUuid(),SecurityGroupConstant.SECURITY_GROUP_NETWORK_SERVICE_TYPE
the\ L3\ network[uuid\:%s]\ doesn't\ have\ the\ network\ service\ type[%s]\ enabled = L3网络[uuid:{0}]没有开启[{1}]类型的网络服务

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:160
# args: wrongUuids,securityGroupUuid
VM\ nics[uuids\:%s]\ are\ not\ on\ L3\ networks\ that\ have\ been\ attached\ to\ the\ security\ group[uuid\:%s] = 云主机网卡[uuids:{0}]不能在L3网络上，这个已经挂载到安全组[uuid:{1}]了

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:201
# args: JSONObjectUtil.toJsonString(ao)
rule\ type\ can\ not\ be\ null.\ rule\ dump\:\ %s = 

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:206
# args: ao.getType(),JSONObjectUtil.toJsonString(ao)
unknown\ rule\ type[%s],\ rule\ can\ only\ be\ Ingress/Egress.\ rule\ dump\:\ %s = 

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:212
# args: JSONObjectUtil.toJsonString(ao)
protocol\ can\ not\ be\ null.\ rule\ dump\:\ %s = 

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:218
# args: ao.getProtocol(),JSONObjectUtil.toJsonString(ao)
invalid\ protocol[%s].\ Valid\ protocols\ are\ [TCP,\ UDP,\ ICMP].\ rule\ dump\:\ %s = 

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:223
# args: JSONObjectUtil.toJsonString(ao)
startPort\ can\ not\ be\ null.\ rule\ dump\:\ %s = 

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:233
# args: ao.getStartPort(),JSONObjectUtil.toJsonString(ao)
invalid\ startPort[%s].\ Valid\ range\ is\ [0,\ 65535].\ rule\ dump\:\ %s = 

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:228
# args: ao.getStartPort(),JSONObjectUtil.toJsonString(ao)
invalid\ ICMP\ type[%s].\ Valid\ type\ is\ [-1,\ 255].\ rule\ dump\:\ %s = 

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:250
# args: ao.getEndPort(),JSONObjectUtil.toJsonString(ao)
invalid\ endPort[%s].\ Valid\ range\ is\ [0,\ 65535].\ rule\ dump\:\ %s = 

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:245
# args: ao.getEndPort(),JSONObjectUtil.toJsonString(ao)
invalid\ ICMP\ code[%s].\ Valid\ range\ is\ [-1,\ 3].\ rule\ dump\:\ %s = 

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:257
# args: ao.getAllowedCidr(),JSONObjectUtil.toJsonString(ao)
invalid\ CIDR[%s].\ rule\ dump\:\ %s = 

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:265
# args: JSONObjectUtil.toJsonString(msg.getRules().get(j))
rule\ should\ not\ be\ duplicated.\ rule\ dump\:\ %s = 

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:285
# args: JSONObjectUtil.toJsonString(sao)
rule\ exist.\ rule\ dump\:\ %s = 

# at: src/main/java/org/zstack/network/service/NetworkServiceApiInterceptor.java:41
# args: 
networkServices\ cannot\ be\ empty = 

# at: src/main/java/org/zstack/network/service/NetworkServiceApiInterceptor.java:62
# args: puuid
network\ service\ for\ provider[uuid\:%s]\ must\ be\ specified = 

# at: src/main/java/org/zstack/network/service/NetworkServiceApiInterceptor.java:67
# args: puuid
cannot\ find\ network\ service\ provider[uuid\:%s]\ or\ it\ provides\ no\ services = 

# at: src/main/java/org/zstack/network/service/NetworkServiceApiInterceptor.java:81
# args: puuid,notSupported
network\ service\ provider[uuid\:%s]\ doesn't\ provide\ services%s = 

# at: src/main/java/org/zstack/network/service/NetworkServiceApiInterceptor.java:100
# args: type,msg.getL3NetworkUuid()
there\ has\ been\ a\ network\ service[%s]\ attached\ to\ L3\ network[uuid\:%s] = 

# at: src/main/java/org/zstack/network/service/NetworkServiceManagerImpl.java:369
# args: l3NetworkUuid,serviceType
L3Network[uuid\:%s]\ doesn't\ have\ network\ service[type\:%s]\ enabled\ or\ no\ provider\ provides\ this\ network\ service = 

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:66
# args: 
either\ eipUuid\ or\ vipUuid\ must\ be\ set = 

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:78
# args: msg.getEipUuid()
eip[uuid\:%s]\ is\ not\ in\ state\ of\ Enabled,\ cannot\ get\ attachable\ vm\ nic = 

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:83
# args: msg.getEipUuid(),vmNicUuid
eip[uuid\:%s]\ has\ attached\ to\ vm\ nic[uuid\:%s],\ cannot\ get\ attachable\ vm\ nic = 

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:94
# args: msg.getEipUuid(),vmNicUuid
eip[uuid\:%s]\ has\ attached\ to\ another\ vm\ nic[uuid\:%s],\ can't\ attach\ again = 

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:103
# args: msg.getEipUuid(),EipState.Enabled,state
eip[uuid\:\ %s]\ can\ only\ be\ attached\ when\ state\ is\ %s,\ current\ state\ is\ %s = 

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:123
# args: msg.getVmNicUuid(),msg.getEipUuid()
guest\ l3Network\ of\ vm\ nic[uuid\:%s]\ and\ vip\ l3Network\ of\ EIP[uuid\:%s]\ are\ the\ same\ network = 

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:137
# args: msg.getUuid()
eip[uuid\:%s]\ has\ not\ attached\ to\ any\ vm\ nic = 

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:165
# args: eipIp,gw,netmask,vmNicUuid
overlap\ public\ and\ private\ subnets.\ The\ subnet\ of\ EIP[%s]\ is\ an\ overlap\ with\ the\ subnet[%s/%s]\ of\ the\ VM\ nic[uuid\:%s]. = 

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:172
# args: vmUuid,vip.getL3NetworkUuid(),vip.getUuid(),vip.getName(),vip.getIp()
the\ vm[uuid\:%s]\ that\ the\ EIP\ is\ about\ to\ attach\ is\ already\ on\ the\ public\ network[uuid\:%s]\ from\ which\ the\ vip[uuid\:%s,\ name\:%s,\ ip\:%s]\ comes = 

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:180
# args: msg.getVipUuid(),vip.getUseFor()
vip[uuid\:%s]\ has\ been\ occupied\ other\ network\ service\ entity[%s] = 

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:184
# args: msg.getVipUuid(),VipState.Enabled,vip.getState()
vip[uuid\:%s]\ is\ not\ in\ state[%s],\ current\ state\ is\ %s = 

# at: src/main/java/org/zstack/network/service/eip/EipManagerImpl.java:1076
# args: l3.getUuid(),l3.getName(),vm.getUuid(),vm.getName()
unable\ to\ attach\ the\ L3\ network[uuid\:%s,\ name\:%s]\ to\ the\ vm[uuid\:%s,\ name\:%s],\ because\ the\ L3\ network\ is\ providing\ EIP\ to\ one\ of\ the\ vm's\ nic = 

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:242
# args: 
l3\ network\ uuid\ cannot\ be\ null = 

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:565
# args: inv.getUuid(),destHostUuid
cannot\ configure\ DHCP\ for\ vm[uuid\:%s]\ on\ the\ destination\ host[uuid\:%s] = 

# at: src/main/java/org/zstack/network/service/flat/FlatEipBackend.java:529
# args: vmUuid,vm.getState()
unable\ to\ apply\ the\ EIP\ operation\ for\ the\ the\ vm[uuid\:%s,\ state\:%s],\ because\ cannot\ find\ the\ VM's\ hostUUid = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:95
# args: msg.getVipUuid(),lbuuid
the\ vip[uuid\:%s]\ is\ occupied\ by\ another\ load\ balancer[uuid\:%s] = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:99
# args: msg.getVipUuid(),useFor
the\ vip[uuid\:%s]\ is\ occupied\ by\ another\ service[%s] = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:111
# args: msg.getVmNicUuids(),l3Uuids
vm\ nics[uuids\:%s]\ are\ not\ on\ the\ same\ L3\ network.\ they\ are\ on\ L3\ networks[uuids\:%s] = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:125
# args: l3Uuid,LoadBalancerConstants.LB_NETWORK_SERVICE_TYPE_STRING
the\ L3\ network[uuid\:%s]\ of\ the\ vm\ nics\ has\ no\ network\ service[%s]\ enabled = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:134
# args: existingNics,msg.getListenerUuid()
the\ vm\ nics[uuid\:%s]\ are\ already\ on\ the\ load\ balancer\ listener[uuid\:%s] = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:227
# args: msg.getLoadBalancerPort(),luuid
conflict\ loadBalancerPort[%s],\ a\ listener[uuid\:%s]\ has\ used\ that\ port = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:236
# args: msg.getInstancePort(),luuid
conflict\ instancePort[%s],\ a\ listener[uuid\:%s]\ has\ used\ that\ port = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerBase.java:902
# args: msg.getVmNicUuids().get(0)
the\ L3\ network\ of\ vm\ nic[uuid\:%s]\ doesn't\ have\ load\ balancer\ service\ enabled = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerBase.java:929
# args: self.getUuid(),self.getProviderType(),msg.getVmNicUuids().get(0),providerType
service\ provider\ type\ mismatching.\ The\ load\ balancer[uuid\:%s]\ is\ provided\ by\ the\ service\ provider[type\:%s],\ but\ the\ L3\ network\ of\ vm\ nic[uuid\:%s]\ is\ enabled\ with\ the\ service\ provider[type\:\ %s] = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:91
# args: msg.getLoadBalancerUuid()
cannot\ find\ the\ load\ balancer[uuid\:%s] = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:230
# args: tag.getTag()
cannot\ delete\ the\ system\ tag[%s].\ The\ load\ balancer\ plugin\ relies\ on\ it,\ you\ can\ only\ update\ it = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:250
# args: algorithm,LoadBalancerConstants.BALANCE_ALGORITHMS
invalid\ balance\ algorithm[%s],\ valid\ algorithms\ are\ %s = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:264
# args: systemTag,s
invalid\ unhealthy\ threshold[%s],\ %s\ is\ not\ a\ number = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:278
# args: systemTag,s
invalid\ healthy\ threshold[%s],\ %s\ is\ not\ a\ number = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:292
# args: systemTag,s
invalid\ healthy\ timeout[%s],\ %s\ is\ not\ a\ number = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:306
# args: systemTag,s
invalid\ connection\ idle\ timeout[%s],\ %s\ is\ not\ a\ number = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:320
# args: systemTag,s
invalid\ health\ check\ interval[%s],\ %s\ is\ not\ a\ number = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:334
# args: systemTag,s
invalid\ max\ connection[%s],\ %s\ is\ not\ a\ number = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:347
# args: systemTag
invalid\ health\ target[%s],\ the\ format\ is\ targetCheckProtocol\:port,\ for\ example,\ tcp\:default = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:352
# args: systemTag,protocol,LoadBalancerConstants.HEALTH_CHECK_TARGET_PROTOCOLS
invalid\ health\ target[%s],\ the\ target\ checking\ protocol[%s]\ is\ invalid,\ valid\ protocols\ are\ %s = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:364
# args: systemTag,port
invalid\ invalid\ health\ target[%s],\ port[%s]\ is\ not\ a\ number = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:361
# args: systemTag,port
invalid\ invalid\ health\ target[%s],\ port[%s]\ is\ not\ in\ the\ range\ of\ [1,\ 65535] = 

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:64
# args: msg.getRuleUuid(),state
Port\ forwarding\ rule[uuid\:%s]\ is\ not\ in\ state\ of\ Enabled,\ current\ state\ is\ %s = 

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:69
# args: msg.getRuleUuid(),vmNicUuid
Port\ forwarding\ rule[uuid\:%s]\ has\ been\ attached\ to\ vm\ nic[uuid\:%s]\ already = 

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:80
# args: msg.getUuid()
port\ forwarding\ rule\ rule[uuid\:%s]\ has\ not\ been\ attached\ to\ any\ vm\ nic,\ can't\ detach = 

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:92
# args: msg.getRuleUuid(),vmNicUuid
port\ forwarding\ rule[uuid\:%s]\ has\ been\ attached\ to\ vm\ nic[uuid\:%s],\ can't\ attach\ again = 

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:100
# args: msg.getRuleUuid(),state
port\ forwarding\ rule[uuid\:%s]\ is\ not\ in\ state\ of\ Enabled,\ \ current\ state\ is\ %s.\ A\ rule\ can\ only\ be\ attached\ when\ its\ state\ is\ Enabled = 

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:116
# args: msg.getVmNicUuid(),msg.getRuleUuid()
guest\ l3Network\ of\ vm\ nic[uuid\:%s]\ and\ vip\ l3Network\ of\ port\ forwarding\ rule[uuid\:%s]\ are\ the\ same\ network = 

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:197
# args: msg.getVipUuid(),peerL3Uuid,msg.getVmNicUuid(),nicL3Uuid
the\ VIP[uuid\:%s]\ is\ already\ bound\ the\ a\ guest\ L3\ network[uuid\:%s],\ but\ the\ VM\ nic[uuid\:%s]\ is\ on\ another\ guest\ L3\ network[uuid\:%s] = 

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:157
# args: msg.getVipPortStart(),msg.getVipPortEnd(),msg.getPrivatePortStart(),msg.getPrivatePortEnd()
for\ range\ port\ forwarding,\ the\ port\ range\ size\ must\ match;\ vip\ range[%s,\ %s]'s\ size\ doesn't\ match\ range[%s,\ %s]'s\ size = 

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:164
# args: msg.getAllowedCidr()
invalid\ CIDR[%s] = 

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:174
# args: vipStart,vipEnd,vo.getUuid(),vo.getVipPortStart(),vo.getVipPortEnd()
vip\ port\ range[vipStartPort\:%s,\ vipEndPort\:%s]\ overlaps\ with\ rule[uuid\:%s,\ vipStartPort\:%s,\ vipEndPort\:%s] = 

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:193
# args: msg.getVmNicUuid(),msg.getVipUuid()
guest\ l3Network\ of\ vm\ nic[uuid\:%s]\ and\ vip\ l3Network\ of\ vip[uuid\:\ %s]\ are\ the\ same\ network = 

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:242
# args: vm.getName(),vm.getUuid(),vipUuid
the\ VM[name\:%s\ uuid\:%s]\ already\ has\ port\ forwarding\ rules\ that\ have\ different\ VIPs\ than\ the\ one[uuid\:%s] = 

# at: src/main/java/org/zstack/network/service/vip/VipApiInterceptor.java:50
# args: msg.getAllocatorStrategy()
unsupported\ ip\ allocation\ strategy[%s] = 

# at: src/main/java/org/zstack/network/service/vip/VipApiInterceptor.java:55
# args: msg.getRequiredIp()
requiredIp[%s]\ is\ not\ in\ valid\ IPv4\ mediaType = 

# at: src/main/java/org/zstack/network/service/vip/VipApiInterceptor.java:65
# args: msg.getRequiredIp(),msg.getL3NetworkUuid()
there\ is\ already\ a\ vip[%s]\ on\ l3Network[uuid\:%s] = 

# at: src/main/java/org/zstack/network/service/vip/VipBase.java:179
# args: self.getUuid(),self.getName(),self.getIp(),self.getServiceProvider()
service\ provider\ of\ the\ vip[uuid\:%s,\ name\:%s,\ ip\:\ %s]\ has\ been\ set\ to\ %s = 

# at: src/main/java/org/zstack/network/service/vip/VipBase.java:189
# args: self.getUuid(),self.getName(),self.getIp(),self.getUseFor()
the\ field\ 'useFor'\ of\ the\ vip[uuid\:%s,\ name\:%s,\ ip\:\ %s]\ has\ been\ set\ to\ %s = 

# at: src/main/java/org/zstack/network/service/vip/VipBase.java:199
# args: self.getUuid(),self.getName(),self.getIp(),self.getPeerL3NetworkUuid()
the\ field\ 'peerL3NetworkUuid'\ of\ the\ vip[uuid\:%s,\ name\:%s,\ ip\:\ %s]\ has\ been\ set\ to\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouter.java:246
# args: self.getName(),self.getUuid(),self.getState()
the\ virtual\ router[name\:%s,\ uuid\:%s,\ current\ state\:%s]\ is\ not\ running,and\ cannot\ perform\ required\ operation.\ Please\ retry\ your\ operation\ later\ once\ it\ is\ running = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouter.java:251
# args: self.getUuid(),getSelf().getStatus(),msg.getPath()
virtual\ router[uuid\:%s]\ is\ in\ status\ of\ %s\ that\ cannot\ make\ http\ call\ to\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:130
# args: msg.getImageUuid(),type,ImageMediaType.RootVolumeTemplate
image[uuid\:%s]'s\ mediaType\ is\ %s,\ the\ mediaType\ of\ a\ virtual\ router\ image\ must\ be\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:136
# args: msg.getImageUuid(),format
image[uuid\:%s]\ is\ of\ format\ %s,\ cannot\ be\ used\ for\ virtual\ router = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:106
# args: msg.getManagementNetworkUuid(),msg.getZoneUuid()
management\ network[uuid\:%s]\ is\ not\ in\ the\ same\ zone[uuid\:%s]\ this\ offering\ is\ going\ to\ create = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:119
# args: msg.getManagementNetworkUuid(),msg.getZoneUuid()
public\ network[uuid\:%s]\ is\ not\ in\ the\ same\ zone[uuid\:%s]\ this\ offering\ is\ going\ to\ create = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:147
# args: msg.getPublicNetworkUuid()
the\ L3\ network[uuid\:\ %s]\ has\ the\ SNAT\ service\ enabled,\ it\ cannot\ be\ used\ as\ a\ public\ network = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:145
# args: msg.getManagementNetworkUuid()
the\ L3\ network[uuid\:\ %s]\ has\ the\ SNAT\ service\ enabled,\ it\ cannot\ be\ used\ as\ a\ management\ network = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:173
# args: managementNetworkUuid
the\ management\ network[uuid\:%s]\ doesn't\ have\ any\ IP\ range = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:175
# args: managementNetworkUuid,gateway
the\ management\ network[uuid\:%s,\ gateway\:%s]\ is\ not\ reachable = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterKvmBackend.java:108
# args: iso.getIsoPath(),vrSpec.getDestHost().getUuid(),vrSpec.getDestHost().getManagementIp(),iso.getVirtualRouterUuid(),rsp.getError()
failed\ to\ create\ VirtualRouterBootstrapIso[%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s]\ for\ virtual\ router[uuid\:%s],\ because\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterKvmBackend.java:142
# args: iso.getIsoPath(),hostUuid,iso.getVirtualRouterUuid(),rsp.getError()
failed\ to\ delete\ VirtualRouterBootstrapIso[%s]\ on\ kvm\ host[uuid\:%s]\ for\ virtual\ router[uuid\:%s],\ because\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterManagerImpl.java:650
# args: vr.getUuid(),l3Nw.getUuid(),vr.getState()
virtual\ router[uuid\:%s]\ for\ l3\ network[uuid\:%s]\ is\ not\ in\ Running\ state,\ current\ state\ is\ %s.\ We\ don't\ have\ HA\ feature\ now(it's\ coming\ soon),\ please\ restart\ it\ from\ UI\ and\ then\ try\ starting\ this\ vm\ again = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterManagerImpl.java:921
# args: msg.getL3NetworkUuid()
failed\ tot\ attach\ virtual\ router\ network\ services\ to\ l3Network[uuid\:%s].\ When\ eip\ is\ selected,\ snat\ must\ be\ selected\ too = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterManagerImpl.java:925
# args: msg.getL3NetworkUuid()
failed\ tot\ attach\ virtual\ router\ network\ services\ to\ l3Network[uuid\:%s].\ When\ port\ forwarding\ is\ selected,\ snat\ must\ be\ selected\ too = 

# at: src/main/java/org/zstack/network/service/virtualrouter/dhcp/VirtualRouterDhcpBackend.java:120
# args: vr.getUuid(),vr.getManagementNic().getIp(),rsp.getError(),struct
unable\ to\ add\ dhcp\ entries\ to\ virtual\ router\ vm[uuid\:%s\ ip\:%s],\ because\ %s,\ dhcp\ entry[%s] = 

# at: src/main/java/org/zstack/network/service/virtualrouter/dhcp/VirtualRouterSyncDHCPOnStartFlow.java:175
# args: vr.getUuid(),vr.getManagementNic().getIp(),ret.getError()
unable\ to\ program\ dhcp\ entries\ served\ by\ virtual\ router[uuid\:%s,\ ip\:%s],\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/dns/VirtualRouterDnsBackend.java:193
# args: vr.getUuid(),vr.getManagementNic().getIp(),struct,l3.getUuid(),l3.getName(),ret.getError()
virtual\ router[uuid\:%s,\ ip\:%s]\ failed\ to\ configure\ dns%s\ for\ L3Network[uuid\:%s,\ name\:%s],\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/dns/VirtualRouterSyncDnsOnStartFlow.java:108
# args: vr.getName(),vr.getUuid(),JSONObjectUtil.toJsonString(dns),ret.getError()
virtual\ router[name\:\ %s,\ uuid\:\ %s]\ failed\ to\ configure\ dns%s,\ %s\  = 

# at: src/main/java/org/zstack/network/service/virtualrouter/eip/VirtualRouterEipBackend.java:149
# args: struct.getEip().getUuid(),struct.getEip().getName(),struct.getVip().getIp(),struct.getNic().getUuid(),vr.getUuid(),ret.getError()
failed\ to\ create\ eip[uuid\:%s,\ name\:%s,\ ip\:%s]\ for\ vm\ nic[uuid\:%s]\ on\ virtual\ router[uuid\:%s],\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/eip/VirtualRouterEipBackend.java:185
# args: offering.getUuid(),l3inv.getUuid(),l3inv.getZoneUuid(),struct.getVip().getL3NetworkUuid(),struct.getEip().getUuid()
found\ a\ virtual\ router\ offering[uuid\:%s]\ for\ L3Network[uuid\:%s]\ in\ zone[uuid\:%s];\ however,\ the\ network's\ public\ network[uuid\:%s]\ is\ not\ the\ same\ to\ EIP[uuid\:%s]'s;\ you\ may\ need\ to\ use\ system\ tag\ guestL3Network\:\:l3NetworkUuid\ to\ specify\ a\ particular\ virtual\ router\ offering\ for\ the\ L3Network = 

# at: src/main/java/org/zstack/network/service/virtualrouter/eip/VirtualRouterEipBackend.java:288
# args: struct.getEip().getUuid(),struct.getEip().getName(),struct.getVip().getIp(),struct.getNic().getUuid(),vr.getUuid(),ret.getError()
failed\ to\ remove\ eip[uuid\:%s,\ name\:%s,\ ip\:%s]\ for\ vm\ nic[uuid\:%s]\ on\ virtual\ router[uuid\:%s],\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/eip/VirtualRouterSyncEipOnStartFlow.java:180
# args: vr.getUuid(),ret.getError()
failed\ to\ sync\ eip\ on\ virtual\ router[uuid\:%s],\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/lb/VirtualRouterLoadBalancerBackend.java:701
# args: struct.getLb().getUuid()
cannot\ find\ virtual\ router\ for\ load\ balancer\ [uuid\:%s] = 

# at: src/main/java/org/zstack/network/service/virtualrouter/nat/VirtualRouterSnatBackend.java:73
# args: guestL3.getUuid(),guestL3.getName(),offering.getPublicNetworkUuid(),offering.getUuid(),offering.getName()
guest\ l3Network[uuid\:%s,\ name\:%s]\ needs\ SNAT\ service\ provided\ by\ virtual\ router,\ but\ public\ l3Network[uuid\:%s]\ of\ virtual\ router\ offering[uuid\:\ %s,\ name\:%s]\ is\ the\ same\ to\ this\ guest\ l3Network = 

# at: src/main/java/org/zstack/network/service/virtualrouter/nat/VirtualRouterSnatBackend.java:124
# args: vr.getUuid(),vr.getManagementNic().getIp(),JSONObjectUtil.toJsonString(info),spec.getVmInventory().getUuid(),spec.getVmInventory().getName(),struct.getL3Network().getUuid(),struct.getL3Network().getName(),ret.getError()
virtual\ router[uuid\:%s,\ ip\:%s]\ failed\ to\ apply\ snat[%s]\ for\ vm[uuid\:%s,\ name\:%s]\ on\ L3Network[uuid\:%s,\ name\:%s],\ because\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/nat/VirtualRouterSyncSNATOnStartFlow.java:92
# args: vr.getName(),vr.getUuid(),JSONObjectUtil.toJsonString(snatInfo),ret.getError()
virtual\ router[name\:\ %s,\ uuid\:\ %s]\ failed\ to\ sync\ snat%s,\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/ApplyPortforwardingRuleOnVirtualRouterVmFlow.java:81
# args: to.getVipIp(),to.getPrivateIp(),to.getVipPortStart(),to.getVipPortEnd(),to.getPrivatePortStart(),to.getPrivatePortEnd(),ret.getError()
failed\ to\ create\ port\ forwarding\ rule[vip\ ip\:\ %s,\ private\ ip\:\ %s,\ vip\ start\ port\:\ %s,\ vip\ end\ port\:\ %s,\ private\ start\ port\:\ %s,\ private\ end\ port\:\ %s],\ because\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/ReleasePortForwardingRuleOnVirtualRouterVmFlow.java:75
# args: JSONObjectUtil.toJsonString(to),ret.getError()
failed\ to\ revoke\ port\ forwarding\ rules\ %s,\ because\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/VirtualRouterPortForwardingBackend.java:141
# args: offering.getUuid(),struct.getGuestL3Network().getUuid(),struct.getGuestL3Network().getZoneUuid(),struct.getVip().getL3NetworkUuid(),struct.getRule().getUuid()
found\ a\ virtual\ router\ offering[uuid\:%s]\ for\ L3Network[uuid\:%s]\ in\ zone[uuid\:%s];\ however,\ the\ network's\ public\ network[uuid\:%s]\ is\ not\ the\ same\ to\ PortForwarding\ rule[uuid\:%s]'s;\ you\ may\ need\ to\ use\ system\ tag\ guestL3Network\:\:l3NetworkUuid\ to\ specify\ a\ particular\ virtual\ router\ offering\ for\ the\ L3Network = 

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/VirtualRouterPortForwardingBackend.java:207
# args: rule.getVipPortStart(),rule.getVipPortEnd(),rule.getPrivatePortStart(),rule.getPrivatePortEnd()
virtual\ router\ doesn't\ support\ port\ forwarding\ range\ redirection,\ the\ vipPortStart\ must\ be\ equals\ to\ privatePortStart\ and\ vipPortEnd\ must\ be\ equals\ to\ privatePortEnd;but\ this\ rule\ rule\ has\ a\ mismatching\ range\:\ vip\ port[%s,\ %s],\ private\ port[%s,\ %s] = 

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/VirtualRouterSyncPortForwardingRulesOnStartFlow.java:187
# args: vr.getName(),vr.getUuid(),ret.getError()
failed\ to\ sync\ port\ forwarding\ rules\ served\ by\ virtual\ router[name\:\ %s,\ uuid\:\ %s],\ because\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBackend.java:171
# args: vipvo.getVirtualRouterVmUuid(),vrState
virtual\ router[uuid\:%s,\ state\:%s]\ is\ not\ running,\ current\ HA\ has\ not\ been\ supported,\ please\ manually\ start\ this\ virtual\ router = 

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBaseBackend.java:141
# args: tos,ret.getError()
failed\ to\ remove\ vip%s,\ because\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBaseBackend.java:176
# args: tos,vr.getUuid(),ret.getError()
failed\ to\ create\ vip%s\ on\ virtual\ router[uuid\:%s],\ because\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBaseBackend.java:196
# args: vipvo.getVirtualRouterVmUuid(),vrState
virtual\ router[uuid\:%s,\ state\:%s]\ is\ not\ running = 

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBaseBackend.java:228
# args: offering.getUuid(),s.getL3Network().getUuid(),s.getL3Network().getZoneUuid(),self.getL3NetworkUuid(),self.getUuid()
found\ a\ virtual\ router\ offering[uuid\:%s]\ for\ L3Network[uuid\:%s]\ in\ zone[uuid\:%s];\ however,\ the\ network's\ public\ network[uuid\:%s]\ is\ not\ the\ same\ to\ VIP[uuid\:%s]'s;\ you\ may\ need\ to\ use\ system\ tag\ guestL3Network\:\:l3NetworkUuid\ to\ specify\ a\ particular\ virtual\ router\ offering\ for\ the\ L3Network = 

# at: src/main/java/org/zstack/network/service/virtualrouter/vyos/VyosDeployAgentFlow.java:87
# args: mgmtNicIp
unable\ to\ ssh\ in\ to\ the\ vyos[%s],\ the\ ssh\ port\ seems\ not\ open = 

# at: src/main/java/org/zstack/portal/apimediator/ApiMediatorImpl.java:241
# args: cmsg.getResourceUuid()
resourceUuid[%s]\ is\ not\ a\ valid\ uuid.\ A\ valid\ uuid\ is\ a\ UUID(v4\ recommended)\ with\ '-'\ stripped.\ see\ http\://en.wikipedia.org/wiki/Universally_unique_identifier\ for\ format\ of\ UUID,\ the\ regular\ expression\ ZStack\ uses\ to\ validate\ a\ UUID\ is\ '[0-9a-f]{8}[0-9a-f]{4}[1-5][0-9a-f]{3}[89ab][0-9a-f]{3}[0-9a-f]{12}' = 

# at: src/main/java/org/zstack/portal/apimediator/ApiMessageProcessorImpl.java:268
# args: f.getName(),msg.getClass().getName(),at.maxLength(),str.length()
field[%s]\ of\ message[%s]\ exceeds\ max\ length\ of\ string.\ expected\ was\ <\=\ %s,\ actual\ was\ %s = 

# at: src/main/java/org/zstack/portal/apimediator/ApiMessageProcessorImpl.java:274
# args: f.getName(),msg.getClass().getName()
field[%s]\ of\ message[%s]\ is\ mandatory,\ can\ not\ be\ null = 

# at: src/main/java/org/zstack/portal/apimediator/ApiMessageProcessorImpl.java:281
# args: f.getName(),msg.getClass().getName(),vals,value
valid\ value\ for\ field[%s]\ of\ message[%s]\ are\ %s,\ but\ %s\ found = 

# at: src/main/java/org/zstack/portal/apimediator/ApiMessageProcessorImpl.java:291
# args: f.getName(),msg.getClass().getName(),regex,value
valid\ regex\ value\ for\ field[%s]\ of\ message[%s]\ are\ %s,\ but\ %s\ found = 

# at: src/main/java/org/zstack/portal/apimediator/ApiMessageProcessorImpl.java:299
# args: f.getName()
field[%s]\ must\ be\ a\ nonempty\ list = 

# at: src/main/java/org/zstack/portal/apimediator/ApiMessageProcessorImpl.java:307
# args: f.getName()
field[%s]\ cannot\ contain\ a\ NULL\ element = 

# at: src/main/java/org/zstack/portal/apimediator/ApiMessageProcessorImpl.java:318
# args: f.getName()
field[%s]\ cannot\ contain\ any\ empty\ string = 

# at: src/main/java/org/zstack/portal/apimediator/ApiMessageProcessorImpl.java:314
# args: f.getName()
field[%s]\ cannot\ be\ an\ empty\ string = 

# at: src/main/java/org/zstack/portal/apimediator/ApiMessageProcessorImpl.java:330
# args: f.getName(),low,high
field[%s]\ must\ be\ in\ range\ of\ [%s,\ %s] = 值[{0}]必须在[{1}, {2}]之间

# at: src/main/java/org/zstack/prometheus/PrometheusApiInterceptor.java:41
# args: msg.getRelativeTime()
the\ relativeTime[%s]\ is\ invalid,\ it\ must\ be\ in\ format\ of,\ for\ example,\ 10s,\ 1h = 相关时间[{0}]不合法,格式必须例如10s，1h

# at: src/main/java/org/zstack/prometheus/PrometheusApiInterceptor.java:45
# args: msg.getRelativeTime()
the\ relativeTime[%s]\ is\ invalid,\ it's\ too\ big = 相关时间[{0}]不合法，值's 过大

# at: src/main/java/org/zstack/prometheus/PrometheusManagerImpl.java:426
# args: rsp.getStatusCode(),rsp.getBody()
query\ failure;\ status\ code\:%s,%s = 查询失败；失败码为：{0},{1}

# at: src/main/java/org/zstack/prometheus/PrometheusManagerImpl.java:459
# args: msg.getExpression(),disallowedMetric
the\ expression[%s]\ contains\ disallowed\ metric[%s] = 表达[{0}]包含了不允许的度量[{1}]

# at: src/main/java/org/zstack/prometheus/PrometheusManagerImpl.java:481
# args: ret.get("errorType"),ret.get("error")
query\ failure,\ errorType\:%s,\ error\:\ %s = 查询失败，错误类型：{0}, 错误：{1}

# at: src/main/java/org/zstack/query/MysqlQueryBuilderImpl3.java:431
# args: attr,inventoryClass.getName()
condition\ name[%s]\ is\ invalid,\ no\ such\ field\ on\ inventory\ class[%s] = 条件名[{0}]非法，在清单类里面没有这个阈

# at: src/main/java/org/zstack/query/MysqlQueryBuilderImpl3.java:436
# args: attr,attr,inventoryClass.getName()
condition\ name[%s]\ is\ invalid,\ field[%s]\ of\ inventory[%s]\ is\ annotated\ as\ @Unqueryable\ field = 条件名[{0}]非法，清单[{2}]的值[{1}]不是被标记为@Unqueryable的值

# at: src/main/java/org/zstack/query/MysqlQueryBuilderImpl3.java:447
# args: info.jpaMetaClass.getName(),attr
entity\ meta\ class[%s]\ has\ no\ field[%s] = 实体元类[{0}]中没有值[{1}]

# at: src/main/java/org/zstack/query/MysqlQueryBuilderImpl3.java:999
# args: f,info.inventoryClass.getSimpleName(),info.premitiveFieldNames
field[%s]\ is\ not\ a\ primitive\ of\ the\ inventory\ %s;\ you\ cannot\ specify\ it\ in\ the\ parameter\ 'fields';valid\ fields\ are\ %s = 值[{0}]不是清单{1}的原语；你不能在参数'域'中指定该参数；非法的域{2}

# at: src/main/java/org/zstack/query/QueryFacadeImpl.java:257
# args: JSONObjectUtil.toJsonString(cond)
'value'\ of\ query\ condition\ %s\ cannot\ be\ null = 查询条件中{0}的'值'不能为空

# at: src/main/java/org/zstack/storage/backup/BackupStorageApiInterceptor.java:64
# args: name
%s\ should\ not\ be\ null = {0} 不能为空

# at: src/main/java/org/zstack/storage/backup/BackupStorageApiInterceptor.java:87
# args: 
zoneUuids,\ backupStorageUuids\ must\ have\ at\ least\ one\ be\ none-empty\ list,\ or\ all\ is\ set\ to\ true = zoneUuids, backupStorageUuids 至少有一个不为空，或者all被设置为真 

# at: src/main/java/org/zstack/storage/backup/BackupStorageApiInterceptor.java:117
# args: msg.getBackupStorageUuid(),msg.getZoneUuid()
backup\ storage[uuid\:%s]\ has\ not\ been\ attached\ to\ zone[uuid\:%s] = 备份存储[uuid:{0}]没有被加载到zone[uuid:{1}]

# at: src/main/java/org/zstack/storage/backup/BackupStorageApiInterceptor.java:126
# args: msg.getBackupStorageUuid(),msg.getZoneUuid()
backup\ storage[uuid\:%s]\ has\ been\ attached\ to\ zone[uuid\:%s] = 备份存储[uuid:{0}]已经被加载到zone[uuid:{1}]

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:131
# args: url,e.toString()
cannot\ get\ image.\ The\ image\ url\ is\ %s.\ Exception\ is\ %s = 无法取得镜像。镜像的url是{0}，抛出的错误为{1}

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:139
# args: self.getUuid(),self.getName(),url,size,self.getAvailableCapacity()
the\ backup\ storage[uuid\:%s,\ name\:%s]\ has\ not\ enough\ capacity\ to\ download\ the\ image[%s].Required\ size\:%s,\ available\ size\:%s = 备份存储[uuid:{0}, name:{1}]没有足够的容量可供下载镜像[{2}]。需要的大小：{3}，可用的大小：{4}

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:154
# args: msg.getClass().getName(),self.getStatus()
backup\ storage\ cannot\ proceed\ message[%s]\ because\ its\ status\ is\ %s = 备份存储无法处理消息[{0}]因为它的状态为{1}

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:160
# args: msg.getClass().getName(),self.getState()
backup\ storage\ cannot\ proceed\ message[%s]\ because\ its\ state\ is\ %s = 备份存储无法处理消息[{0}]因为它的状态为{1}

# at: src/main/java/org/zstack/storage/backup/BackupStorageCapacityUpdater.java:139
# args: size,backupStorageUuid,capacityVO.getAvailableCapacity()
cannot\ reserve\ %s\ on\ the\ backup\ storage[uuid\:%s],\ it\ only\ has\ %s\ available = 无法在备份存储{1}保留{0}，它仅有{2}可用容量

# at: src/main/java/org/zstack/storage/backup/BackupStorageManagerImpl.java:302
# args: 
capacity\ reservation\ on\ all\ backup\ storage\ failed = 在所有备份存储上保留容量失败

# at: src/main/java/org/zstack/storage/backup/BackupStorageReservedCapacityAllocatorFlow.java:46
# args: BackupStorageGlobalConfig.RESERVED_CAPACITY.value(),spec.getSize()
after\ subtracting\ reserved\ capacity[%s],\ no\ backup\ storage\ has\ required\ capacity[%s\ bytes] = 在减去保留容量[{0}]，没有备份存储有容量[{1}] bytes

# at: src/main/java/org/zstack/storage/backup/imagestore/CommitVolumeAsImageFlowChain.java:303
# args: String.join(",", msg.getBackupStorageUuids()),errorCodes.get(0).getCause().getDetails()
unable\ to\ commit\ backup\ storage\ specified\ by\ uuids\:\ %s,\ becasue\:\ %s = 无法通过uuids：{0}提交备份存储，因为：{1}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:154
# args: url,rsp.getError()
unable\ to\ connect\ to\ SimpleHttpBackupStorage[url\:%s],\ because\ %s = 无法连接到SimpleHttpBackupStorage[url:{0}]，因为{1}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:638
# args: self.getUuid(),ret.getUuid()
the\ uuid\ of\ imagestoreBackupStorage\ agent\ changed[expected\:%s,\ actual\:%s],\ it's\ most\ likely\ the\ agent\ was\ manually\ restarted.\ Issue\ a\ reconnect\ to\ sync\ the\ status = 镜像备份存储的代理的uuid发生了改变[期望：{0}，实际：{1}]，很'有可能代理被手动重启了，需要重连同步状态

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:61
# args: msg.getHostname()
hostname[%s]\ is\ neither\ an\ IPv4\ address\ nor\ a\ valid\ hostname = 主机名[{0}]不是一个IPv4的地址，而是一个非法的主机名

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:67
# args: msg.getHostname()
duplicate\ backup\ storage.\ There\ has\ been\ an\ image\ store\ backup\ storage[hostname\:%s] = 重复的备份存储。已经存在一个备份存储[主机名：{0}]

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:72
# args: 
file\ path\ needed = 需要文件路径

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:76
# args: dir
absolute\ file\ path\ required\:\ %s = 需要文件的绝对路径；{0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:85
# args: dir
file\ path\ contains\ invalid\ character\:\ %s = 文件路径包含非法字符：{0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageFactory.java:78
# args: amsg.getUrl()
invalid\ url[%s],\ the\ url\ must\ be\ an\ absolute\ path\ starting\ with\ '/' = 无效的url[{0}]，url必须是以'/'开头的绝对路径

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageFactory.java:87
# args: hostname
existing\ SimpleHttpBackupStorage\ with\ hostname[%s]\ found = 存在主机名为[{0}]的简单http备份存储

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageMetaDataMaker.java:455
# args: rsp.getBackupStorageMetaFileName()
Check\ image\ metadata\ file\:\ %s\ failed = 检查镜像元数据文件：{0}失败

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageMetaDataMaker.java:320
# args: rsp.getBackupStorageMetaFileName()
Create\ image\ metadata\ file\ \:\ %s\ failed = 创建镜像元数据文件：{0}失败

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageMetaDataMaker.java:460
# args: rsp.getBackupStorageMetaFileName()
Image\ metadata\ file\:\ %s\ is\ not\ exist = 镜像元数据文件：{0}不存在

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageMetaDataMaker.java:498
# args: rsp.getError()
delete\ image\ metadata\ file\ failed\:\ %s = 删除镜像元数据文件失败：{0}

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorage.java:100
# args: scheme,url
SftpBackupStorage\ doesn't\ support\ scheme[%s]\ in\ url[%s] = Sftp备份存储不支持在url[{1}]里包含scheme[{0}]

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorage.java:272
# args: self.getUuid(),ret.getUuid()
the\ uuid\ of\ sftpBackupStorage\ agent\ changed[expected\:%s,\ actual\:%s],\ it's\ most\ likely\ the\ agent\ was\ manually\ restarted.\ Issue\ a\ reconnect\ to\ sync\ the\ status = Sftp镜像备份存储的代理的uuid发生了改变[期望：{0}，实际：{1}]，很'有可能代理被手动重启了，需要重连同步状态

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorageApiInterceptor.java:69
# args: msg.getHostname()
duplicate\ backup\ storage.\ There\ has\ been\ a\ sftp\ backup\ storage[hostname\:%s]\ existing = 重复的备份存储。已经存在一个备份存储[主机名：{0}]

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorageMetaDataMaker.java:466
# args: rsp.getBackupStorageMetaFileName()
check\ image\ metadata\ file\:\ %s\ failed = 检查镜像元数据文件：{0}失败

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorageMetaDataMaker.java:327
# args: rsp.getBackupStorageMetaFileName()
create\ image\ metadata\ file\ \:\ %s\ failed = 创建镜像元数据文件：{0}失败

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorageMetaDataMaker.java:471
# args: rsp.getBackupStorageMetaFileName()
image\ metadata\ file\:\ %s\ is\ not\ exist = 镜像元数据文件：{0}不存在

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:66
# args: msg.getPoolName()
duplicate\ poolName[%s].\ There\ has\ been\ a\ pool\ with\ the\ same\ name\ existing = 

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:81
# args: existing
cannot\ add\ ceph\ primary\ storage,\ there\ has\ been\ some\ ceph\ primary\ storage\ using\ mon[hostnames\:%s] = 无法添加ceph主存储，一定有某些ceph主存储使用了mon[主机名：{0}]

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:127
# args: monUrl,MON_URL_FORMAT
invalid\ monUrl[%s].\ A\ valid\ url\ is\ in\ format\ of\ %s = 非法的monUrl[{0}]. 格式为{1}的非法url

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:134
# args: 
dataVolumePoolName\ can\ be\ null\ but\ cannot\ be\ an\ empty\ string = 数据盘池名可以为空但是不能为一个空字符串

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:139
# args: 
rootVolumePoolName\ can\ be\ null\ but\ cannot\ be\ an\ empty\ string = 根数据盘池名可以为空但是不能为一个空字符串

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:144
# args: 
imageCachePoolName\ can\ be\ null\ but\ cannot\ be\ an\ empty\ string = 镜像缓存池名可以为空但是不能为空字符串

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:167
# args: existing
cannot\ add\ ceph\ backup\ storage,\ there\ has\ been\ some\ ceph\ backup\ storage\ using\ mon[hostnames\:%s] = 无法添加ceph备份存储，已经有某个ceph备份存储使用mon[主机名：{0}]

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:175
# args: 
poolName\ is\ required\ when\ importImages\ is\ true = 当importImages为真的时候必须填写池名

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:173
# args: 
poolName\ can\ be\ null\ but\ cannot\ be\ an\ empty\ string = 池名可以为空但是不能是空的字符串

# at: src/main/java/org/zstack/storage/ceph/backup/CephBackupStorageBase.java:436
# args: self.getUuid()
all\ ceph\ mons\ are\ Disconnected\ in\ ceph\ backup\ storage[uuid\:%s] = 所有在ceph备份存储[uuid:{0}]中的ceph的mons都处于失联状态

# at: src/main/java/org/zstack/storage/ceph/backup/CephBackupStorageBase.java:839
# args: self.getUuid(),JSONObjectUtil.toJsonString(errorCodes)
unable\ to\ connect\ to\ the\ ceph\ backup\ storage[uuid\:%s].\ Failed\ to\ connect\ all\ ceph\ mons.\ Errors\ are\ %s = 无法连接到ceph备份存储[uuid:{0}]。无法与所有的ceph mons连接。错误是{1}

# at: src/main/java/org/zstack/storage/ceph/backup/CephBackupStorageBase.java:926
# args: otherCeph.getName(),otherCeph.getUuid(),fsId
there\ is\ another\ CEPH\ backup\ storage[name\:%s,\ uuid\:%s]\ with\ the\ same\ FSID[%s],\ you\ cannot\ add\ the\ same\ CEPH\ setup\ as\ two\ different\ backup\ storage = 有另外一个CEPH备份存储[name:{0}, uuid:{1}]有相同的FSIO[{2}]，你不能添加同样的CEPH为两个不同的备份存储

# at: src/main/java/org/zstack/storage/ceph/backup/CephBackupStorageBase.java:1330
# args: 
unable\ to\ add\ mon\ to\ ceph\ backup\ storage = 无法添加mon到ceph备份存储

# at: src/main/java/org/zstack/storage/ceph/backup/CephBackupStorageMonBase.java:88
# args: uuid
cannot\ update\ status\ of\ the\ ceph\ backup\ storage\ mon[uuid\:%s],\ it\ has\ been\ deleted.This\ error\ can\ be\ ignored = 无法更新ceph备份存储mon[uuid:{0}]，他已经被删除。这个错误可以被忽略

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:1658
# args: path,JSONObjectUtil.toJsonString(errorCodes)
all\ mons\ failed\ to\ execute\ http\ call[%s],\ errors\ are\ %s = 所有的mons都无法执行http call[{0}]，错误是{1}

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2262
# args: 
unable\ to\ connect\ mons = 无法连接到mons

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2325
# args: base.getSelf().getHostname(),fsid,getSelf().getFsid()
the\ mon[ip\:%s]\ returns\ a\ fsid[%s]\ different\ from\ the\ current\ fsid[%s]\ of\ the\ cep\ cluster,are\ you\ adding\ a\ mon\ not\ belonging\ to\ current\ cluster\ mistakenly? = mon[ip:{0}]返回了一个fsid[{1}]和当前ceph集群的fsid[{2}]不同，你是否错误地添加了一个不属于当前集群的mon？

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:924
# args: backupStorage.getUuid(),backupStorage.getName(),bsFsid,self.getUuid(),self.getName(),getSelf().getFsid()
the\ backup\ storage[uuid\:%s,\ name\:%s,\ fsid\:%s]\ is\ not\ in\ the\ same\ ceph\ cluster\ with\ the\ primary\ storage[uuid\:%s,\ name\:%s,\ fsid\:%s] = 备份存储[uuid:{0}, name:{1}, fsid:{2}]和主存储[uuid:{3}, name:{4}, fsid:{5}]不在同一个ceph集群中

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:1645
# args: self.getUuid()
all\ ceph\ mons\ of\ primary\ storage[uuid\:%s]\ are\ not\ in\ Connected\ state = 所有的主存储的ceph mons都不处于已连接状态

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:1715
# args: self.getUuid(),JSONObjectUtil.toJsonString(errorCodes)
unable\ to\ connect\ to\ the\ ceph\ primary\ storage[uuid\:%s].\ Failed\ to\ connect\ all\ ceph\ mons.\ Errors\ are\ %s = 无法连接到ceph主存储[uuid:{0}]。连接所有ceph mons失败。错误是{1}

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:1786
# args: 
the\ fsid\ returned\ by\ mons\ are\ mismatching,\ it\ seems\ the\ mons\ belong\ to\ different\ ceph\ clusters\:\n = mons返回的fsid不匹配，似乎mons属于不同的ceph集群

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:1804
# args: otherCeph.getName(),otherCeph.getUuid(),fsId
there\ is\ another\ CEPH\ primary\ storage[name\:%s,\ uuid\:%s]\ with\ the\ same\ FSID[%s],\ you\ cannot\ add\ the\ same\ CEPH\ setup\ as\ two\ different\ primary\ storage = 有另外一个CEPH主存储[name:{0}, uuid:{1}] 有相同的 FSID[{2}]，你不能添加相同的CEPH设置到两个不同的主存储

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2028
# args: self.getUuid(),self.getName(),mon.getSelf().getUuid(),res.error
the\ ceph\ primary\ storage[uuid\:%s,\ name\:%s]\ is\ down,\ as\ one\ mon[uuid\:%s]\ reports\ an\ operation\ failure[%s] = ceph主存储[uuid:{0}, name:{1}]关闭，因为一个mon[uuid:{2}]报告了一个操作失败[{3}]

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2306
# args: 
unable\ to\ add\ mon\ to\ ceph\ primary\ storage = 无法添加mon到ceph主存储

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2498
# args: bsType
unable\ to\ upload\ bits\ to\ the\ backup\ storage[type\:%s],\ we\ only\ support\ CEPH = 无法上传bits到备份存储[type:{0}]，仅支持CEPH

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2541
# args: 
backing\ up\ snapshots\ to\ backup\ storage\ is\ a\ depreciated\ feature,\ which\ will\ be\ removed\ in\ future\ version = 备份快照到备份存储是一个弃用的功能，将会在未来版本中被移除

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageFactory.java:256
# args: vol.getPrimaryStorageUuid()
cannot\ find\ any\ Connected\ ceph\ mon\ for\ the\ primary\ storage[uuid\:%s] = 无法找到一台处于Connected状态的用于监控Ceph主存储[uuid:{0}]的监控节点

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageMonBase.java:88
# args: uuid
cannot\ update\ status\ of\ the\ ceph\ primary\ storage\ mon[uuid\:%s],\ it\ has\ been\ deleted.This\ error\ can\ be\ ignored = 不能更新一台已经被删除的Ceph主存储监控节点[uuid:{0}]，这个错误可被忽略

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:77
# args: 
zoneUuids,\ clusterUuids,\ primaryStorageUuids\ must\ have\ at\ least\ one\ be\ none-empty\ list,\ or\ all\ is\ set\ to\ true = 区域、集群、主存储的Uuids中必须至少有一个不为空列表，或者全部的pass都设置为true

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:99
# args: msg.getPrimaryStorageUuid(),msg.getClusterUuid()
primary\ storage[uuid\:%s]\ has\ not\ been\ attached\ to\ cluster[uuid\:%s]\ yet = 主存储[uuid:{0}]还未加载到集群[uuid:{1}]上

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:116
# args: msg.getPrimaryStorageUuid(),msg.getClusterUuid()
primary\ storage[uuid\:%s]\ has\ been\ attached\ to\ cluster[uuid\:%s] = 主存储[uuid:{0}]已被加载到集群[uuid:{1}]上

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:131
# args: msg.getPrimaryStorageUuid(),msg.getClusterUuid()
primary\ storage[uuid\:%s]\ and\ cluster[uuid\:%s]\ are\ not\ in\ the\ same\ zone = 主存储[uuid:{0}]还集群[uuid:{1}]不在同一个区域内

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:151
# args: msg.getPrimaryStorageUuid(),clusterUuidsString
primary\ storage[uuid\:%s]\ cannot\ be\ deleted\ for\ still\ being\ attached\ to\ cluster[uuid\:%s]. = 不能删除主存储[uuid:{0}]，因为它还被加载在集群[uuid:{1}]上

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageAvoidAllocatorFlow.java:50
# args: spec.getAvoidPrimaryStorageUuids()
after\ removing\ primary\ storage%s\ to\ avoid,\ there\ is\ no\ candidate\ primary\ storage\ anymore = 把主存储{0}移到排除列表后，就没有申请的主存储了

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageBase.java:426
# args: bsUuid,self.getZoneUuid(),self.getUuid()
backup\ storage[uuid\:%s]\ is\ not\ attached\ to\ zone[uuid\:%s]\ the\ primary\ storage[uuid\:%s]\ belongs\ to = 镜像存储[uuid:{0}]没有加载到主存储[uuid:{2}]所在的区域[uuid:{1}]

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageBase.java:533
# args: 
operation\ not\ supported = 不支持的操作

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageCapacityUpdater.java:280
# args: size,capacityVO.getUuid()
cannot\ reserve\ %s\ bytes\ on\ the\ primary\ storage[uuid\:%s],\ it's\ short\ of\ available\ capacity = 无法在主存储[uuid:{1}]上保留{0}字节，可用容量不足

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:88
# args: systemTag,uuid
%s\ is\ invalid.\ %s\ is\ not\ a\ valid\ zstack\ uuid = {0}是无效的，{1}不是一个有效的ZStack uuid

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:92
# args: resourceUuid
no\ primary\ storage[uuid\:%s]\ found = 找不到主存储[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:571
# args: errs
cannot\ find\ any\ qualified\ primary\ storage,\ errors\ are\ %s = 找不到合格的主存储，错误为:{0}

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageReservedCapacityAllocatorFlow.java:48
# args: PrimaryStorageGlobalConfig.RESERVED_CAPACITY.value(),spec.getSize()
after\ subtracting\ reserved\ capacity[%s],\ there\ is\ no\ primary\ storage\ having\ required\ size[%s\ bytes] = 释放保留容量[{0}]后，就没有主存储拥有要求的大小：{1}字节了

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageTagAllocatorExtension.java:126
# args: uuid
cannot\ find\ primary\ storage[uuid\:%s],\ the\ uuid\ is\ specified\ in\ instance\ offering\ or\ disk\ offering = 找不到由实例规格或云盘规格指定的主存储[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageTagAllocatorExtension.java:166
# args: tag
cannot\ find\ primary\ storage\ having\ user\ tag[%s].\ The\ user\ tag\ is\ specified\ in\ instance\ offering\ or\ disk\ offering = 找不到由实例规格或云盘规格指定的拥有指定用户标签的主存储[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageTagAllocatorFlow.java:85
# args: extp.getClass().getName()
PrimaryStorageTagAllocatorExtensionPoint[%s]\ returns\ zero\ primary\ storage\ candidate = 主存储标签分配插件[{0}]返回零个主存储申请

# at: src/main/java/org/zstack/storage/primary/imagestore/local/LocalStorageKvmImageStoreBackupStorageMediatorImpl.java:198
# args: 
System\ can't\ find\ imagestore\ backup\ Storage.\ Please\ do\ not\ set\ imagestore\ backup\ Storage\ server\ IP\ to\ localhost(127.*.*.*), = 系统找不到镜像仓库镜像存储。请不要设置镜像存储服务IP为localhost(127.*.*.*)

# at: src/main/java/org/zstack/storage/primary/imagestore/local/LocalStorageKvmImageStoreBackupStorageMediatorImpl.java:201
# args: operationSuggestion,greply.getHostname(),backupStorageInstallPath,pinv.getUuid(),primaryStorageInstallPath,rsp.getError()
%s\ failed\ to\ download\ bits\ from\ the\ imagestore\ backup\ storage[hostname\:%s,\ path\:\ %s]\ to\ the\ local\ primary\ storage[uuid\:%s,\ path\:\ %s],\ %s = {0}从镜像仓库镜像存储[hostname:{1}, path: {2}]到本地主存储[uuid:{3}, path: {4}]下载失败，{5}

# at: src/main/java/org/zstack/storage/primary/imagestore/nfs/NfsPrimaryToImageStoreBackupKVMBackend.java:305
# args: pinv.getUuid(),primaryStorageInstallPath,r.getHostname(),rsp.getError()
failed\ to\ upload\ bits\ from\ the\ local\ storage[uuid\:%s,\ path\:%s]\ to\ image\ store\ [hostname\:%s],\ %s = {0}从本地主存储[uuid:{0}, path: {1}]到镜像仓库镜像存储[hostname:{2}上传失败，{3}

# at: src/main/java/org/zstack/storage/primary/imagestore/nfs/NfsPrimaryToImageStoreBackupKVMBackend.java:181
# args: volume.getUuid(),image.getImageUuid(),rsp.getError()
fails\ to\ create\ root\ volume[uuid\:%s]\ from\ cached\ image[path\:%s]\ because\ %s = 从镜像[path:{1}]创建根云盘失败，因为{2}

# at: src/main/java/org/zstack/storage/primary/imagestore/nfs/NfsPrimaryToImageStoreBackupKVMBackend.java:235
# args: greply.getHostname(),backupStorageInstallPath,pinv.getUuid(),primaryStorageInstallPath,rsp.getError()
failed\ to\ download\ bits\ from\ the\ imagestore\ backup\ storage[hostname\:%s,\ path\:\ %s]\ to\ the\ local\ primary\ storage[uuid\:%s,\ path\:\ %s],\ %s = 从镜像仓库镜像存储[hostname:{0}, path: {1}]到本地主存储[uuid:{2}, path: {3}]下载失败，{4}

# at: src/main/java/org/zstack/storage/primary/imagestore/smp/KvmAgentCommandDispatcher.java:67
# args: this.primaryStorageUuid
cannot\ find\ any\ connected\ host\ to\ perform\ the\ operation,\ it\ seems\ all\ KVM\ hosts\ in\ the\ clusters\ attached\ with\ the\ shared\ mount\ point\ storage[uuid\:%s]\ are\ disconnected = 找不到任何Connected的物理机去执行操作，看起来加载到shared mount point存储的集群上所有物理机都处于Disconnected状态

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:73
# args: msg.getVolumeUuid()
the\ volume[uuid\:%s]\ is\ not\ on\ any\ local\ primary\ storage = 云盘[uuid:{0}]不在任一本地主存储上

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:77
# args: msg.getVolumeUuid(),msg.getDestHostUuid()
the\ volume[uuid\:%s]\ is\ already\ on\ the\ host[uuid\:%s] = 云盘[uuid:{0}]已经在物理机[uuid:{1}]上

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:82
# args: msg.getPrimaryStorageUuid()
the\ primary\ storage[uuid\:%s]\ is\ not\ found = 主存储[uuid:{0}]未找到

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:86
# args: ref.getPrimaryStorageUuid()
the\ primary\ storage[uuid\:%s]\ is\ disabled\ cold\ migrate\ is\ not\ allowed = 主存储[uuid:{0}]为Disabled时不允许冷迁移

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:93
# args: msg.getDestHostUuid(),ref.getPrimaryStorageUuid(),msg.getVolumeUuid()
the\ dest\ host[uuid\:%s]\ doesn't\ belong\ to\ the\ local\ primary\ storage[uuid\:%s]\ where\ the\ volume[uuid\:%s]\ locates = 目标物理机[uuid:{0}]不属于云盘[uuid:{2}]位于的本地主存储[uuid:{1}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:99
# args: msg.getVolumeUuid()
the\ volume[uuid\:%s]\ is\ not\ in\ status\ of\ Ready,\ cannot\ migrate\ it = 云盘[uuid:{0}]的状态不是Ready，不能迁移

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:124
# args: vol.getUuid(),vol.getVmInstanceUuid(),vmstate
the\ volume[uuid\:%s]\ is\ the\ root\ volume\ of\ the\ vm[uuid\:%s].\ Currently\ the\ vm\ is\ in\ state\ of\ %s,\ please\ stop\ it\ before\ migration = 云盘[uuid:{0}]不是云主机[uuid:{1}]的根云盘。现在这个云主机的状态为{2}，请在迁移前停止它

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:133
# args: vol.getUuid(),vol.getVmInstanceUuid(),count
the\ volume[uuid\:%s]\ is\ the\ root\ volume\ of\ the\ vm[uuid\:%s].\ Currently\ the\ vm\ still\ has\ %s\ data\ volumes\ attached,\ please\ detach\ them\ before\ migration = 云盘[uuid:{0}]不是云主机[uuid:{1}]的根云盘。现在这个云主机仍然有挂载的数据云盘，请在迁移前卸载

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:103
# args: vol.getUuid(),vol.getName(),vol.getVmInstanceUuid()
the\ data\ volume[uuid\:%s,\ name\:\ %s]\ is\ still\ attached\ on\ the\ VM[uuid\:%s].\ Please\ detach\ it\ before\ migration = 数据云盘[uuid:{0}, 名称: {1}]仍然挂载在云主机[uuid:{2}]上，请在迁移前卸载

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:130
# args: msg.getUrl()
the\ url[%s]\ is\ not\ an\ absolute\ path\ starting\ with\ '/' = url[{0}]不是一个以'/'开头的绝对路径

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:210
# args: msg.getPrimaryStorageUuid()
The\ primary\ storage[uuid\:%s]\ is\ disabled\ cold\ migrate\ is\ not\ allowed = 主存储[uuid:{0}]Disabled时不允许冷迁移

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:274
# args: msg.getVolumeUuid()
volume[uuid\:%s]\ is\ not\ on\ the\ local\ storage\ anymore,it\ may\ have\ been\ deleted = 云盘[uuid:{0}]已经不在本地存储上，可能已经被删除

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:778
# args: msg.getImage().getUuid(),self.getUuid(),JSONObjectUtil.toJsonString(ret.errorCodes)
failed\ to\ download\ image[uuid\:%s]\ to\ all\ hosts\ in\ the\ local\ storage[uuid\:%s].\ %s = 在本地存储[uuid:{1}]上往所有物理机下载镜像[uuid:{0}]失败。{2}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:1296
# args: hostUuid,self.getUuid(),ref.getAvailableCapacity(),size
host[uuid\:\ %s]\ of\ local\ primary\ storage[uuid\:\ %s]\ doesn't\ have\ enough\ capacity[current\:\ %s\ bytes,\ needed\:\ %s] = 主存储[uuid:{1}]上的物理机[uuid:{0}]没有足够的容量[现在: {2} bytes, 需要: {3}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:1556
# args: msg.getVolumeUuid(),self.getUuid()
unable\ to\ create\ the\ data\ volume[uuid\:\ %s]\ on\ a\ local\ primary\ storage[uuid\:%s],\ because\ the\ hostUuid\ is\ not\ specified. = 不能在本地主存储[uuid:{1}]上创建云盘[uuid:{0}]，因为物理机uuid没有指定

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:334
# args: spec.getVmInventory().getHypervisorType()
local\ storage\ doesn't\ support\ live\ migration\ for\ hypervisor[%s] = 本地存储不支持虚拟机监视器[{0}]上的热迁移

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:510
# args: volume.getUuid(),vm.getUuid(),vm.getRootVolumeUuid(),rootHost,volume.getUuid(),dataHost
cannot\ attach\ the\ data\ volume[uuid\:%s]\ to\ the\ vm[uuid\:%s].\ Both\ vm's\ root\ volume\ and\ the\ data\ volume\ are\ on\ local\ primary\ storage,\ but\ they\ are\ on\ different\ hosts.\ The\ root\ volume[uuid\:%s]\ is\ on\ the\ host[uuid\:%s]\ but\ the\ data\ volume[uuid\:\ %s]\ is\ on\ the\ host[uuid\:\ %s] = 不能加载数据云盘[uuid:{0}]到云主机[uuid:{1}]。根云盘和数据云盘都在本地主存储上，但他们属于不同的物理机。根云盘[uuid:{2}]在物理机[uuid:{3}]上，但数据云盘[uuid:{4}]在物理机[uuid:{5}]上

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:716
# args: vol.getName(),vol.getUuid(),vol.getPrimaryStorageUuid()
the\ data\ volume[name\:%s,\ uuid\:%s]\ is\ on\ the\ local\ storage[uuid\:%s];\ however,the\ host\ on\ which\ the\ data\ volume\ is\ has\ been\ deleted.\ Unable\ to\ recover\ this\ volume = 数据云盘[name:{0}, uuid:{1}]在本地存储[uuid:{2}]上；然而物理机内的数据云盘已经被删除了

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:759
# args: vm.getUuid(),vm.getName(),psuuid
unable\ to\ recover\ the\ vm[uuid\:%s,\ name\:%s].\ The\ vm's\ root\ volume\ is\ on\ the\ local\ storage[uuid\:%s];\ however,\ the\ host\ on\ which\ the\ root\ volume\ is\ has\ been\ deleted = 不能回复云主机[uuid:{0}, name:{1}]。云主机的根云盘在本地存储[uuid:{2}]上；然而物理机内的根云盘已经被删除了

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:796
# args: vm.getUuid()
unable\ to\ live\ migrate\ with\ local\ storage.\ The\ vm[uuid\:%s]\ has\ volumes\ on\ local\ storage,to\ protect\ your\ data,\ please\ stop\ the\ vm\ and\ do\ the\ volume\ migration = 本地存储不能热迁移。云主机[uuid:{0}]在本地存储上有云盘，为了保护你的数据，请停止云主机做云盘迁移

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:841
# args: LocalStorageSystemTags.DEST_HOST_FOR_CREATING_DATA_VOLUME.getTagFormat()
To\ create\ data\ volume\ on\ the\ local\ primary\ storage,\ you\ must\ specify\ the\ host\ that\ the\ data\ volume\ is\ going\ to\ be\ created\ using\ the\ system\ tag\ [%s] = 要在本地主存储上创建数据云盘，必须用系统标签[0]指定创建数据云盘的物理机

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:851
# args: hostUuid,msg.getPrimaryStorageUuid()
the\ host[uuid\:%s]\ doesn't\ belong\ to\ the\ local\ primary\ storage[uuid\:%s] = 物理机[uuid:{0}] 不属于本地主存储[uuid:{1}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmFactory.java:107
# args: context.getInventory().getUuid(),priUuid,reply.getError()
KVM\ host[uuid\:\ %s]\ fails\ to\ be\ added\ into\ local\ primary\ storage[uuid\:\ %s],\ %s = 物理机[uuid:{0}]添加到主存储[uuid:{1}]失败，{2}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmMigrateVmFlow.java:1099
# args: p.volume.getUuid(),p.volume.getName(),dstHostUuid
unable\ to\ create\ an\ empty\ volume[uuid\:%s,\ name\:%s]\ on\ the\ kvm\ host[uuid\:%s] = 不能创建空的云盘[uuid:{0}, name:{1}]在物理机[uuid:{2}]上

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmSftpBackupStorageMediatorImpl.java:202
# args: greply.getHostname(),backupStorageInstallPath,pinv.getUuid(),primaryStorageInstallPath,rsp.getError()
failed\ to\ download\ bits\ from\ the\ SFTP\ backup\ storage[hostname\:%s,\ path\:\ %s]\ to\ the\ local\ primary\ storage[uuid\:%s,\ path\:\ %s],\ %s = 从SFTP镜像存储[hostname:{0}, path: {1}] 下载到本地存储[uuid:{2}, path: {3}]失败，{4}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmSftpBackupStorageMediatorImpl.java:253
# args: pinv.getUuid(),primaryStorageInstallPath,r.getHostname(),backupStorageInstallPath,rsp.getError()
failed\ to\ upload\ bits\ from\ the\ local\ storage[uuid\:%s,\ path\:%s]\ to\ the\ SFTP\ backup\ storage[hostname\:%s,\ path\:%s],\ %s = 从本地存储[uuid:{0}, path: {1}]上传到SFTP镜像存储[hostname:{2}, path:{3}]失败, {4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsApiParamChecker.java:31
# args: url,zoneUuid
there\ has\ been\ a\ nfs\ primary\ storage\ having\ url\ as\ %s\ in\ zone[uuid\:%s] = 已经存在NFS主存储在区域[uuid:{1}]内拥有url{0}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:232
# args: vms.size(),StringUtils.join(vms, "\n")
there\ are\ %s\ running\ VMs\ on\ the\ NFS\ primary\ storage,\ please\ stop\ them\ and\ try\ again\:\
%s\
 = 

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:247
# args: 
cannot\ find\ usable\ backend = 

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:272
# args: 
no\ usable\ backend\ found = 

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:411
# args: self.getUuid(),self.getName(),msg.getVolume().getUuid(),msg.getSnapshot().getUuid(),msg.getSnapshot().getName()
no\ host\ in\ Connected\ status\ to\ which\ nfs\ primary\ storage[uuid\:%s,\ name\:%s]\ attached\ found\ to\ revert\ volume[uuid\:%s]\ to\ snapshot[uuid\:%s,\ name\:%s] = 

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:441
# args: self.getUuid(),self.getName(),msg.getVolume().getUuid(),msg.getVolume().getRootImageUuid()
no\ host\ in\ Connected\ status\ to\ which\ nfs\ primary\ storage[uuid\:%s,\ name\:%s]\ attached\ found\ to\ revert\ volume[uuid\:%s]\ to\ image[uuid\:%s] = 

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:513
# args: vol.getVmInstanceUuid(),vmState
vm[uuid\:%s]\ is\ not\ Running\ or\ Stopped,\ current\ state\ is\ %s = 

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:560
# args: self.getUuid()
primary\ storage[uuid\:%s]\ doesn't\ attach\ to\ any\ cluster = 

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:736
# args: self.getUuid(),self.getName(),msg.getVolume().getUuid(),msg.getVolume().getName()
the\ NFS\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ any\ usable\ host\ to\ create\ the\ data\ volume[uuid\:%s,\ name\:%s] = 

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:1016
# args: self.getUuid(),self.getName()
the\ NFS\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ hosts\ in\ attached\ clusters\ to\ perform\ the\ operation = NFS主存储[uuid:{0}, name:{1}]不能找到物理机挂载到集群，执行此操作

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:1209
# args: self.getUuid(),self.getName()
the\ NFS\ primary\ storage[uuid\:%s,\ name\:%s]\ has\ not\ attached\ to\ any\ clusters,\ or\ no\ hosts\ in\ the\ attached\ clusters\ are\ connected = NFS主存储[uuid:{0}, name:{1}] 没有挂载到任何一个集群，或者挂载到集群的物理机均无法连接

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageFactory.java:185
# args: pri.getUuid()
cannot\ find\ a\ Connected\ host\ to\ execute\ command\ for\ nfs\ primary\ storage[uuid\:%s] = 对nfs主存储[uuid:{0}]来说不能发现一个可连接的物理机执行命令

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageFactory.java:225
# args: psUuid,imageFormat
cannot\ find\ proper\ hypervisorType\ for\ primary\ storage[uuid\:%s]\ to\ handle\ image\ format\ or\ volume\ format[%s] = 对主存储[uuid:{0}]来说不能发现合适的管理程序类型来处理镜像格式或云盘格式[{1}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:206
# args: inv.getUuid(),inv.getName(),clusterUuid,versionInCluster,otherVersion,QCOW3_QEMU_IMG_VERSION,QCOW3_QEMU_IMG_VERSION
unable\ to\ attach\ a\ primary\ storage[uuid\:%s,\ name\:%s]\ to\ cluster[uuid\:%s].\ Kvm\ host\ in\ the\ cluster\ has\ qemu-img\ with\ version[%s];\ but\ the\ primary\ storage\ has\ attached\ to\ another\ cluster\ that\ has\ kvm\ host\ which\ has\ qemu-img\ with\ version[%s].\ qemu-img\ version\ greater\ than\ %s\ is\ incompatible\ with\ versions\ less\ than\ %s,\ this\ will\ causes\ volume\ snapshot\ operation\ to\ fail.\ Please\ avoid\ attaching\ a\ primary\ storage\ to\ clusters\ that\ have\ different\ Linux\ distributions,\ in\ order\ to\ prevent\ qemu-img\ version\ mismatch = 不能挂载主存储[uuid:{0}, name:{1}]到集群[uuid:{2}].集群中的物理机存在[{3}]版本qemu-img；但是主存储已经挂载到另一个物理机拥有[{4}]版本qemu-img的集群。版本大于{5}的qemu-img不兼容版本小于{6}，这将会造成云盘快照操作失败。为了防止qemu-img版本不兼容，请避免挂载主存储到物理机装有不同linux版本的集群

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:502
# args: installPath,inv.getUuid(),rsp.getError()
failed\ to\ check\ existence\ of\ %s\ on\ nfs\ primary\ storage[uuid\:%s],\ %s = 检查nfs主存储中是否存在{0}失败

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:560
# args: context.getInventory().getUuid(),context.getInventory().getName(),mine,e.getKey(),version,QCOW3_QEMU_IMG_VERSION,QCOW3_QEMU_IMG_VERSION
unable\ to\ attach\ a\ primary\ storage\ to\ cluster.\ Kvm\ host[uuid\:%s,\ name\:%s]\ in\ cluster\ has\ qemu-img\ with\ version[%s];\ but\ the\ primary\ storage\ has\ attached\ to\ a\ cluster\ that\ has\ kvm\ host[uuid\:%s],\ which\ has\ qemu-img\ with\ version[%s].\ qemu-img\ version\ greater\ than\ %s\ is\ incompatible\ with\ versions\ less\ than\ %s,\ this\ will\ causes\ volume\ snapshot\ operation\ to\ fail.\ Please\ avoid\ attaching\ a\ primary\ storage\ to\ clusters\ that\ have\ different\ Linux\ distributions,\ in\ order\ to\ prevent\ qemu-img\ version\ mismatch = 不能挂载主存储到集群。集群中的物理机[uuid:{0}, name:{1}]拥有[{2}]版本的qemu-img；但是主存储已经挂载到拥有[{4}]版本qemu-img的集群上。版本大于{5}的qemu-img不兼容版本小于{6}，这将会造成云盘快照操作失败。为了防止qemu-img版本不兼容，请避免挂载主存储到物理机装有不同linux版本的集群

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:607
# args: volume.getUuid(),volume.getName(),host.getUuid(),host.getManagementIp(),rsp.getError()
unable\ to\ create\ empty\ volume[uuid\:%s,\ \ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = 不能在物理机[uuid:{2}, ip:{3}]上创建空云盘[uuid:{0},  name:{1}]，因为{4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:723
# args: vol.getUuid(),sinv.getUuid(),host.getUuid(),host.getManagementIp(),rsp.getError()
failed\ to\ revert\ volume[uuid\:%s]\ to\ snapshot[uuid\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ %s = 回滚在物理机[uuid:{2}, ip:{3}]上的云盘[uuid:{0}]到快照[uuid:{1}]的状态失败，{4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:756
# args: vol.getUuid(),vol.getRootImageUuid(),host.getUuid(),host.getManagementIp(),rsp.getError()
failed\ to\ revert\ volume[uuid\:%s]\ to\ image[uuid\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ %s = 回滚在物理机[uuid:{2}, ip:{3}]上的云盘[uuid:{0}]到镜像[uuid:{1}]，{4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:961
# args: errors
%s = 

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryToSftpBackupKVMBackend.java:159
# args: backupStorageInstallPath,greply.getHostname(),pinv.getUuid(),primaryStorageInstallPath,rsp.getError()
failed\ to\ download[%s]\ from\ SftpBackupStorage[hostname\:%s]\ to\ nfs\ primary\ storage[uuid\:%s,\ path\:%s],\ %s = 从Sftp镜像存储[hostname:{1}] 下载[{0}]到nfs主存储[uuid:{2}, path:{3}]失败，{4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryToSftpBackupKVMBackend.java:216
# args: pinv.getUuid(),primaryStorageInstallPath,hostname,backupStorageInstallPath,rsp.getError()
failed\ to\ upload\ bits\ from\ nfs\ primary\ storage[uuid\:%s,\ path\:%s]\ to\ SFTP\ backup\ storage[hostname\:%s,\ path\:\ %s],\ %s = 从nfs主存储[uuid:{0}, path:{1}]上传比特到STFP镜像存储[hostname:{2}, path: {3}]失败，{4}

# at: src/main/java/org/zstack/storage/primary/smp/KvmBackend.java:206
# args: clusterUuid
no\ connected\ host\ found\ in\ the\ cluster[uuid\:%s] = cluster[uuid:{0}]不存在已连接的物理机

# at: src/main/java/org/zstack/storage/primary/smp/KvmBackend.java:641
# args: 
cannot\ find\ any\ connected\ host\ to\ perform\ the\ operation = 找不到处于Connected状态的物理机来执行操作

# at: src/main/java/org/zstack/storage/primary/smp/KvmBackend.java:926
# args: volume.getUuid(),volume.getVmInstanceUuid(),state
the\ volume[uuid;%s]\ is\ attached\ to\ a\ VM[uuid\:%s]\ which\ is\ in\ state\ of\ %s,\ cannot\ do\ the\ snapshot\ merge = 云盘[uuid;{0}] 挂载到处于{2}状态的虚拟机，不能合并快照

# at: src/main/java/org/zstack/storage/primary/smp/KvmBackend.java:979
# args: img.getUuid(),img.getName(),self.getZoneUuid()
the\ image[uuid\:%s,\ name\:\ %s]\ is\ not\ available\ to\ download\ on\ any\ backup\ storage\:\
1.\ check\ if\ image\ is\ in\ status\ of\ Deleted\
2.\ check\ if\ the\ backup\ storage\ on\ which\ the\ image\ is\ shown\ as\ Ready\ is\ attached\ to\ the\ zone[uuid\:%s] = 不能从镜像存储中下载镜像[uuid:%s, name: %s]\
1.检查镜像是否处于被删除状态\
2.检查镜像处于就绪状态的镜像存储是否挂载到区域[uuid:{2}]

# at: src/main/java/org/zstack/storage/primary/smp/KvmBackend.java:1298
# args: backupStorageUuid
cannot\ find\ backup\ storage[uuid\:%s] = 找不到镜像存储[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/smp/SMPPrimaryStorageBase.java:87
# args: self.getUuid(),self.getName()
the\ shared\ mount\ point\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ any\ available\ host\ in\ attached\ clusters\ for\ instantiating\ the\ volume = 共享挂载点主存储[uuid:{0}, name:{1}]在挂载的集群中找不到任何可用的物理机来实例化云盘

# at: src/main/java/org/zstack/storage/primary/smp/SMPPrimaryStorageBase.java:326
# args: 
not\ supported\ operation = 不支持的操作

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotApiInterceptor.java:82
# args: msg.getUuid()
volume\ snapshot[uuid\:%s]\ is\ not\ on\ primary\ storage,\ cannot\ be\ backed\ up = 云盘快照[uuid:{0}]不在主存储上，不能备份

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotApiInterceptor.java:90
# args: msg.getUuid(),msg.getBackupStorageUuid()
volume\ snapshot[uuid\:%s]\ is\ already\ on\ backup\ storage[uuid\:\ %s] = 云盘快照[uuid:{0}]已经在备份存储[uuid: {1}]上

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotApiInterceptor.java:102
# args: msg.getUuid(),priUuid,zoneUuid,msg.getBackupStorageUuid()
volume\ snapshot[uuid\:%s]\ is\ on\ primary\ storage[uuid\:%s]\ which\ is\ in\ zone[uuid\:%s]\ that\ backup\ storage[uuid\:%s]\ is\ not\ attached\ to = 云盘快照存放在主存储[uuid:{1}]，而主存储[uuid:{1}]挂载在未挂载备份存储[uuid:{3}]的区域[uuid:{2}]

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotApiInterceptor.java:110
# args: 
either\ volumeUuid\ or\ treeUuid\ must\ be\ set = 云盘Uuid或者快照树Uuid必须设置

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotApiInterceptor.java:130
# args: msg.getVolumeUuid(),status
volume[uuid\:%s]\ is\ not\ in\ status\ Ready,\ current\ is\ %s,\ can't\ create\ snapshot = 云盘[uuid:{0}]未出于就绪状态，当前是{1}，不能创建快照

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotApiInterceptor.java:157
# args: msg.getUuid(),state
volume\ snapshot[uuid\:%s]\ is\ in\ state\ %s,\ cannot\ revert\ volume\ to\ it = 云盘快照[uuid:{0}]出于状态{1}，不能恢复云盘到该快照状态

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotApiInterceptor.java:162
# args: msg.getUuid()
original\ volume\ for\ snapshot[uuid\:%s]\ has\ been\ deleted,\ cannot\ revert\ volume\ to\ it = 快照[uuid:{0}]的原版云盘已经被删除，不能恢复云盘到该快照

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotManagerImpl.java:312
# args: primaryStorageUuid,vol.getUuid()
primary\ storage[uuid\:%s]\ doesn't\ support\ volume\ snapshot;\ cannot\ create\ snapshot\ for\ volume[uuid\:%s] = 主存储[uuid:{0}]不能支持云盘快照，不能为云盘[uuid:{1}]创建快照

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotTreeBase.java:132
# args: currentRoot.getUuid(),currentRoot.getName()
cannot\ find\ volume\ snapshot[uuid\:%s,\ name\:%s],\ it\ may\ have\ been\ deleted\ by\ previous\ operation = 不能创建云盘快照[uuid:{0}, name:{1}]，该快照可能已经被以前的操作删除

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotTreeBase.java:616
# args: failSnapshot.getUuid(),failSnapshot.getName(),evt
failed\ to\ change\ status\ of\ volume\ snapshot[uuid\:%s,\ name\:%s]\ by\ status\ event[%s] = 通过状态事件[{2}]改变云盘快照[uuid:{0}, name:{1}]失败

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotTreeBase.java:1210
# args: rmsg.getVolume().getUuid(),rmsg.getSnapshot().getUuid(),rmsg.getVolume().getVmInstanceUuid(),state
unable\ to\ reset\ volume[uuid\:%s]\ to\ snapshot[uuid\:%s],\ the\ vm[uuid\:%s]\ volume\ attached\ to\ is\ not\ in\ Stopped\ state,\ current\ state\ is\ %s = 不能重置云盘[uuid:{0}]到快照[uuid:{1}]状态，云盘的虚拟机[uuid:{2}]未处于停止状态，当前状态是{3}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:87
# args: msg.getVolumeUuid()
the\ volume[uuid\:%s]\ is\ not\ in\ status\ of\ deleted.\ This\ is\ operation\ is\ to\ recover\ a\ deleted\ data\ volume = 云盘[uuid:{0}]未处于删除状态。此操作将覆盖一个被删除的数据云盘

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:183
# args: vol.getUuid()
the\ volume[uuid\:%s]\ is\ in\ status\ of\ deleted,\ cannot\ do\ the\ operation = 云盘[uuid:{0}]出于删除操作，不能执行此操作

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:106
# args: msg.getImageUuid(),ImageMediaType.DataVolumeTemplate,type
image[uuid\:%s]\ is\ not\ %s,\ it's\ %s = 镜像[uuid:{0}]不是{1}，而是{2}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:111
# args: img.getUuid(),img.getState()
image[uuid\:%s]\ is\ not\ Enabled,\ it's\ %s = 镜像不能启用，此镜像是{1}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:115
# args: img.getUuid(),img.getStatus()
image[uuid\:%s]\ is\ not\ Ready,\ it's\ %s = 镜像未准备就绪，此镜像是{1}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:126
# args: msg.getVolumeUuid()
volume[uuid\:%s]\ is\ Root\ volume,\ can\ not\ be\ attach\ to\ vm = 

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:133
# args: msg.getVolumeUuid(),state,VolumeState.Enabled
volume[uuid\:%s]\ is\ in\ state[%s],\ data\ volume\ can\ only\ be\ attached\ when\ state\ is\ %s = 云盘[uuid:{0}]处于[{1}]状态，数据云盘只能在处于{2}状态的时候挂载

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:138
# args: msg.getVolumeUuid(),status,VolumeStatus.Ready,VolumeStatus.NotInstantiated
volume[uuid\:%s]\ is\ in\ status[%s],\ data\ volume\ can\ only\ be\ attached\ when\ status\ is\ %s\ or\ %S = 云盘[uuid:{0}]处于[{1}]，数据云盘只能在处于{2}或%S状态的时候挂载

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:145
# args: msg.getVolumeUuid()
data\ volume[uuid\:%s]\ is\ not\ attached\ to\ any\ vm,\ can't\ detach = 数据云盘没有被挂载到云盘，不能卸载

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:149
# args: msg.getVolumeUuid()
to\ detach\ shareable\ data\ volume[uuid\:%s],\ vm\ uuid\ is\ needed. = 卸载共享数据云盘[uuid:{0}]需要虚拟机的uuid

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:165
# args: vol.getUuid(),vol.getName()
the\ volume[uuid\:%s,\ name\:%s]\ is\ Root\ Volume,\ can't\ detach\ it = 不能卸载根云盘[uuid:{0}, name:{1}]

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:174
# args: vol.getUuid(),vol.getName()
the\ volume[uuid\:%s,\ name\:%s]\ is\ Root\ Volume,\ can't\ attach\ it = 不能挂载根云盘[uuid:{0}, name:{1}]

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:179
# args: vol.getUuid()
data\ volume[uuid\:%s]\ is\ Disabled,\ can't\ attach = 数据云盘已被禁用，不能挂载

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:176
# args: vol.getUuid(),vol.getVmInstanceUuid()
data\ volume[%s]\ has\ been\ attached\ to\ vm[uuid\:%s],\ can't\ attach\ again = 数据云盘已经被挂载到虚拟机[uuid:{1}]，不能再次挂载

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:181
# args: VolumeStatus.Ready,VolumeStatus.NotInstantiated,vol.getStatus()
data\ volume\ can\ only\ be\ attached\ when\ status\ is\ [%s,\ %s],\ current\ is\ %s = 数据云盘仅能当处于[{0}, {1}]状态挂载，当前状态是{2}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:192
# args: vol.getUuid(),vol.getFormat(),volHvType,msg.getVmInstanceUuid(),hvType
data\ volume[uuid\:%s]\ has\ format[%s]\ that\ can\ only\ be\ attached\ to\ hypervisor[%s],\ but\ vm[uuid\:%s]\ has\ hypervisor\ type[%s].\ Can't\ attach = 只有[{1}]格式的数据云盘[uuid:{0}]才能被挂载到管理程序[{2}]，但是虚拟机是[{4}]类型的管理程序，数据云盘不能挂载到该虚拟机

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:225
# args: hvType,maxDataVolumeNum,count,msg.getVmInstanceUuid()
hypervisor[%s]\ only\ allows\ max\ %s\ data\ volumes\ to\ be\ attached\ to\ a\ single\ vm;\ there\ have\ been\ %s\ data\ volumes\ attached\ to\ vm[uuid\:%s] = [{0}]管理程序仅允许最大不超过{1}数据云盘挂载到单个虚拟机。{2} data volumes已经挂载到虚拟机[uuid:{3}]

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:215
# args: msg.getUuid()
it's\ not\ allowed\ to\ backup\ root\ volume,\ uuid\:%s = 备份根云盘不被允许，uuid:{0}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:234
# args: msg.getVolumeUuid()
volume[uuid\:%s]\ is\ Root\ volume,\ can't\ be\ deleted = 不能删除根云盘[uuid:{0}]

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:260
# args: msg.getVolumeUuid()
volume[uuid\:%s]\ is\ already\ in\ status\ of\ deleted = 云盘[uuid:{0}]早已处于被删除状态

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:253
# args: msg.getUuid()
it's\ not\ allowed\ to\ change\ state\ of\ root\ volume,\ uuid\:%s = 不能改变根云盘状态，uuid:{0}

# at: src/main/java/org/zstack/storage/volume/VolumeBase.java:450
# args: self.getUuid(),self.getName()
the\ volume[uuid\:%s,\ name\:%s]\ is\ not\ deleted\ yet,\ can't\ expunge\ it = 云盘[uuid:{0}, name:{1}]仍未被删除，不能清除该云盘

# at: src/main/java/org/zstack/storage/volume/VolumeManagerImpl.java:325
# args: template.getUuid(),template.getName()
the\ image[uuid\:%s,\ name\:%s]\ has\ been\ deleted\ on\ all\ backup\ storage = 镜像[uuid:{0}, name:{1}]已经从所有的镜像存储中删除

# at: src/main/java/org/zstack/storage/volume/VolumeManagerImpl.java:337
# args: template.getUuid(),msg.getPrimaryStorageUuid()
cannot\ find\ a\ backup\ storage\ on\ which\ the\ image[uuid\:%s]\ is\ that\ satisfies\ all\ conditions\ of\:\ 1.\ has\ state\ Enabled\ 2.\ has\ status\ Connected.\ 3\ has\ attached\ to\ zone\ in\ which\ primary\ storage[uuid\:%s]\ is = 

# at: src/main/java/org/zstack/storage/volume/VolumeManagerImpl.java:590
# args: VolumeFactory.class.getSimpleName()
there\ should\ not\ be\ more\ than\ one\ %s\ implementation. = 不允许超过一种实现

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:34
# args: 
SharedVolume\ cannot\ be\ set\ bandwidth. = 共享云盘不允许设置带宽

# at: src/main/java/org/zstack/tag/TagApiInterceptor.java:58
# args: msg.getResourceType()
no\ resource\ type[%s]\ found\ in\ tag\ system = 标签系统中不存在[{0}]资源类型

# at: src/main/java/org/zstack/tag/TagApiInterceptor.java:77
# args: msg.getUuid()
tag[uuid\:%s]\ is\ an\ inherent\ system\ tag,\ can\ not\ be\ removed = 固有系统标签[uuid:{0}]禁止移除

# at: src/main/java/org/zstack/tag/TagApiInterceptor.java:99
# args: 
The\ argument\ \:'resourceType'\ doesn't\ match\ uuid = 

# at: src/main/java/org/zstack/tag/TagManagerImpl.java:199
# args: tag,type,resourceType,resourceUuid
Duplicated\ Tag[tag\:%s,\ type\:%s,\ resourceType\:%s,\ resourceUuid\:%s] = 标签[tag:{0}, type:{1}, resourceType:{2}, resourceUuid:{3}]重复

# at: src/main/java/org/zstack/tag/TagManagerImpl.java:742
# args: tag
no\ system\ tag\ matches\ %s = 没有找到匹配{0}的系统标签

# at: src/main/java/org/zstack/vmware/VCenterApiInterceptor.java:35
# args: msg.getUsername()
vCenter\ login\ name\ expected,\ got\:\ %s = vCenter需要登录名字，得到：{0}

# at: src/main/java/org/zstack/vmware/VCenterApiInterceptor.java:39
# args: msg.getDomainName()
domainName[%s]\ is\ neither\ an\ IPv4\ address\ nor\ a\ valid\ hostname = 域名[{0}]不是一个IPv4地址或有效的主机名

# at: src/main/java/org/zstack/vmware/VCenterApiInterceptor.java:45
# args: msg.getDomainName()
vCenter\ [domainName\:%s]\ has\ been\ added = vCenter[domainName:{0}]已经被添加