# at: src/main/java/org/zstack/accessKey/AccessKeyApiInterceptor.java:44
# args: accountUuid,userUuid
no\ pemission\ to\ do\ the\ operation\ for\ [accountUuid\:%s,\ userUuid\:%s] = 

# at: src/main/java/org/zstack/accessKey/AccessKeyApiInterceptor.java:59
# args: msg.getAccountUuid(),msg.getUserUuid()
[accountId\:\ %s,\ userID\:\ %s]\ is\ not\ valid\ account\ or\ iam2\ porject/user = 

# at: src/main/java/org/zstack/accessKey/AccessKeyApiInterceptor.java:71
# args: msg.getAccountUuid(),msg.getUserUuid()
accessKey\ number\ for\ [accountId\:\ %s,\ userID\:\ %s]exceeds\ the\ max = 

# at: src/main/java/org/zstack/aliyun/account/AliyunAccountBase.java:341
# args: builder.deleteCharAt(builder.length() - 1),timeout
cannot\ connect\ to\ [%s]\ in\ %d\ milliseconds,\ so\ aliyun\ openapi\ is\ unreachable. = 

# at: src/main/java/org/zstack/aliyun/backup/BackupToAliyunBase.java:465
# args: 
no\ bucket\ found\ for\ backup = 没有可用的Bucket执行备份

# at: src/main/java/org/zstack/aliyun/core/AliyunEbsClient.java:28
# args: 
accessKey\ and\ keySecret\ must\ be\ set = 必须设置accessKey和keySecret

# at: src/main/java/org/zstack/aliyun/core/AliyunEbsClient.java:73
# args: 
ocean\ api\ endpoint\ must\ not\ be\ null = 

# at: src/main/java/org/zstack/aliyun/core/AliyunNasClient.java:33
# args: 
accessKey\ and\ keySecret\ must\ be\ set! = 

# at: src/main/java/org/zstack/aliyun/core/AliyunNasClient.java:40
# args: 
regionId\ must\ be\ set! = 

# at: src/main/java/org/zstack/aliyun/core/AliyunSdkImpl.java:2119
# args: AliyunConstant.DEFAULT_ENTRY_WAIT_STATUS_TIMEOUT
entry\ is\ still\ existed\ after\ %s\ ms = 虚拟路由器删除超时（{0} ms）

# at: src/main/java/org/zstack/aliyun/core/AliyunSdkImpl.java:2657
# args: 
image\ already\ existed\ remote,\ please\ use\ sync\ first. = 镜像已经存在阿里云服务器上，请尝试同步数据

# at: src/main/java/org/zstack/aliyun/core/AliyunSdkImpl.java:2845
# args: 
no\ identity\ zones\ can\ be\ used\ now = 没有可用区能使用

# at: src/main/java/org/zstack/aliyun/core/AliyunSdkImpl.java:2981
# args: request.getRegionId()
regionId[%s]\ is\ invalid\ by\ aliyun! = regionId[{0}]是无效的！

# at: src/main/java/org/zstack/aliyun/core/AliyunStorageSdkIml.java:63
# args: 
Not\ a\ valid\ message! = 

# at: src/main/java/org/zstack/aliyun/core/AliyunStorageSdkIml.java:159
# args: action,result.ErrorCode,result.ErrorMessage
%s\ failed,\ ErrorCode\:\ %s,\ ErrorMessage\:\ %s = 

# at: src/main/java/org/zstack/aliyun/core/AliyunStorageSdkIml.java:282
# args: 15000
Device\ Not\ Ready\ in\ %d\ milli\ seconds = 

# at: src/main/java/org/zstack/aliyun/core/AliyunStorageSdkIml.java:476
# args: result.Content.TaskStatus
snapshot\ task\ status\ is\ finished\ %s = 

# at: src/main/java/org/zstack/aliyun/core/AliyunStorageSdkIml.java:472
# args: msg.getTimeout(),result.Content.Progress,result.Content.TaskStatus
snapshot\ task\ cannot\ finished\ in\ %d\ milliseconds,\ now\ progress\ is\ %d,\ status\ is\ %s = 

# at: src/main/java/org/zstack/aliyun/core/AliyunStorageSdkIml.java:874
# args: 
not\ supported\ HybridClient = 

# at: src/main/java/org/zstack/aliyun/core/AliyunUtils.java:258
# args: e.getMessage()
add\ endpoint\ to\ sdk\ failed,\ due\ to\:\ %s = 

# at: src/main/java/org/zstack/aliyun/core/OssSdkImpl.java:85
# args: 
cannot\ find\ key\ /\ secret\ from\ msg = 

# at: src/main/java/org/zstack/aliyun/core/OssSdkImpl.java:407
# args: 
cannot\ input\ 0-length\ file\ as\ vm\ images! = 

# at: src/main/java/org/zstack/aliyun/core/OssSdkImpl.java:496
# args: e.getMessage()
Permission\ denied\ for\:\ %s = 

# at: src/main/java/org/zstack/aliyun/core/OssSdkImpl.java:585
# args: e.getRequestId()
Bucket\ name\ is\ already\ existed\ (maybe\ created\ by\ other\ user),\ Please\ select\ a\ different\ name\ and\ try\ again.(aliyun\ request-id\:\ %s) = Bucket名称已经存在（可能已经被别的用户使用了），请尝试使用一个新的命名。（阿里云请求ID: {0}）

# at: src/main/java/org/zstack/aliyun/core/datacenter/AliyunPrivateDataCenterBase.java:277
# args: HybridType.AliyunEBS.toString()
arg\ 'endpoint'\ must\ be\ set\ in\ %s\ type = 

# at: src/main/java/org/zstack/aliyun/core/datacenter/AliyunPrivateDataCenterBase.java:332
# args: type.toString()
not\ supported\ datacenter\ [%s]\ type\ here! = 

# at: src/main/java/org/zstack/aliyun/core/identityzone/AliyunPrivateIdentityZoneBase.java:252
# args: 
must\ indicate\ zoneId\ in\ private\ aliyun. = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/OceanApi.java:87
# args: e.getMessage()
make\ ocean\ api\ signature\ string\ failed\:\ %s = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/backup/AliyunEbsBackupStorageApiInterceptor.java:30
# args: 
url(ocean\ endpoint)\ must\ be\ set\ for\ aliyun\ ebs\ backupstorage = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/backup/AliyunEbsBackupStorageBase.java:95
# args: 
cannot\ support\ qcow2\ format\ on\ ebs = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/backup/AliyunEbsBackupStorageBase.java:620
# args: objectFile,ovo.getBucketName()
no\ such\ object\ %s\ found\ in\ bucket\ %s = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/backup/AliyunEbsBackupStorageCascadeExtenstion.java:46
# args: oss.getUuid(),evo.getUuid()
cannot\ delete\ oss\ bucket\ [%s],\ Aliyun\ Ebs\ BackupStorage\ [%s]\ still\ existed,\ please\ delete\ it\ first. = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsKvmFactory.java:148
# args: vol.getUuid()
cannot\ find\ device\ path\ from\ volume\:\ %s = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsKvmFactory.java:491
# args: 
aliyun\ ebs\ not\ support\ resize\ on\ running\ vm\ now. = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsKvmFactory.java:613
# args: isoUuid
iso\ [%s]\ has\ been\ attached,\ we\ can\ not\ attach\ it\ until\ detach\ it = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageApiInterceptor.java:39
# args: msg.getUrl()
url\ must\ starts\ with\ http\://\ or\ https\://,\ but\ got\ %s = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageApiInterceptor.java:35
# args: 
url(ocean\ endpoint)\ must\ be\ set\ for\ aliyun\ ebs\ primarystorage = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageApiInterceptor.java:43
# args: 
panguPartitionUuid\ or\ identityZoneUuid\ must\ be\ set. = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageApiInterceptor.java:49
# args: msg.getPanguPartitionUuid(),msg.getIdentityZoneUuid()
panguPartitionUuid\ [%s]\ not\ be\ matched\ with\ identityZoneUuid\ [%s] = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageBase.java:674
# args: self.getUuid(),self.getName()
the\ aliyun\ ebs\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ any\ available\ host\ in\ attached\ clusters\ for\ instantiating\ the\ volume = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageBase.java:2827
# args: reply1.getProgress()
create\ snapshot\ timeout,\ progress\ is\ %d = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageBase.java:1925
# args: msg.getVolume().getRootImageUuid()
cannot\ find\ snapshot\ from\ image\:\ %s,\ maybe\ the\ image\ has\ been\ deleted = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageBase.java:2685
# args: 
ebs\ primarystorage\ cannot\ support\ decrease\ size\ now = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageBase.java:3087
# args: bsvo.getType()
aliyun\ ebs\ primarystorage\ only\ support\ aliyun\ ebs\ bs,\ actually\ get\ type\:\ %s = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStorageCascadeExtension.java:46
# args: iz.getUuid(),evo.getUuid()
cannot\ delete\ identity\ zone\ [%s],\ Aliyun\ Ebs\ PrimaryStorage\ [%s]\ still\ existed,\ please\ delete\ it\ first. = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStoragePathMaker.java:113
# args: installPath
invalid\ install\ path\:\ %s = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStoragePathMaker.java:24
# args: volumeId,url
append\ volumeId\:\ %s,\ but\ another\ volumeId\ existed\ in\ url\:\ %s = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStoragePathMaker.java:79
# args: url
invalid\ install\ url\:\ %s = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStoragePathMaker.java:35
# args: hostUuid,url
hostUuid\ [%s]\ already\ existed\ in\ url\:\ %s = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStoragePathMaker.java:83
# args: hostUuid
cannot\ find\ devicePath\ on\ host\:\ %s = 

# at: src/main/java/org/zstack/aliyun/ebs/storage/primary/AliyunEbsPrimaryStoragePathMaker.java:128
# args: installPath
invalid\ snapshot\ install\ path\:\ %s = 

# at: src/main/java/org/zstack/aliyun/ecs/CheckEcsImageExistPublicFlow.java:79
# args: eivo.getUuid(),eivo.getName(),eivo.getCreateDate()
ecs\ image\ existed\ remote\ and\ local,\ ecs\ image\ uuid\:\ %s,\ name\:\ %s,\ created\ time\:\ %s = 云主机镜像存在于阿里云服务器和本地，云主机镜像的uuid: {0}，名称: {1}，创建时间: {2}

# at: src/main/java/org/zstack/aliyun/ecs/CheckEcsImageExistPublicFlow.java:107
# args: msg.getName(),new SimpleDateFormat("yyyy/MM/dd HH:mm:ss").format(HybridUtilsForAliyun.fmtTime(rpl.getCreateDate()))
ecs\ image\ existed\ remote,\ name\:\ %s,\ created\ time\:\ %s = 云主机镜像已经存在于阿里云服务器上，名称: {0}，创建时间: {1}

# at: src/main/java/org/zstack/aliyun/ecs/CreateEcsInstancePublicFlow.java:180
# args: 
No\ Available\ instance\ types\ now. = 没有可用的实例类型

# at: src/main/java/org/zstack/aliyun/ecs/CreateEcsInstancePublicFlow.java:303
# args: ecs.getUuid(),ecs.getEcsInstanceId()
no\ system\ disk\ found\ for\ ecs\:\ [%s],\ ecs\ id\ is\:\ [%s] = 没有系统云盘可用来创建云主机，云主机id是: [{1}]

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:65
# args: evo.getEcsStatus().toString()
Only\ delete\ ecs\ which\ status\ is\ running\ or\ stopped,\ now\ is\ %s = 只能删除状态为运行中或者已停止的云主机，现在云主机状态为{0}

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:70
# args: evo.getChargeType().toString()
Only\ postpaid\ ecs\ support\ delete\ remote,\ the\ indicate\ ecs\ charge\ type\ is\:\ %s = 只有已付费的云主机支持删除，目前云主机付费状态是: {0}

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:84
# args: 
Only\ admin\ can\ set\ parameter\ [onlyZstack]\ \=\ false = 只有管理员能设置[onlyZsatck]参数为false

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:93
# args: evo.getAvailableIpAddressCount()
vSwitch\ availableIpAddress\ is\ not\ enough,\ now\ is\ (%d) = 虚拟交换机可用IP地址不够，现有IP地址数量({0})

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:97
# args: privateIp,cidr
%s\ is\ not\ in\ cidr\ range\:\ %s = {0}没有在CIDR范围中: {1}

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:103
# args: vSwitchUuid,ecs.getUuid()
private\ ip\ is\ existed\ in\ vswitch\:\ %s,\ allocated\ to\ ecs\:\ %s = 私有IP已经存在虚拟交换机中: {0}，已分配给云主机: {1}

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:137
# args: 
bandwidth\ must\ be\ set\ while\ allocate\ publicIp = 当分配公有IP时带宽必须被设置

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:140
# args: msg.getPrivateIpAddress()
%s\ is\ not\ ipv4\ address = {0}不是一个ipv4地址

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:143
# args: msg.getEcsRootVolumeType(),EcsInstanceConstant.validVolumeCategory.toString()
%s\ is\ not\ valid\ volume\ type,\ valid\ types\ are\ [%s] = {0}不是有效的云盘类型，有效的云盘类型有[{1}]

# at: src/main/java/org/zstack/aliyun/ecs/EcsApiInterceptor.java:147
# args: 
instanceOffering\ or\ instanceType\ must\ be\ set! = 计算规格和实例类型必须被设置

# at: src/main/java/org/zstack/aliyun/ecs/EcsInstanceManagerImpl.java:375
# args: rly1.getVncUrl()
decode\ url\ failed\:\ %s = url解码失败: {0}

# at: src/main/java/org/zstack/aliyun/ecs/ExportImageFromBSFlow.java:52
# args: 
image\ has\ been\ deleted! = 

# at: src/main/java/org/zstack/aliyun/identityzone/CreateIdentityZoneInDBFlow.java:47
# args: izvo.getZoneId(),izvo.getDataCenterUuid()
izone[%s]\ already\ existed\ in\ datacenter[%s] = 可用区[{0}]数据中心[{1}]中已经存在

# at: src/main/java/org/zstack/aliyun/identityzone/SelectValidIdentityZoneFlow.java:50
# args: 
no\ identity\ chosen,\ may\ be\ stock\ problems = 没有可用区选择，可能是存储问题

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:71
# args: 
the\ operation\ only\ custom\ image = 这个操作只能对用户自己的镜像进行

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:80
# args: 
Only\ system\ disks\ can\ create\ mirrors = 只有系统云盘可以创建快照

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:131
# args: 
can\ not\ delete\ ecs\ system\ image\ remote = 不能删除阿里云服务器上的云主机系统镜像

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:142
# args: 
Only\ support\ ImageStoreBackupStorage = 用本地镜像创建阿里云上的镜像只支持ImageStore镜像存储

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:145
# args: 
image\ name\ cannot\ starts\ with\ http\://\ or\ https\:// = 镜像名称不可以以http://或https://开始

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:158
# args: imageUuid
no\ backup\ storage\ found\ for\ imageUuid\:\ %s = 未找到uuid为{0}的镜像服务器

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:162
# args: imageUuid
exceeded\ backup\ storage\ found\ for\ the\ imageUuid\:\ %s,\ please\ indicate\ it\ manually = 发现多个存在镜像uuid为{0}的镜像服务器，请尝试指定镜像服务器

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:173
# args: platform,EcsImageConstant.ECS_IMAGE_PLATFORM.getValid()
valid\ platform\:[%s]\ for\ aliyun\ image\ import,\ valid\ value\ are\:\ [%s] = 有效的导入阿里云镜像平台: [{0}]，有效值是[{1}]

# at: src/main/java/org/zstack/aliyun/image/EcsImageApiInterceptor.java:178
# args: ivo.getUuid()
image\ [%s]\ is\ not\ enable\ now = 镜像[{0}]不可用

# at: src/main/java/org/zstack/aliyun/image/EcsImageManagerImpl.java:306
# args: msg.getDataCenterUuid()
no\ ossbucket\ attached\ to\ the\ datacenter\:\ %s = 没有oss Bucket添加到数据中心{0}

# at: src/main/java/org/zstack/aliyun/image/EcsImageManagerImpl.java:361
# args: msg.getImageUuid(),msg.getDataCenterUuid()
the\ indicated\ image\ [%s]\ is\ importing\ to\ datacenter\ [%s]\ now... = 指定的镜像[{0}]正在被导入到数据中心[{1}]中...

# at: src/main/java/org/zstack/aliyun/nas/core/AliyunNasApiInterceptor.java:44
# args: psUuids.toString()
PrimaryStorage\ [%s]\ still\ running,\ can\ not\ delete\ access\ group = 

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasBase.java:194
# args: msg.getSourceCidrIp(),msg.getAccessGroupUuid()
access\ group\ rule\ [%s]\ already\ existed\ in\ access\ group\ [%s] = 

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasBase.java:849
# args: msg.getName(),msg.getDataCenterUuid()
access\ group\ [%s]\ already\ existed\ in\ datacenter\ [%s] = 

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasFileSystemBase.java:150
# args: self.getFileSystemId(),regionId
no\ filesystem\ [%s]\ found\ in\ region\:\ %s = 

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasFileSystemBase.java:203
# args: msg.getDataCenterUuid()
nas\ filesystem\ existed\ in\ datacenter\:\ %s = 

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasFileSystemBase.java:304
# args: refs.toString()
some\ primary\ storage\ [%s]\ used\ this\ nas,\ can\ not\ delete\ it\ until\ delete\ the\ primary\ storage. = 

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasMountTargetBase.java:314
# args: cmsg.getWait()
mount\ domain\ not\ valid\ after\ %d\ milliseconds,\ delete\ it... = 

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasMountTargetBase.java:422
# args: 
there\ are\ no\ nas\ access\ group\ existed,\ please\ create\ at\ least\ one = 

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasMountTargetBase.java:404
# args: self.getMountDomain(),self.getNasFileSystemUuid()
no\ such\ mount\ target\ [%s]\ in\ nas\:\ %s = 

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasMountTargetBase.java:472
# args: msg.getMountDomain(),msg.getNasFSUuid()
nas\ mount\ target\ [%s]\ existed\ in\ filesystem\:\ %s = 

# at: src/main/java/org/zstack/aliyun/nas/filesystem/AliyunNasMountTargetBase.java:512
# args: self.getAccessGroupUuid()
the\ access\ group\ attached\ is\ already\:\ %s = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:2927
# args: imageVO.getUuid()
image\ [uuid\:%s]\ has\ been\ deleted = 镜像[uuid:{0}]已经被删除

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:532
# args: vSwitchUuid
EcsVSwitchVO[%s]\ is\ not\ existed,\ may\ be\ it\ has\ been\ deleted! = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:525
# args: accessGroupUuid
AliyunNasAccessGroupVO[%s]\ is\ not\ existed,\ may\ be\ it\ has\ been\ deleted! = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:824
# args: self.getUuid()
cannot\ find\ an\ available\ host\ to\ operation\ in\ primary\ storage\:\ %s = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:903
# args: self.getUuid(),hostUuid,rsp.error
failed\ to\ ping\ aliyun\ nas\ primary\ storage[uuid\:%s]\ from\ host[uuid\:%s],because\ %s.\ disconnect\ this\ host-ps\ connection = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:1391
# args: 
nas\ primary\ storage\ not\ mounted,\ please\ init\ it\ first! = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:1575
# args: bsType
cannot\ find\ any\ BackupStorageKvmFactory\ for\ the\ type[%s] = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:2001
# args: vol.getUuid()
cannot\ find\ host\ to\ operate\ volume\:\ [%s] = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:2238
# args: self.getUuid()
cannot\ find\ and\ host\ to\ sync\ volume\ size\ in\ primary\:\ %s = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:2265
# args: 
image\ [%s]\ has\ been\ deleted,\ cannot\ reinit\ root\ volume\ from\ it = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:2420
# args: 
no\ available\ host\ could\ check\ mountPath! = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:2647
# args: String.join(",", msg.getBackupStorageUuids()),errorCodes.getCauses().get(0).getDetails()
unable\ to\ allocate\ backup\ storage\ specified\ by\ uuids\:\ %s,\ becasue\:\ %s = 不能给uuid列表{0}分配镜像服务器，因为{1}

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmBackend.java:2815
# args: bsvo.getType()
aliyun\ nas\ primarystorage\ only\ support\ imagestore\ bs,\ actually\ get\ type\:\ %s = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmFactory.java:158
# args: context.getInventory().getUuid(),context.getInventory().getName(),mine,e.getKey(),version,QCOW3_QEMU_IMG_VERSION,QCOW3_QEMU_IMG_VERSION
unable\ to\ attach\ a\ primary\ storage\ to\ cluster.\ Kvm\ host[uuid\:%s,\ name\:%s]\ in\ cluster\ has\ qemu-img\ with\ version[%s];\ but\ the\ primary\ storage\ has\ attached\ to\ a\ cluster\ that\ has\ kvm\ host[uuid\:%s],\ which\ has\ qemu-img\ with\ version[%s].\ qemu-img\ version\ greater\ than\ %s\ is\ incompatible\ with\ versions\ less\ than\ %s,\ this\ will\ causes\ volume\ snapshot\ operation\ to\ fail.\ Please\ avoid\ attaching\ a\ primary\ storage\ to\ clusters\ that\ have\ different\ Linux\ distributions,\ in\ order\ to\ prevent\ qemu-img\ version\ mismatch = 不能挂载主存储到集群。集群中的物理机[uuid:{0}, name:{1}]拥有[{2}]版本的qemu-img；但是主存储已经挂载到拥有[{4}]版本qemu-img的集群上。版本大于{5}的qemu-img不兼容版本小于{6}，这将会造成云盘快照操作失败。为了防止qemu-img版本不兼容，请避免挂载主存储到物理机装有不同linux版本的集群

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunKvmFactory.java:342
# args: 
no\ available\ host\ could\ download\ imagecache! = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunNasPrimaryStorageBase.java:1048
# args: msg.getResourceUuid()
resource[uuid\:\ %s]\ cannot\ found = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunNasPrimaryStorageBase.java:69
# args: self.getUuid(),self.getName()
the\ aliyun\ nas\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ any\ available\ host\ in\ attached\ clusters\ for\ instantiating\ the\ volume = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunNasPrimaryStorageBase.java:192
# args: self.getUuid(),self.getName()
the\ aliyun\ nas\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ any\ available\ host\ in\ attached\ clusters\ for\ delete\ bits\ on\ primarystorage = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunNasPrimaryStorageBase.java:555
# args: self.getUuid(),self.getName()
the\ Aliyun\ Nas\ primary\ storage[uuid\:%s,\ name\:%s]\ has\ not\ attached\ to\ any\ clusters,\ or\ no\ hosts\ in\ the\ attached\ clusters\ are\ connected = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunNasPrimaryStorageBase.java:837
# args: hostUuid
failed\ to\ check\ mount\ path\ on\ host\:\ %s = 

# at: src/main/java/org/zstack/aliyun/nas/storage/primary/AliyunNasPrimaryStorageBase.java:924
# args: 
cannot\ find\ a\ host\ to\ cleanup\ image\ cache. = 

# at: src/main/java/org/zstack/aliyun/network/AliyunNetworkServiceBase.java:533
# args: eipVo.getAllocateResourceUuid()
ecs\ instance[%s]\ isn't\ existed,\ please\ check\ it. = 云主机[{0}]不存在，请进行核查

# at: src/main/java/org/zstack/aliyun/network/AliyunNetworkServiceBase.java:537
# args: ecsVo.getUuid(),ecsVo.getEcsStatus()
Only\ ecs\ instances\ that\ are\ in\ the\ running\ and\ stopped\ status\ can\ detach\ the\ eip\ ,\ but\ the\ ecs\ [%s]\ status\ is\ [%s]\ now\  = 只有正在运行或已停止状态的云主机才能绑定弹性IP，但是云主机[{0}]状态为[{1}]

# at: src/main/java/org/zstack/aliyun/network/AliyunNetworkServiceBase.java:2860
# args: msg.getUuid()
virtual\ border\:\ %s\ has\ been\ deleted = 边界路由器: {0}已经被删除

# at: src/main/java/org/zstack/aliyun/network/AliyunNetworkServiceBase.java:3389
# args: tupleCidr,msg.getNextHopUuid()
destination\ cidr\ [%s]\ is\ existed\ and\ point\ to\ another\ instance-id\ [%s],\ please\ check\ or\ delete\ it\ first = 目标CIDR[{0}]已经存在且指向其他云主机[{1}]，请检查或删除它

# at: src/main/java/org/zstack/aliyun/network/AliyunNetworkServiceBase.java:3902
# args: evo.getUuid(),evo.getEcsStatus()
Only\ esc\ instances\ that\ are\ in\ the\ running\ and\ stopped\ status\ can\ attach\ the\ eip\ ,\ but\ the\ ecs\ [%s]\ status\ is\ [%s]\ now\  = 只有正在运行或已停止状态的云主机才能绑定弹性IP，但是云主机[{0}]状态为[{1}]

# at: src/main/java/org/zstack/aliyun/network/connection/AliyunConnectionManagerImpl.java:585
# args: msg.getVbrUuid()
Vbr\:\ [%s]\ is\ in\ create\ connection\ progress,\ please\ wait... = 虚拟边界路由器: [{0}]正在创建连接中，请稍后...

# at: src/main/java/org/zstack/aliyun/network/connection/CreateVbrRouteEntryFlow.java:80
# args: tuple.get(0, String.class),msg.getVbrUuid(),vpcCidr
custom\ cidr\ [%s]\ is\ already\ existed\ in\ vbr\ [%s],\ it\ is\ overlapped\ with\ target\ cidr\ [%s],\ please\ check\ and\ delete\ it\ first. = 自定义CIDR['{0]已经存在于虚拟边界路由器[{1}']，它已经和目标CIDR[{2}]重叠了，请检查然后删除它

# at: src/main/java/org/zstack/aliyun/network/connection/CreateVpcRouteEntryFlow.java:71
# args: tuple.get(0, String.class),vRouterUuid,cidr
custom\ cidr\ [%s]\ is\ already\ existed\ in\ vrouter\ [%s],\ it\ is\ overlapped\ with\ target\ cidr\ [%s],\ please\ check\ and\ delete\ it\ first. = 原始的CIDR[{0}]已经存在于虚拟路由器中[{1}]，已经被目标CIDR所覆盖，请先检验然后删除它

# at: src/main/java/org/zstack/aliyun/network/connection/GetCidrsFlow.java:50
# args: msg.getL3networkUuid()
No\ Such\ Cidr\ found\ for\ l3network\:\ %s = 未找到三层网络{0}对应的CIDR

# at: src/main/java/org/zstack/aliyun/network/connection/GetCidrsFlow.java:40
# args: msg.getL3networkUuid()
No\ Such\ VRouter\ nic\ found\ for\ l3network\:\ %s = 未找到三层网络{0}对应的虚拟路由器网卡

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:43
# args: msg.getUuid()
no\ such\ vpc\ found\ for\:\ %s = 未找到该VPC: {0}

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:48
# args: msg.getUuid()
no\ such\ vm\ found\ for\:\ %s = 没有找到该云主机: {0}

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:53
# args: msg.getUuid()
no\ such\ vbr\ found\ for\:\ %s = 没有找到该虚拟边界路由器: {0}

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:58
# args: msg.getUuid()
no\ such\ l3network\ found\ for\:\ %s = 没有找到该三层网络: {0}

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:62
# args: msg.getResourceType()
not\ a\ supported\ resource\ type\:\ %s = 不支持资源类型: {0}

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:68
# args: 
Only\ admin\ can\ create\ connections = 只有admin才能创建连接

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:72
# args: msg.getCpeIp()
CpeIp\ must\ be\ ipv4\ address,\ but\ now\ is\ %s = CpeIp必须是ipv4地址，但是现在是{0}

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:76
# args: 
cpeIp\ must\ be\ ipv4\ address = cpeIp必须是ipv4地址

# at: src/main/java/org/zstack/aliyun/network/connection/VpcConnectionApiInterceptor.java:82
# args: msg.getL3networkUuid(),msg.getVpcUuid()
l3network\ %s\ and\ vpc\ %s\ already\ connected,\ please\ check\ it = 三层网络{0}和vpc{1}已经连接

# at: src/main/java/org/zstack/aliyun/network/vpn/AliyunVpcVpnBase.java:955
# args: 
vpn\ gateway\ and\ user\ gateway\ are\ not\ in\ the\ same\ dataCenterUuid! = vpn网关和用户网关不是同一个dataCenterUuid

# at: src/main/java/org/zstack/aliyun/oss/EcsOssApiInterceptor.java:33
# args: msg.getBucketName(),msg.getDataCenterUuid()
ossBucket\ [%s]\ is\ already\ added\ in\ dataCenter\ [%s] = oss Bucket['{0]已经被添加数据中心[{1}']

# at: src/main/java/org/zstack/aliyun/oss/EcsOssApiInterceptor.java:41
# args: ovo.getUuid()
OssBucket[%s]\ is\ not\ attached. = oss Bucket[{0}]没有被添加

# at: src/main/java/org/zstack/aliyun/oss/EcsOssManagerImpl.java:114
# args: 
domain,\ key,\ secret\ must\ be\ set\ all = 

# at: src/main/java/org/zstack/aliyun/oss/OssBucketCascadeExtension.java:106
# args: 
oss\ bucket\ is\ not\ empty! = oss Bucket不为空

# at: src/main/java/org/zstack/aliyun/pangu/AliyunPanguApiInterceptor.java:39
# args: appName,partitionName,vo.getIdentityZoneUuid()
appName\:\ %s,\ partitionName\:\ %s\ is\ existed\ in\ identityZone\:\ %s = 

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:62
# args: 
Root\ volume\ cannot\ be\ deleted = 根云盘不能被删除

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:83
# args: 
Cannot\ set\ the\ disk's\ deleteWithInstance\ property\ to\ false\ when\ the\ category\ property\ of\ the\ disk\ is\ cloud\ and\ portable\ property\ is\ false = 当云盘的category属性是cloud且portable为false，不能设置云盘的deleteWithInstance属性为false

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:78
# args: 
Cannot\ set\ the\ disk's\ deleteWithInstance\ property\ to\ false\ when\ the\ category\ property\ of\ the\ disk\ is\ ephemeral = 当云盘的category属性为ephemeral时，不能设置云盘的deleteWithInstance属性为false

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:95
# args: msg.getUuid()
The\ disk\ [%s]\ is\ not\ attach\ on\ any\ instance\  = 该云盘[{0}]没有加载到任何云主机

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:121
# args: msg.getEcsUuid()
The\ state\ of\ the\ ecs\ [%s]\ instance\ must\ be\ running\ or\ stopped = 云主机[{0}]的状态必须是运行或者已停止

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:105
# args: 
Only\ data\ disk\ can\ be\ mounted\ on\ ecs = 只有数据云盘可以挂装到云主机上

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:109
# args: 
The\ disk\ not\ be\ attach\ on\ any\ ecs = 该云盘没有加载到任何云主机

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:143
# args: 
Non-independent\ disk\ can\ only\ be\ destroyed\ with\ instances = 未独立的云盘只能和云主机一起删除

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:126
# args: 
Disk\ and\ ecs\ instances\ must\ be\ in\ the\ same\ zone = 云盘和云主机必须在相同的区域下

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:130
# args: msg.getDiskUuid(),msg.getEcsUuid()
The\ disk\ [%s]\ is\ already\ mounted\ on\ the\ instance\ [%s] = 云盘[{0}]已经安装到云服务器实例[{1}]

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:135
# args: 
Only\ data\ disk\ can\ attach\ to\ ecs = 只有数据云盘能加载到云服务器

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:139
# args: 
Cannot\ attach\ disk\ when\ in\ use = 不能加载正在使用的云盘

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:154
# args: 
The\ size\ and\ snapshot\ id\ in\ the\ request\ parameter\ must\ select\ one\ of\ the\ items\ to\ specify\ the\ size\ of\ the\ disk\ or\ create\ a\ disk\ using\ the\ snapshot. = 在请求参数中size和快照id必须选择一项以便于指定磁盘大小或创建一个快照使用的磁盘

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:167
# args: 
Not\ allowed\ create\ disk\ on\ root\ volume\ snapshot = 不允许在根云盘快照上创建云盘

# at: src/main/java/org/zstack/aliyun/storage/disk/AliyunDiskApiInterceptor.java:176
# args: 
the\ disk\ name\ or\ description\ cannot\ set\ start\ with\ 'http\://'\ or\ 'https\://'\  = 云盘名称和介绍不能以http://或https://开头

# at: src/main/java/org/zstack/aliyun/storage/snapshot/AliyunSnapshotApiInterceptor.java:41
# args: 
The\ operation\ allows\ only\ when\ ecs\ state\ of\ the\ ecs\ instance\ status\ be\ running\ or\ stopped = 当云主机态为运行中或已停止时该操作才被允许

# at: src/main/java/org/zstack/apimediator/ApiValidator.java:60
# args: hostname,newBS
More\ than\ one\ BackupStorage\ on\ the\ same\ host\ identified\ by\ hostname.\ There\ has\ been\ a\ SftpBackupStorage\ [hostname\:%s]\ existing.\ The\ BackupStorage\ type\ to\ be\ added\ is\ %s.\  = 有超过一个镜像服务器拥有相同的主机名，已经存在一个 SFTP 镜像服务器 [主机名:{0}]，被添加的镜像存储类型为 {1}

# at: src/main/java/org/zstack/apimediator/ApiValidator.java:68
# args: hostname,newBS
More\ than\ one\ BackupStorage\ on\ the\ same\ host\ identified\ by\ hostname.\ There\ has\ been\ an\ ImageStoreBackupStorage\ [hostname\:%s]\ existing.\ The\ BackupStorage\ type\ to\ be\ added\ is\ %s.\  = 有超过一个镜像服务器拥有相同的主机名，已经存在一个镜像服务器 [主机名:{0}]，被添加的镜像存储类型为 {1}

# at: src/main/java/org/zstack/appliancevm/ApplianceVmBase.java:129
# args: self.getUuid(),getSelf().getStatus(),msg.getPath()
appliance\ vm[uuid\:%s]\ is\ in\ status\ of\ %s\ that\ cannot\ make\ http\ call\ to\ %s = 系统虚拟机[uuid:{0}]处于{1}状态，无法对[{2}]执行HTTP RPC调用

# at: src/main/java/org/zstack/appliancevm/ApplianceVmBase.java:413
# args: getSelf().getUuid()
appliance\ vm\ %s\ stopped = 

# at: src/main/java/org/zstack/appliancevm/ApplianceVmBase.java:463
# args: getSelf().getUuid()
appliance\ vm\ %s\ destroyed = 

# at: src/main/java/org/zstack/appliancevm/ApplianceVmBase.java:524
# args: getSelf().getUuid()
appliance\ vm\ %s\ reboot = 

# at: src/main/java/org/zstack/appliancevm/ApplianceVmBase.java:534
# args: getSelf().getUuid()
appliance\ vm\ %s\ reboot\ failed = 

# at: src/main/java/org/zstack/appliancevm/ApplianceVmBase.java:586
# args: getSelf().getUuid()
appliance\ vm\ %s\ start\ failed = 

# at: src/main/java/org/zstack/autoscaling/AutoScalingInterceptor.java:75
# args: msg.getAlarmUuid(),ruleVO.getScalingGroupUuid()
alarm[uuid\:%s]\ are\ being\ used\ by\ the\ autoScalingGroup[%s]\ which\ cannot\ be\ deleted = 

# at: src/main/java/org/zstack/autoscaling/AutoScalingManagerImpl.java:583
# args: msg.getTemplateUuid(),JSONObjectUtil.toJsonString(errors)
detach\ autoScalingTemplate[%s]\ from\ AutoScalingGroup\ failed,\ errors\ are\ %s = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:880
# args: 
rootDiskOfferingUuid\ cannot\ be\ null\ when\ image\ mediaType\ is\ ISO = 根云盘规格不能为空在镜像类型为ISO时

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:860
# args: instanceOfferingVO.getUuid()
instance\ offering[uuid\:%s]\ is\ Disabled,\ can't\ create\ vm\ from\ it = 计算规格[uuid:{0}]没有被启用，不能根据该规格创建云主机

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:863
# args: instanceOfferingVO.getUuid(),instanceOfferingVO.getType()
instance\ offering[uuid\:%s,\ type\:%s]\ is\ not\ UserVm\ type,\ can't\ create\ vm\ from\ it = 计算规格[uuid:{0}, type:{1}]不是UserVm类型，不能通过它创建虚拟机

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:871
# args: imageVO.getUuid()
image[uuid\:%s]\ is\ Disabled,\ can't\ create\ vm\ from\ it = 镜像[uuid:{0}]没被启用，不能根据该镜像创建云主机

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:874
# args: imageVO.getUuid()
image[uuid\:%s]\ is\ not\ ready\ yet,\ can't\ create\ vm\ from\ it = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:877
# args: imageVO.getUuid(),imageVO.getMediaType()
image[uuid\:%s]\ is\ of\ mediaType\:\ %s,\ only\ RootVolumeTemplate\ and\ ISO\ can\ be\ used\ to\ create\ vm = 镜像[uuid:{0}] 类型为{1}，该镜像只能用来创建根云盘或者用来创建云主机

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:884
# args: imageVO.getUuid()
image[uuid\:%s]\ is\ system\ image,\ can't\ be\ used\ to\ create\ user\ vm = 镜像[uuid:{0}] 是系统镜像，不能使用它创建用户虚拟机

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:896
# args: diskOfferingVO.getUuid()
disk\ offerings[uuids\:%s]\ are\ Disabled,\ can\ not\ create\ vm\ from\ it = 云盘规格[uuids:{0}]没有被启用，不能使用它创建云主机

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:356
# args: 
Only\ one\ scaling\ activity\ can\ be\ executed\ in\ the\ same\ scaling\ group\ at\ the\ same\ time. = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:1252
# args: 
The\ number\ of\ instances\ exceeds\ the\ limit = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:584
# args: msg.getAutoScalingGroupUuid(),JSONObjectUtil.toJsonString(errors)
autoScalingGroup[%s]\ create\ vms\ failed\ completely,\ errors\ are\ %s = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:632
# args: loadBalancerListenerUuidListStr
add\ vm\ nic\ to\ loadBalancer\ failed,\ No\ loadBalancer[uuids\=%s]\ can\ be\ found. = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:671
# args: msg.getAutoScalingGroupUuid(),JSONObjectUtil.toJsonString(addVmNicToLoadBalancerErrorCodes)
autoScalingGroup[%s]\ add\ newly\ created\ vm\ to\ loadBalancer\ failed\ completely,\ errors\ are\ %s = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:706
# args: securityGroupUuid
add\ vm\ nic\ to\ securityGroup\ failed,\ No\ securityGroup[uuid\=%s]\ can\ be\ found. = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:742
# args: msg.getAutoScalingGroupUuid(),JSONObjectUtil.toJsonString(addVmNicToSecurityGroupErrorCodes)
autoScalingGroup[%s]\ add\ newly\ created\ vm\ to\ securityGroup\ failed\ completely,\ errors\ are\ %s = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:852
# args: templateGroupRefVO.getTemplateUuid()
A\ resource\ can\ not\ be\ found,\ details\:\ resource[uuid\:%s,\ type\:AutoScalingVmTemplateVO]\ not\ found = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:857
# args: vmTemplateVO.getVmInstanceOfferingUuid()
A\ resource\ can\ not\ be\ found,\ details\:\ resource[uuid\:%s,\ type\:InstanceOfferingVO]\ not\ found = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:868
# args: vmTemplateVO.getImageUuid()
A\ resource\ can\ not\ be\ found,\ details\:\ resource[uuid\:%s,\ type\:ImageVO]\ not\ found = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:892
# args: diskOfferingVO.getUuid()
A\ resource\ can\ not\ be\ found,\ details\:\ resource[uuid\:%s,\ type\:DiskOfferingVO]\ not\ found = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:905
# args: l3Uuid
A\ resource\ can\ not\ be\ found,\ details\:\ resource[uuid\:%s,\ type\:L3NetworkVO]\ not\ found = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:921
# args: vmTemplateVO.getDefaultL3NetworkUuid(),l3Uuids
defaultL3NetworkUuid[uuid\:%s]\ is\ not\ in\ l3NetworkUuids\ %s = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:994
# args: self.getUuid(),AutoScalingGroupState.Enabled.toString()
the\ auto\ scaling\ group[%s]\ state\ error,\ expected\:\ %s\ state = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:1006
# args: self.getUuid()
The\ autoScalingGroup[%s]\ not\ attach\ any\ vm\ template = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:1060
# args: self.getUuid(),vmInstanceUuids,JSONObjectUtil.toJsonString(errors)
autoScalingGroup[%s]\ destroy\ vms[%s]\ failed\ completely,\ errors\ are\ %s = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:1265
# args: 
Cannot\ find\ deleted\ target\ instance\ list = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:1734
# args: ruleUuid,JSONObjectUtil.toJsonString(errors)
delete\ autoScalingRule[%s]\ triggers\ failed,\ errors\ are\ %s = 

# at: src/main/java/org/zstack/autoscaling/group/AutoScalingGroupBase.java:2356
# args: removalPolicy.toString()
Unsupported\ RemovalPolicy[%s]\ type = 

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisApiInterceptor.java:63
# args: address
IPMI\ Address\ %s\ is\ not\ valid = IPMI地址{0}是无效的

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisApiInterceptor.java:69
# args: 
Please\ check\ the\ IPMI\ connection\ and\ make\ sure\ the\ IPMI\ Address,\ Port,\ Username\ and\ Password\ of\ remote\ server\ are\ correct. = 请检查IPMI连接，并确认IPMI地址、端口、账号、密码是否正确

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisApiInterceptor.java:84
# args: address,port
Baremetal\ Chassis\ of\ IPMI\ address\ %s\ and\ IPMI\ port\ %d\ has\ already\ been\ created. = IPMI地址为{0}，端口为{1}的裸金属设备已经被创建

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisApiInterceptor.java:95
# args: msg.getClusterUuid()
Cluster[uuid\:%s]\ does\ not\ exists. = 集群[uuid:{0}]不存在

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisApiInterceptor.java:102
# args: msg.getClusterUuid()
Cluster[uuid\:%s]\ is\ not\ a\ baremetal\ cluster. = 集群[uuid:{0}]不是一个裸金属集群

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisApiInterceptor.java:108
# args: msg.getClusterUuid()
Cluster[uuid\:%s]\ is\ not\ Enabled. = 集群[uuid:{0}]处于停用状态

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisApiInterceptor.java:146
# args: address,port
IPMI\ Address\ and\ Port\ %s\:%d\ already\ exists. = IPMI地址为{0}，端口为{1}的裸金属设备已经存在

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisApiInterceptor.java:211
# args: clusterUuid
no\ usable\ baremetal\ pxeserver\ attached\ to\ cluster[uuid\:%s] = 裸金属集群[uuid:{0}]中没有可用的部署服务器

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisManagerImpl.java:152
# args: chassis.getUuid(),chassis.getPxeServerUuid(),cmd.content
baremetal\ chassis[uuid\:%s]\ is\ supposed\ to\ using\ pxeserver[uuid\:%s],\ but\ it\ was\ pxeserver[uuid\:%s]\ that\ actually\ handled\ the\ DHCP\ request = 裸金属设备[uuid:{0}]应当由部署服务器[uuid:{1}]提供DHCP服务，但实际情况是部署服务器[uuid:{2}]提供的DHCP服务

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisManagerImpl.java:638
# args: msg.getUuid()
failed\ to\ delete\ baremetal\ chassis\ %s = 

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisManagerImpl.java:705
# args: bmc.getUuid()
Failed\ to\ remotely\ power\ on\ baremetal\ chassis[uuid\:%s] = 无法远程启动裸金属设备[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisManagerImpl.java:721
# args: bmc.getUuid()
Failed\ to\ remotely\ power\ reset\ baremetal\ chassis[uuid\:%s] = 无法远程重启裸金属设备[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisManagerImpl.java:732
# args: bmc.getUuid()
Failed\ to\ remotely\ pxe\ boot\ chassis[uuid\:%s] = 无法远程设置裸金属设备[uuid:{0}]从网卡启动

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisManagerImpl.java:900
# args: bmc.getUuid()
failed\ to\ connect\ to\ chassis\ [uuid\:%s],\ please\ check\ ipmi\ connection. = 无法连接到裸金属设备[uuid:{0}], 请确认IPMI连接可用

# at: src/main/java/org/zstack/baremetal/chassis/BaremetalChassisManagerImpl.java:981
# args: e.getMessage()
fail\ to\ load\ chassis\ info\ from\ file,\ because\:\ %s = 无法从文件中读取裸金属设备信息，因为：{0}

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:66
# args: msg.getChassisUuid()
Baremetal\ chassis[uuid\:%s]\ does\ not\ exist = 

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:72
# args: chassis.getUuid()
Baremetal\ chassis[uuid\:%s]\ is\ not\ Enabled\ or\ Available,\ please\ choose\ another\ one. = 裸金属设备[uuid:{0}]被停用或者已被分配，请重新选择

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:78
# args: chassis.getUuid()
no\ corresponding\ pxeserver,\ please\ inspect\ baremetal\ chassis[uuid\:%s]\ again = 裸金属设备[uuid:{0}]没有关联部署服务器，请重新获取硬件信息

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:91
# args: chassis.getUuid()
No\ hardware\ info\ found\ for\ baremetal\ chassis[uuid\:%s],\ please\ choose\ another\ one. = 裸金属设备[uuid:{0}]硬件信息未知，请重新选择

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:102
# args: chassis.getPxeServerUuid()
baremetal\ pxeserver[uuid\:%s]\ is\ neither\ Enabled\ nor\ Connected,\ please\ check = 

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:119
# args: mac
Mac\ address\ %s\ is\ invalid.\ It\ should\ be\ like\ 6c\:b3\:11\:1b\:0b\:1e = MAC地址{0}不合法

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:125
# args: chassis.getUuid(),mac
Baremetal\ chassis[uuid\:%s]\ doesn't\ have\ nic\ with\ mac\ address\ %s = 裸金属设备[uuid:{0}]硬件信息中未发现MAC地址为{1}的网卡

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:143
# args: 
duplicated\ bm\ bonding\ uuid\ detacted = 

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:147
# args: 
Baremetal\ Bonding\ does\ not\ exist = 

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:155
# args: 
duplicated\ l3\ network\ uuid\ detacted = 

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:159
# args: 
the\ selected\ l3\ network\ doesn't\ exist = 

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:172
# args: chassis.getUuid()
the\ selected\ l3\ network\ cannot\ be\ assigned\ to\ chassis[uuid\:%s] = 

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:184
# args: 
only\ iso\ image\ is\ supported\ in\ zstack\ baremetal\ service = 目前仅支持为裸机部署ISO镜像

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:193
# args: 
only\ ImageStoreBackupStorage\ is\ supported\ in\ zstack\ baremetal\ service = 目前仅支持从镜像仓库中为裸机选择ISO镜像

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:207
# args: 
cannot\ recover\ baremetal\ instance\ that's\ not\ in\ Destroyed\ state = 只能恢复处于Destroyed状态的裸金属主机

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceApiInterceptor.java:219
# args: 
cannot\ expunge\ baremetal\ instance\ that's\ not\ in\ Destroyed\ state = 只能彻底删除处于Destroyed状态的裸金属主机

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceBase.java:461
# args: bmc.getUuid()
Failed\ to\ remotely\ power\ off\ baremetal\ chassis[uuid\:%s] = 无法远程关闭裸金属设备[uuid:{0}]

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceBase.java:266
# args: self.getClusterUuid()
failed\ to\ allocate\ baremetal\ pxeserver,\ make\ sure\ there\ is\ a\ pxeserver\ with\ enough\ available\ capacity\ attached\ on\ cluster[uuid\:%s] = 分配部署服务器失败，请确认裸金属集群[uuid:{0}]中所挂载的部署服务器拥有足够的剩余存储空间用于保存镜像缓存

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceBase.java:453
# args: reboot ? "reset" : "on",bmc.getUuid()
Failed\ to\ remotely\ power\ %s\ baremetal\ chassis[uuid\:%s] = 

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceManagerImpl.java:1169
# args: msg.getL2NetworkUuid()
there\ are\ bm\ instances\ using\ ip\ address\ allocated\ from\ l2[uuid\:%s] = 

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceManagerImpl.java:1177
# args: msg.getL3NetworkUuid()
there\ are\ bm\ instances\ using\ ip\ address\ allocated\ from\ l3[uuid\:%s] = 

# at: src/main/java/org/zstack/baremetal/instance/BaremetalInstanceManagerImpl.java:1197
# args: msg.getIpRangeUuid()
there\ are\ bm\ instances\ using\ ip\ address\ allocated\ from\ ip\ range[uuid\:%s] = 

# at: src/main/java/org/zstack/baremetal/network/BaremetalNetworkApiInterceptor.java:39
# args: 
creating\ bm\ bonding\ is\ only\ allowed\ before\ creating\ bm\ instance = 

# at: src/main/java/org/zstack/baremetal/network/BaremetalNetworkApiInterceptor.java:48
# args: msg.getName()
bond\ name\ %s\ already\ exists = 

# at: src/main/java/org/zstack/baremetal/network/BaremetalNetworkApiInterceptor.java:73
# args: slave
Slave\ address\ %s\ is\ invalid.\ It\ should\ be\ like\ 6c\:b3\:11\:1b\:0b\:1e,6c\:b3\:11\:1b\:0b\:1f = 

# at: src/main/java/org/zstack/baremetal/network/BaremetalNetworkApiInterceptor.java:79
# args: slave,msg.getChassisUuid()
mac\ address\ %s\ does\ not\ belong\ to\ chassis[uuid\:%s] = 

# at: src/main/java/org/zstack/baremetal/network/BaremetalNetworkApiInterceptor.java:85
# args: slave
mac\ address\ %s\ is\ already\ a\ bond\ slave = 

# at: src/main/java/org/zstack/baremetal/preconfiguration/PreconfigurationApiInterceptor.java:43
# args: 
cannot\ update\ predefined\ preconfiguration\ templates = 

# at: src/main/java/org/zstack/baremetal/preconfiguration/PreconfigurationApiInterceptor.java:55
# args: 
cannot\ delete\ predefined\ preconfiguration\ templates = 

# at: src/main/java/org/zstack/baremetal/preconfiguration/PreconfigurationApiInterceptor.java:63
# args: 
cannot\ change\ state\ of\ predefined\ preconfiguration\ templates = 

# at: src/main/java/org/zstack/baremetal/preconfiguration/PreconfigurationManagerImpl.java:62
# args: msg.getTemplateUuid()
cannot\ find\ PreconfigurationTemplateVO[uuid\:%s],\ it\ may\ have\ been\ deleted = 

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:74
# args: netmask
PXE\ Server\ DHCP\ Range\ Netmask\ %s\ is\ invalid. = 部署服务器DHCP服务子网掩码{0}非法

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:80
# args: begin,end
PXE\ Server\ DHCP\ Range\ Start\ %s\ and\ Range\ Stop\ %s\ do\ not\ belong\ to\ the\ same\ subnet. = 部署服务器DHCP地址区间起始IP{0}和结束IP{1}不属于一个子网内

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:88
# args: msg.getHostname()
PXE\ Server\ with\ hostname\ %s\ already\ exists. = 地址为{0}的部署服务器已经存在

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:95
# args: 
storagePath\ should\ be\ an\ absolute\ path = 部署服务器的存储路径必须是绝对路径

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:113
# args: msg.getHostname()
failed\ to\ connect\ to\ %s,\ please\ check\ network\ connection\ between\ zstack\ management\ node\ and\ baremetal\ pxeserver = 请检查管理节点与部署服务器{0}之间的网络连接

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:127
# args: msg.getHostname()
no\ local\ repo\ found\ under\ /opt/zstack-dvd\ of\ %s,\ please\ download\ zstack\ iso\ and\ create\ local\ repo\ first = 部署服务器{0}中缺少使用ZStack ISO创建的本地源

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:141
# args: msg.getDhcpInterface()
PXE\ Server\ DHCP\ Interface\ %s\ does\ not\ exists,\ or\ it\ does\ not\ have\ an\ IP\ address. = 部署服务器DHCP接口{0}不存在，或者它没有IP地址

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:150
# args: msg.getDhcpRangeBegin(),msg.getDhcpRangeEnd(),msg.getDhcpInterface()
%s\ ~\ %s\ cannot\ connect\ to\ dhcp\ interface\ %s = {0} ~ {1} 无法连通DHCP监听网卡{2}

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:187
# args: msg.getClusterUuid(),msg.getPxeServerUuid()
cluster[uuid\:%s]\ and\ pxeserver[uuid\:%s]\ don't\ belong\ to\ one\ zone = 裸金属集群[uuid:{0}]和部署服务器[uuid:{1}]不属于同一个区域

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:196
# args: msg.getClusterUuid()
cluster[uuid\:%s]\ is\ not\ baremetal\ cluster = 集群[uuid:{0}]不是一个裸金属集群

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:207
# args: msg.getPxeServerUuid(),msg.getClusterUuid()
baremetal\ pxeserver[uuid\:%s]\ already\ attached\ to\ cluster[uuid\:%s] = 部署服务器[uuid:{0}]已经挂载到裸金属集群[uuid:{1}]，无需再次挂载

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:233
# args: msg.getPxeServerUuid(),msg.getClusterUuid(),ip,begin,end
baremetal\ pxeserver[uuid\:%s]\ is\ not\ compatible\ with\ baremetal\ instances\ in\ cluster[uuid\:%s],\ existing\ nic\ ip\ %s\ is\ out\ of\ pxeserver\ dhcp\ range\ %s\ ~\ %s. = 部署服务器[uuid:{0}]不适合于集群[uuid:{1}]，因为集群中已有的裸金属主机网卡地址{2}超出了部署服务器的DHCP范围{3} ~ {4}

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerApiInterceptor.java:250
# args: msg.getPxeServerUuid(),msg.getClusterUuid()
baremetal\ pxeserver[uuid\:\ %s]\ not\ attached\ to\ cluster[uuid\:\ %s] = 部署服务器[uuid:{0}]没有挂载到裸金属集群[uuid:{1}]

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:286
# args: self.getUuid()
failed\ to\ init\ configs\ on\ baremetal\ pxeserver[uuid\:%s] = 部署服务器[uuid:{0}]初始化配置失败

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:423
# args: self.getUuid()
failed\ to\ create\ bm\ instance\ configs\ on\ baremetal\ pxeserver[uuid\:%s] = 在部署服务器[uuid:{0}]上创建裸金属主机相关配置失败

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:454
# args: self.getUuid()
failed\ to\ delete\ bm\ instance\ configs\ on\ baremetal\ pxeserver[uuid\:%s] = 在部署服务器[uuid:{0}]上删除裸金属主机相关配置失败

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:485
# args: self.getUuid()
failed\ to\ create\ bm\ instance\ novnc\ proxy\ on\ baremetal\ pxeserver[uuid\:%s] = 在部署服务器[uuid:{0}]上创建裸金属主机NoVNC代理失败

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:516
# args: self.getUuid()
failed\ to\ delete\ bm\ instance\ novnc\ proxy\ on\ baremetal\ pxeserver[uuid\:%s] = 在部署服务器[uuid:{0}]上删除裸金属主机NoVNC代理失败

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:548
# args: self.getUuid()
failed\ to\ create\ bm\ instance\ nginx\ proxy\ on\ baremetal\ pxeserver[uuid\:%s] = 在部署服务器[uuid:{0}]上创建裸金属主机Nginx代理失败

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:579
# args: self.getUuid()
failed\ to\ delete\ bm\ instance\ nginx\ proxy\ on\ baremetal\ pxeserver[uuid\:%s] = 在部署服务器[uuid:{0}]上删除裸金属主机Nginx代理失败

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:610
# args: self.getUuid()
failed\ to\ start\ baremetal\ pxeserver[uuid\:%s] = 启动部署服务器[uuid:{0}]失败

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:643
# args: self.getUuid()
failed\ to\ stop\ baremetal\ pxeserver[uuid\:%s] = 停止部署服务器[uuid:{0}]失败

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:958
# args: msg.getChassisUuid(),self.getUuid()
failed\ to\ create\ dhcp\ config\ of\ chassis[uuid\:%s]\ on\ pxeserver[uuid\:%s] = 

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:987
# args: msg.getChassisUuid(),self.getUuid()
failed\ to\ delete\ dhcp\ config\ of\ chassis[uuid\:%s]\ on\ pxeserver[uuid\:%s] = 

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:1045
# args: self.getUuid(),ret.uuid
the\ uuid\ of\ baremtal\ pxeserver\ agent\ changed[expected\:%s,\ actual\:%s],\ it's\ most\ likely\ the\ agent\ was\ manually\ restarted.\ Issue\ a\ reconnect\ to\ sync\ the\ status = 

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:1211
# args: url,rsp.error
unable\ to\ connect\ to\ baremetal\ pxeserver[url\:%s],\ because\ %s = 连接部署服务器[uuid:{0}]失败，因为: {1}

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:1295
# args: cache.getImageUuid()
failed\ to\ mount\ baremetal\ cache\ of\ image[uuid\:%s] = 挂载裸金属镜像缓存[uuid:{0}]失败

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:1405
# args: msg.getImageUuid()
no\ enough\ space\ left\ in\ baremetal\ image\ cache\ for\ image[uuid\:%s] = 部署服务器存储路径剩余空间不足

# at: src/main/java/org/zstack/baremetal/pxeserver/BaremetalPxeServerBase.java:1501
# args: 
unsupported\ backup\ storage\ type\ for\ baremetal = 裸金属管理所不支持的镜像存储类型

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:88
# args: 
the\ start\ date\ must\ be\ greater\ than\ the\ end\ date = 开始时间必须早于结束时间

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:92
# args: 
resourceType\ and\ resourceUuid\ cannot\ be\ empty\ at\ the\ same\ time = 

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:149
# args: 
the\ minimal\ resource\ unit\ is\ megabyte,\ cannot\ be\ byte = 资源的最小单位必须为MB，而不是byte

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:157
# args: 
price\ must\ be\ 0\ and\ 9999.99 = 价格必须在0和9999.99之间

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:164
# args: 
gpu\ price\ must\ be\ bound\ to\ gpu\ uuid\ empty = GPU类型的价格必须绑定一个GPU设备

# at: src/main/java/org/zstack/billing/BillingApiInterceptor.java:171
# args: msg.getSystemTags()
gpu\ price\ must\ be\ bound\ to\ gpu\ uuid\ %s = GPU类型的价格必须绑定一个正确的GPU设备{0}

# at: src/main/java/org/zstack/billing/BillingManagerImpl.java:207
# args: 
priceKeyName\ is\ null = 

# at: src/main/java/org/zstack/billing/BillingManagerImpl.java:626
# args: resourceUuid
Already\ have\ one\ userdata\ systemTag\ for\ instanceOffering[uuid\:\ %s]. = 

# at: src/main/java/org/zstack/billing/BillingManagerImpl.java:691
# args: 
Shouldn't\ be\ more\ than\ one\ systemTag\ for\ one\ instanceOffering. = 

# at: src/main/java/org/zstack/billing/BillingManagerImpl.java:668
# args: resourceUuid
Already\ have\ one\ userdata\ systemTag\ for\ diskOffering[uuid\:\ %s]. = 

# at: src/main/java/org/zstack/billing/ResourceSpendingHelper.java:50
# args: resourceType
unsupported\ billing\ resource\ type\ [%s] = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationInterceptor.java:63
# args: msg.getUuid()
cannot\ find\ such\ ResourceStackVO\ by\ uuid\ [%s] = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationInterceptor.java:67
# args: validStatus
restart\ resource\ stack\ only\ support\ %s\ status! = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationInterceptor.java:175
# args: 
templateContent\ and\ uuid\ mustn't\ both\ be\ empty\ or\ both\ be\ set! = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationInterceptor.java:98
# args: validStatus
expect\ %s\ status! = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationInterceptor.java:118
# args: 
templateContent\ and\ templateUuid\ mustn't\ both\ be\ empty! = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationInterceptor.java:129
# args: 
templateContent\ and\ url\ mustn't\ both\ be\ empty\ or\ both\ be\ set! = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationInterceptor.java:145
# args: 
only\ admin\ could\ enable/disable\ system\ StackTemplate = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:854
# args: vo.getName()
cannot\ delete\ or\ update\ system\ template\:\ %s = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:385
# args: msg.getUuid()
ResourceStackVO\:\ [%s]\ has\ been\ deleted... = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:415
# args: uuid
ResourceStackVO\ [%s]\ already\ been\ deleted! = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:641
# args: 
templateContent\ must\ be\ set! = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:636
# args: template.getUuid()
template\ [%s]\ chosen\ is\ disabled = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:779
# args: p.getParamName(),p.getResourceType()
cannot\ find\ parameters\ for\ %s,\ which\ is\ %s\ type,\ please\ check\ parameters = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:847
# args: 
StackTemplateVO\ has\ been\ deleted... = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:870
# args: 
content\ must\ be\ set\ by\ templateContent\ or\ url! = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:888
# args: 
get\ null\ content\ input = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:895
# args: result.getTemplateVersion()
invalid\ cloudformation\ template\ version\:\ %s = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationManagerImpl.java:909
# args: msg.getUuid()
StackTemplateVO\:\ [%s]\ has\ been\ deleted... = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationUtils.java:20
# args: 
get\ null\ element\ in\ template\ content = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationUtils.java:24
# args: 
template\ must\ contain\ [ZStackTemplateFormatVersion] = 

# at: src/main/java/org/zstack/cloudformation/CloudFormationUtils.java:27
# args: result.getTemplateVersion(),CloudFormationConstant.version
invalid\ ZStackTemplateFormatVersion\:\ %s,\ %s = 

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationCreator.java:156
# args: 
verb\ must\ contain\ '\:\:'! = 

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationCreator.java:197
# args: t[0],last.getClass().getName()
need\ List\ for\ resource\ [%s]\ output\ here,\ but\ got\ %s. = 

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationCreator.java:221
# args: value
invalid\ dynamic\ variables,\ which\ must\ contained\ ${\:\ %s = 

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationCreator.java:283
# args: 
cannot\ find\ resource\ of\ properties\ set\ before! = 

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationCreator.java:359
# args: 
Some\ actions\ are\ invalid = 

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationDecoder.java:124
# args: e
Unable\ to\ create\ json\ template = 

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationDecoder.java:112
# args: jsonFile
cannot\ find\ such\ template\ file\:\ %s = 

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationDecoder.java:227
# args: 
no\ root\ element\ found,\ please\ check\ your\ cfn\ formation! = 

# at: src/main/java/org/zstack/cloudformation/template/CloudFormationDecoder.java:346
# args: e.getMessage()
Wrong\ json\ format,\ causes\:\ %s = 

# at: src/main/java/org/zstack/cloudformation/template/decoder/DecoderUtils.java:87
# args: msg
cannot\ find\ such\ msg\:\ %s\ for\ create = 

# at: src/main/java/org/zstack/cloudformation/template/decoder/MappingDecoder.java:56
# args: 
Mapping\ value\ body\ cannot\ support\ null! = 

# at: src/main/java/org/zstack/cloudformation/template/decoder/MappingDecoder.java:54
# args: 
Mapping\ value\ body\ cannot\ support\ json\ array! = 

# at: src/main/java/org/zstack/cloudformation/template/decoder/MappingDecoder.java:66
# args: 
mappingName\ must\ be\ found\ in\ result,\ or\ it\ is\ invalid\ cfn\ json. = 

# at: src/main/java/org/zstack/cloudformation/template/decoder/OutputDecoder.java:83
# args: 
Mapping\ body\ cannot\ support\ json\ null! = 

# at: src/main/java/org/zstack/cloudformation/template/decoder/OutputDecoder.java:81
# args: 
Mapping\ body\ cannot\ support\ non\ map\ value! = 

# at: src/main/java/org/zstack/cloudformation/template/decoder/OutputDecoder.java:70
# args: 
Description\ in\ Outputs\ must\ be\ String\ type! = 

# at: src/main/java/org/zstack/cloudformation/template/decoder/ParameterDecoder.java:59
# args: 
paramName\ must\ be\ found\ in\ result,\ or\ it\ is\ invalid\ cfn\ json. = 

# at: src/main/java/org/zstack/cloudformation/template/decoder/ParameterDecoder.java:129
# args: 
Parameters\ root\ body\ must\ be\ json\ object! = 

# at: src/main/java/org/zstack/cloudformation/template/decoder/ResourceDecoder.java:145
# args: 
Mappings\ root\ body\ must\ be\ json\ object! = 

# at: src/main/java/org/zstack/cloudformation/template/decoder/ResourceDecoder.java:112
# args: 
resourceName\ must\ be\ found\ in\ result,\ or\ it\ is\ invalid\ cfn\ json. = 

# at: src/main/java/org/zstack/cloudformation/template/decoder/ResourceDecoder.java:123
# args: 
Parameters\ body\ cannot\ support\ null! = 

# at: src/main/java/org/zstack/cloudformation/template/decoder/ResourceDecoder.java:68
# args: 
Resource\ value\ body\ cannot\ support\ null! = 

# at: src/main/java/org/zstack/cloudformation/template/decoder/ResourceDecoder.java:48
# args: resource.getResourceName(),e.getKey(),resource.getResourceName()
Resource\ %s\ cannot\ depends\ on\ itself,\ please\ check\ %s\ in\ Resource\ [%s] = 

# at: src/main/java/org/zstack/cloudformation/template/decoder/ResourceDecoder.java:254
# args: 
Resource\ root\ body\ must\ be\ json\ object! = 

# at: src/main/java/org/zstack/cloudformation/template/decoder/ResourceDecoder.java:216
# args: 
Resource\ Type\ must\ be\ String! = 

# at: src/main/java/org/zstack/cloudformation/template/function/SelectTemplateFunction.java:83
# args: 
Fn\:\:Select\ out\ of\ range,\ please\ check\ your\ json\ file! = 

# at: src/main/java/org/zstack/cloudformation/template/function/TemplateFunctionUtils.java:71
# args: e.getKey()
only\ functions\ can\ in\ Function,\ but\ found\ %s = 

# at: src/main/java/org/zstack/cloudformation/template/function/TemplateFunctionUtils.java:86
# args: 
element\ is\ null! = 

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupBase.java:324
# args: resourceUuid,affinityGroupUuid
VM\ [uuid\:\ %s]\ has\ already\ been\ added\ to\ affinityGroup\ [uuid\:\ %s] = VM[uuid:{0}已经被添加到亲和组[uuid:{1}]中。]

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupBase.java:341
# args: hostUuid,affinityGroupUuid
There\ are\ other\ VMs\ on\ this\ host\ [uuid\:\ %s]\ belonging\ to\ same\ affinityGroup\ [%s] = 在物理机[uuid:{0}]上的虚拟机属于同一个亲和组中[{1}]

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupBase.java:370
# args: self.getUuid(),host.getUuid(),vmUuid
affinityGroup\ [uuid\:%s]\ reserve\ host\ [uuid\:%s]\ for\ vm\ [uuid\:\ %s]\ failed = 亲和组[uuid:{0}]为虚拟机[uuid:{2}]预分配物理机资源[uuid:{1}]失败

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupBase.java:440
# args: inv.getResourceUuid(),self.getUuid()
vm\ [uuid\:%s]\ doesn't\ satisfy\ the\ affinityGroup\ [uuid\:%s] = 虚拟机[uuid:{1}]不满足亲和组[uuid:{2}]的要求

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupFilterFlow.java:136
# args: 
can\ not\ satisfied\ affinity\ group\ conditions = 不能满足亲和组的条件

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupInterceptor.java:42
# args: VmInstanceState.Running.toString(),VmInstanceState.Stopped.toString(),state.toString()
Vm\ can\ change\ its\ affinityGroup\ only\ in\ state\ [%s,%s],\ but\ vm\ is\ in\ state\ [%s] = 只有状态为[{0},{1}]的虚拟机可以改变亲和组，但是现在虚拟机的状态为[{2}]

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupInterceptor.java:52
# args: msg.getUuid(),agUuid
Vm\ [uuid\:\ %s]\ is\ already\ added\ to\ affinityGroup\ [uuid\:\ %s] = 云主机[uuid:{0}]已经被添加至亲和组[uuid:{1}]中

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupInterceptor.java:77
# args: affinityGroupUuid
AffinityGroup\ [uuid\:\ %s]\ does\ not\ existed = 亲和组[uuid:{0}]不存在

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupInterceptor.java:81
# args: 
Can\ not\ operate\ on\ affinity\ group\ created\ by\ system = 不能对系统创建的亲和组进行操作

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupInterceptor.java:88
# args: affinityGroupUuid
Can\ not\ operate\ on\ affinityGroup\ [uuid\:\ %s]\ which\ is\ not\ enabled = 不能对不是enabled状态的亲和组操作

# at: src/main/java/org/zstack/compute/affinityGroup/AffinityGroupManagerImpl.java:100
# args: msg.getAffinityGroupUuid()
cannot\ find\ the\ affinity\ group[uuid\:%s],\ it\ may\ have\ been\ deleted = 未找到亲和组[uuid:{0}]，它可能已经被删除

# at: src/main/java/org/zstack/compute/allocator/AttachedL2NetworkAllocatorFlow.java:103
# args: spec.getL3NetworkUuids()
no\ host\ found\ in\ clusters\ that\ has\ attached\ to\ L2Networks\ which\ have\ L3Networks%s = 

# at: src/main/java/org/zstack/compute/allocator/AttachedPrimaryStorageAllocatorFlow.java:79
# args: psuuids
no\ host\ found\ in\ clusters\ that\ have\ attached\ to\ primary\ storage\ %s = 

# at: src/main/java/org/zstack/compute/allocator/AttachedVolumePrimaryStorageAllocatorFlow.java:79
# args: requiredPsUuids,vm.getUuid()
no\ host\ found\ in\ clusters\ which\ have\ attached\ to\ all\ primary\ storage\ %s\ where\ vm[uuid\:%s]'s\ volumes\ locate = 

# at: src/main/java/org/zstack/compute/allocator/AvoidHostAllocatorFlow.java:30
# args: spec.getAvoidHostUuids()
after\ rule\ out\ avoided\ host%s,\ there\ is\ no\ host\ left\ in\ candidates = 

# at: src/main/java/org/zstack/compute/allocator/BackupStorageSelectPrimaryStorageAllocatorFlow.java:87
# args: spec.getRequiredBackupStorageUuid(),bsType
the\ backup\ storage[uuid\:%s,\ type\:%s]\ requires\ bound\ primary\ storage,\ however,\ the\ primary\ storage\ has\ not\ been\ added = 无法找到跟镜像服务器[uuid:{0}, type:{1}]配对的主存储。一些镜像服务器必须跟配对的主存储共同使用，例如Ceph镜像服务器只能搭配Ceph主存储使用。请检查你主存储的设置

# at: src/main/java/org/zstack/compute/allocator/BackupStorageSelectPrimaryStorageAllocatorFlow.java:80
# args: spec.getImage().getUuid(),spec.getRequiredBackupStorageUuid(),type,psUuids
The\ image[uuid\:%s]\ is\ on\ the\ backup\ storage[uuid\:%s,\ type\:%s]\ that\ requires\ to\ work\ with\ primary\ storage[uuids\:%s],however,\ no\ host\ found\ suitable\ to\ work\ with\ those\ primary\ storage = 镜像[uuid:{0}]所在的镜像服务器[uuid:{1}, type:{2}]必须跟主存储[uuid:{3}]配对使用，但无法找到可以跟满足条件并可以访问该主存储的物理机

# at: src/main/java/org/zstack/compute/allocator/BackupStorageSelectPrimaryStorageAllocatorFlow.java:71
# args: spec.getImage().getUuid(),name,spec.getRequiredBackupStorageUuid(),spec.getImage().getType(),possiblePrimaryStorageTypes
The\ image[uuid\:%s,\ name\:%s]\ is\ on\ the\ backup\ storage[uuid\:%s,\ type\:%s]\ that\ requires\ to\ work\ with\ primary\ storage[types\:%s],however,\ no\ host\ found\ suitable\ to\ work\ with\ those\ primary\ storage = 镜像[uuid:{0},name:{1}]所在的镜像服务器[uuid:{2}, type:{3}]必须跟主存储[uuid:{4}]一起使用，但无法找到可以跟满足条件并可以访问该主存储的物理机

# at: src/main/java/org/zstack/compute/allocator/FilterFlow.java:33
# args: filter.getClass().getSimpleName(),filter.filterErrorReason()
after\ filtering,\ HostAllocatorFilterExtensionPoint[%s]\ returns\ zero\ candidate\ host,\ it\ means\:\ %s = 

# at: src/main/java/org/zstack/compute/allocator/HostAllocatorApiInterceptor.java:56
# args: 
either\ volumeUuid\ or\ volumeSnapshotUuid\ must\ be\ set = 云盘uuid或者快照uuid必须被设置

# at: src/main/java/org/zstack/compute/allocator/HostAllocatorApiInterceptor.java:75
# args: 
zoneUuids,\ clusterUuids,\ hostUuids\ must\ at\ least\ have\ one\ be\ none-empty\ list,\ or\ all\ is\ set\ to\ true = 区域uuid，集群uuid,物理机uuid必须有一个不为空，或者全部都填写

# at: src/main/java/org/zstack/compute/allocator/HostCapacityAllocatorFlow.java:61
# args: spec.getCpuCapacity(),spec.getMemoryCapacity()
no\ host\ having\ cpu[%s],\ memory[%s\ bytes]\ found = 

# at: src/main/java/org/zstack/compute/allocator/HostOsVersionAllocatorFlow.java:62
# args: currentVersion
no\ candidate\ host\ has\ version[%s] = 

# at: src/main/java/org/zstack/compute/allocator/HostPrimaryStorageAllocatorFlow.java:180
# args: PrimaryStorageState.Enabled,PrimaryStorageState.Disabled,PrimaryStorageStatus.Connected
cannot\ find\ available\ primary\ storage[state\:\ %s\ or\ %s,\ status\:\ %s].\ Check\ the\ state/status\ of\ primary\ storage\ and\ make\ sure\ they\ have\ been\ attached\ to\ clusters = 

# at: src/main/java/org/zstack/compute/allocator/HostPrimaryStorageAllocatorFlow.java:176
# args: PrimaryStorageState.Enabled,PrimaryStorageStatus.Connected,spec.getDiskSize()
cannot\ find\ available\ primary\ storage[state\:\ %s,\ status\:\ %s,\ available\ capacity\ %s\ bytes].\ Check\ the\ state/status\ of\ primary\ storage\ and\ make\ sure\ they\ have\ been\ attached\ to\ clusters = 

# at: src/main/java/org/zstack/compute/allocator/HostSortorChain.java:125
# args: e.getMessage(),host.getUuid(),e.getMessage()
[Host\ Allocation]\:\ %s\ on\ host[uuid\:%s].\ try\ next\ one.\ %s = 

# at: src/main/java/org/zstack/compute/allocator/HostStateAndHypervisorAllocatorFlow.java:97
# args: spec.getHypervisorType()
no\ host\ having\ state\=Enabled\ status\=Connected\ hypervisorType\=%s\ found = 

# at: src/main/java/org/zstack/compute/allocator/HostStateAndHypervisorAllocatorFlow.java:99
# args: 
no\ host\ having\ state\=Enabled\ status\=Connected\ found = 

# at: src/main/java/org/zstack/compute/allocator/HostStateAndHypervisorAllocatorFlow.java:94
# args: candidates.size(),spec.getHypervisorType()
no\ Enabled\ hosts\ found\ in\ the\ [%s]\ candidate\ hosts\ having\ the\ hypervisor\ type\ [%s] = 

# at: src/main/java/org/zstack/compute/allocator/HostStateAndHypervisorAllocatorFlow.java:92
# args: candidates.size()
no\ Enabled\ hosts\ found\ in\ the\ [%s]\ candidate\ hosts = 

# at: src/main/java/org/zstack/compute/allocator/HostStateAndHypervisorAllocatorFlow.java:90
# args: candidates.size()
no\ Connected\ hosts\ found\ in\ the\ [%s]\ candidate\ hosts = 

# at: src/main/java/org/zstack/compute/allocator/ImageBackupStorageAllocatorFlow.java:92
# args: spec.getImage().getUuid(),spec.getImage().getName()
the\ image[uuid\:%s,\ name\:%s]\ is\ deleted\ on\ all\ backup\ storage = 镜像[uuid:{0}, name:{1}]已经从所有镜像服务器上删除，无法执行相应操作

# at: src/main/java/org/zstack/compute/allocator/ImageBackupStorageAllocatorFlow.java:126
# args: zoneUuids,spec.getImage().getUuid()
no\ host\ found\ in\ zones[uuids\:%s]\ that\ attaches\ to\ backup\ storage\ where\ image[%s]\ is\ on = 

# at: src/main/java/org/zstack/compute/allocator/TagAllocatorFlow.java:68
# args: extp.getClass().getName()
InstanceOfferingTagAllocatorExtensionPoint[%s]\ return\ zero\ candidate\ host = 

# at: src/main/java/org/zstack/compute/allocator/TagAllocatorFlow.java:104
# args: extp.getClass().getName()
DiskOfferingTagAllocatorExtensionPoint[%s]\ return\ zero\ candidate\ host = 

# at: src/main/java/org/zstack/compute/cluster/ClusterApiInterceptor.java:55
# args: 
if\ cluster\ type\ is\ baremetal,\ then\ hypervisorType\ must\ be\ baremetal\ too,\ or\ vice\ versa = 

# at: src/main/java/org/zstack/compute/cluster/ClusterApiInterceptor.java:71
# args: 
only\ kvm\ hosts'\ operating\ system\ can\ be\ updated,\ for\ now = 目前只支持升级KVM物理机操作系统

# at: src/main/java/org/zstack/compute/cluster/ClusterApiInterceptor.java:82
# args: msg.getUuid()
there\ are\ hosts\ in\ cluster[uuid\:%s]\ in\ the\ PreMaintenance\ state,\ cannot\ update\ cluster\ os\ right\ now = 集群[uuid:{0}] 中存在处于预维护模式的物理机，无法执行操作系统升级操作

# at: src/main/java/org/zstack/compute/cluster/ClusterApiInterceptor.java:94
# args: msg.getUuid()
not\ all\ hosts\ in\ cluster[uuid\:%s]\ are\ in\ the\ Connected\ status,\ cannot\ update\ cluster\ os\ right\ now = 集群[uuid:{0}] 中存在未处于已连接状态的物理机，无法执行操作系统升级操作

# at: src/main/java/org/zstack/compute/cpuPinning/CpuPinningBasicFactory.java:45
# args: r
invalid\ cpu\ pinning\ ref[%s].\ correct\ example\ is\ [1,3\:3-6,^5] = 

# at: src/main/java/org/zstack/compute/cpuPinning/CpuPinningBasicFactory.java:82
# args: pCpuNum
the\ host\ vm\ located\ only\ have\ %\ CPUs = 

# at: src/main/java/org/zstack/compute/cpuPinning/CpuPinningFilterFlow.java:48
# args: 
vcpu\ pinning\ pcpu\ id\ >\ host\ cores = vcpu要绑定的pcpu id大于了物理机实际核数

# at: src/main/java/org/zstack/compute/cpuPinning/CpuRangeSet.java:58
# args: word
Invalid\ cpuset\ [%s] = 

# at: src/main/java/org/zstack/compute/host/HostApiInterceptor.java:81
# args: msg.getHostUuid()
can\ not\ update\ host[uuid\:%s]which\ is\ connecting\ or\ creating,\ please\ wait. = 无法更新处于连接或创建状态中的物理机[uuid:{0}]信息，请等待

# at: src/main/java/org/zstack/compute/host/HostApiInterceptor.java:87
# args: msg.getManagementIp()
managementIp[%s]\ is\ neither\ an\ IPv4\ address\ nor\ a\ valid\ hostname = 管理IP[{0}]既不是有效的IPv4地址也不是有效的物理机名

# at: src/main/java/org/zstack/compute/host/HostApiInterceptor.java:97
# args: msg.getHostUuid(),hostStatus
can\ not\ maintain\ host[uuid\:%s,\ status\:%s]which\ is\ not\ Connected = 只能对已连接状态的物理机[uuid:{0}, status:{1}]进行维护操作

# at: src/main/java/org/zstack/compute/host/HostBase.java:252
# args: vmFailedToMigrate,self.getUuid(),self.getName(),self.getManagementIp()
failed\ to\ migrate\ vm[uuids\:%s]\ on\ host[uuid\:%s,\ name\:%s,\ ip\:%s],\ will\ try\ stopping\ it. = 

# at: src/main/java/org/zstack/compute/host/HostBase.java:602
# args: 
host\ is\ connecting,\ ping\ failed = 物理机正在连接, 不能进行ping操作

# at: src/main/java/org/zstack/compute/host/HostManagerImpl.java:229
# args: msg.getManagementIp()
there\ has\ been\ a\ host\ having\ managementIp[%s] = 已经存在一个管理IP是[{0}]的物理机

# at: src/main/java/org/zstack/compute/host/HostManagerImpl.java:235
# args: msg.getClusterUuid()
cluster[uuid\:%s]\ is\ not\ existing = 

# at: src/main/java/org/zstack/compute/host/HostManagerImpl.java:325
# args: vo.getName(),vo.getManagementIp()
after\ connecting,\ host[name\:%s,\ ip\:%s]\ returns\ a\ null\ os\ version = 在连接操作后，物理机[name:{0}, ip:{1}]没有返回操作系统版本信息

# at: src/main/java/org/zstack/compute/host/HostManagerImpl.java:356
# args: vo.getClusterUuid(),currentVersion,vo.getName(),vo.getManagementIp(),mineVersion
cluster[uuid\:%s]\ already\ has\ host\ with\ os\ version[%s],\ but\ new\ added\ host[name\:%s\ ip\:%s]\ has\ host\ os\ version[%s] = 集群[uuid:{0}]中物理机使用的操作系统版本是[{1}]，但是新的物理机[name:{2} ip:{3}]的操作系统版本是 [{4}]

# at: src/main/java/org/zstack/compute/host/HostManagerImpl.java:509
# args: d.getPrimaryStorageUuid()
primary\ storage[uuid\:%s]\ becomes\ disconnected,\ the\ host\ has\ no\ connected\ primary\ storage\ attached = 主存储[uuid:{0}]失联，物理机没有关联的主存储

# at: src/main/java/org/zstack/compute/host/MevocoHostBase.java:171
# args: host.getUuid(),host.getName(),host.getState()
host[uuid\:%s,\ name\:%s]\ is\ in\ state[%s],\ cannot\ perform\ required\ operation = 物理机[uuid:{0}, name:{1}]处于状态[{2}]中，不能处理该请求

# at: src/main/java/org/zstack/compute/host/MevocoHostBase.java:283
# args: vmInstanceVO.getUuid(),vmInstanceVO.getState()
only\ support\ do\ live\ snapshot\ on\ vm\ state[%s],\ but\ vm\ is\ on\ [%s]\ state = 

# at: src/main/java/org/zstack/compute/host/MevocoHostBase.java:391
# args: ret.getError()
operation\ error,\ because\ %s = 操作错误，因为{0}

# at: src/main/java/org/zstack/compute/host/MevocoHostBaseFactory.java:69
# args: huuid,cidr
host[uuid\:%s]\ has\ multi\ ips\ in\ cidr[%s] = 物理机[uuid:{0}]在cidr[{1}]中有多个ip

# at: src/main/java/org/zstack/compute/host/MevocoHostManagerImpl.java:264
# args: msg.getHostUuid()
host[uuid\:%s]\ can\ not\ find = 

# at: src/main/java/org/zstack/compute/host/MevocoHostManagerImpl.java:256
# args: clusterUuids,hypervisorType
cluster[uuids\:%s,\ hypervisorType\:%s]\ are\ not\ exist! = 

# at: src/main/java/org/zstack/compute/vm/ChangeVmPasswordFlow.java:50
# args: 
not\ dest\ host\ found\ in\ db,\ can't\ send\ change\ password\ cmd\ to\ the\ host! = 没有在物理机上发现数据库，不能发送更改密码的指令到这个物理机上

# at: src/main/java/org/zstack/compute/vm/ChangeVmPasswordFlow.java:51
# args: 
not\ system\ tag\ found\ on\ vm,\ vm\ must\ have\ the\ following\ system\ tag\:\ qemuga,\ if\ you\ installed\ qemu-ga\ yourself,\ please\ use\ CreateSystemTag\ first. = 没有发现系统标签在云主机上，云主机必须有系统标签: qemuga。如果你已经安装了qemu-ga，请先使用 CreateSystemTag

# at: src/main/java/org/zstack/compute/vm/ChangeVmPasswordFlow.java:54
# args: 
not\ account\ preference\ found,\ \ send\ change\ password\ cmd\ to\ the\ host! = 没有优先级账户去发送改变密码的指令到物理机

# at: src/main/java/org/zstack/compute/vm/DeleteVmGC.java:50
# args: hostUuid
the\ host[uuid\:%s]\ is\ not\ connected = 物理机[uuid:{0}]不是Connected状态

# at: src/main/java/org/zstack/compute/vm/IsoOperator.java:40
# args: vmUuid,isoUuid
VM[uuid\:%s]\ has\ attached\ ISO[uuid\:%s] = 云主机[uuid:{0}]已经加载了ISO[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/IsoOperator.java:48
# args: vmUuid
All\ vm[uuid\:%s]\ CD-ROMs\ have\ mounted\ ISO = 

# at: src/main/java/org/zstack/compute/vm/MacOperator.java:77
# args: mac
This\ is\ not\ a\ valid\ MAC\ address\ [%s] = 这是一个无效的MAC地址

# at: src/main/java/org/zstack/compute/vm/MacOperator.java:87
# args: mac
Not\ a\ valid\ MAC\ address\ [%s] = 这是一个无效的MAC地址[{0}]

# at: src/main/java/org/zstack/compute/vm/MacOperator.java:90
# args: 
Disallowed\ address = 不被允许的MAC地址

# at: src/main/java/org/zstack/compute/vm/MacOperator.java:93
# args: mac
Expected\ unicast\ mac\ address,\ found\ multicast\ MAC\ address\ [%s] = 期望的是一个单播的MAC地址，但找到的是一个多播的MAC地址[{0}]

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:527
# args: 
can\ not\ find\ image\ store\ backup\ storage,\ unable\ to\ commit\ volume\ snapshot\ as\ image = 

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:816
# args: inv.getInventory().getUuid(),state
vm\ running\ on\ local\ storage\ %s\ state\ is\ %s\ not\ running/stopped/paused,\ can\ not\ attach\ volume = 

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:1415
# args: 
direction\ must\ be\ set\ to\ in\ or\ out = 方法必须设置in或者out

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:1457
# args: inbound
inboundBandwidth\ must\ be\ set\ no\ more\ than\ %s. = 下行带宽不能超过{0}

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:1468
# args: outbound
outboundBandwidth\ must\ be\ set\ no\ more\ than\ %s. = 上行带宽不能超过{0}

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:1559
# args: self.getUuid()
vm\ [%s]'\ state\ must\ be\ Running\ or\ Paused\ to\ sync\ nic\ qos = 

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:1564
# args: 
vm\ [%s]'s\ HostUuid\ is\ null,\ cannot\ sync\ nic\ qos = 

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:1901
# args: amsg.getVmInstanceUuid()
not\ dest\ host\ found\ in\ db\ by\ uuid\:\ %s,\ can't\ send\ change\ password\ cmd\ to\ the\ host! = 没有在物理机{0}上发现数据库，不能发送更改密码的指令到这个物理机上

# at: src/main/java/org/zstack/compute/vm/MevocoVmInstanceBase.java:1929
# args: 
state\ is\ not\ correct\ while\ change\ password. = 该状态不支持修改密码

# at: src/main/java/org/zstack/compute/vm/VmAllocateCdRomFlow.java:53
# args: spec.getVmInventory().getUuid()
vm[uuid\:%s]\ cdRom\ deviceId\ repetition = 

# at: src/main/java/org/zstack/compute/vm/VmAllocateNicFlow.java:79
# args: v.getUuid()
there\ is\ no\ available\ ipRange\ on\ L3\ network\ [%s] = L3网络[{0}]中没有可用的网络段

# at: src/main/java/org/zstack/compute/vm/VmAllocatePrimaryStorageForAttachingDiskFlow.java:42
# args: spec.getVmInventory().getUuid()
\ Can\ not\ find\ the\ vm's\ host,\ please\ start\ the\ vm[%s],\ then\ mount\ the\ disk = 未找到虚拟机的物理机，请重启虚拟机[{0}]，然后挂载云盘

# at: src/main/java/org/zstack/compute/vm/VmDownloadIsoFlow.java:68
# args: iso.getUuid(),host.getZoneUuid(),spec.getVmInventory().getName(),spec.getVmInventory().getUuid()
cannot\ find\ the\ iso[uuid\:%s]\ in\ any\ connected\ backup\ storage\ attached\ to\ the\ zone[uuid\:%s].\ check\ below\:\n1.\ if\ the\ backup\ storage\ is\ attached\ to\ the\ zone\ where\ the\ VM[name\:\ %s,\ uuid\:%s]\ is\ running\n2.\ if\ the\ backup\ storage\ is\ in\ connected\ status,\ if\ not,\ try\ reconnecting\ it = 不能发现iso[uuid:{0}]在任何已经挂载到集群[uuid:{1}]上的并且处于Connected状态备份的镜像服务器。可以进行对以下选项的检查: \n1. 镜像服务器是否已经挂载到区域中的任何运行状态的云主机[name: {2}, uuid:{3}]上；\n2. 如果镜像服务器不是处于连接状态，请尝试重连

# at: src/main/java/org/zstack/compute/vm/VmImageSelectBackupStorageFlow.java:92
# args: imageUuid,spec.getVmInventory().getName(),spec.getVmInventory().getUuid()
cannot\ find\ the\ image[uuid\:%s]\ in\ any\ connected\ backup\ storage.\ check\ below\:\n1.\ if\ the\ backup\ storage\ is\ attached\ to\ the\ zone\ where\ the\ VM[name\:\ %s,\ uuid\:%s]\ is\ in\n2.\ if\ the\ backup\ storage\ is\ in\ connected\ status,\ if\ not,\ try\ reconnecting\ it = 不能发现镜像[uuid:{0}]在任何处于Connected状态备份的镜像服务器。可以进行对以下选项的检查: \n1. 镜像服务器是否已经过载到区域中的云主机[name: {1}, uuid:{2}]中；\n2. 如果镜像服务器不是处于连接状态，请尝试重连

# at: src/main/java/org/zstack/compute/vm/VmImageSelectBackupStorageFlow.java:86
# args: imageUuid,spec.getVmInventory().getZoneUuid(),spec.getVmInventory().getName(),spec.getVmInventory().getUuid()
cannot\ find\ the\ image[uuid\:%s]\ in\ any\ connected\ backup\ storage\ attached\ to\ the\ zone[uuid\:%s].\ check\ below\:\n1.\ if\ the\ backup\ storage\ is\ attached\ to\ the\ zone\ where\ the\ VM[name\:\ %s,\ uuid\:%s]\ is\ in\n2.\ if\ the\ backup\ storage\ is\ in\ connected\ status,\ if\ not,\ try\ reconnecting\ it = 不能发现镜像[uuid:{0}]在任何已经挂载到集群[uuid:{1}]上的并且处于Connected状态备份的镜像服务器。可以进行对以下选项的检查: \n1. 镜像服务器是否已经过载到区域中的云主机[name: {2}, uuid:{3}]中；\n2. 如果镜像服务器不是处于Connected状态，请尝试重连

# at: src/main/java/org/zstack/compute/vm/VmImageSelectBackupStorageFlow.java:114
# args: zoneUuid,isoImageUuid
no\ backup\ storage\ attached\ to\ the\ zone[uuid\:%s]\ contains\ the\ ISO[uuid\:%s] = 没有包含着ISO[uuid:{1}]的镜像服务器添加到区域[uuid:{0}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:131
# args: msg.getVmInstanceUuid(),vo.getState().toString()
Can\ not\ create\ CD-ROM\ for\ vm[uuid\:%s]\ which\ is\ in\ state[%s]\  = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:139
# args: 
rootVolumeOffering\ is\ needed\ when\ image\ media\ type\ is\ ISO = 当镜像类型是ISO时根云盘计算规格需要设置

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:149
# args: msg.getVmInstanceUuid(),msg.getHostUuid()
the\ vm[uuid\:%s]\ is\ already\ on\ host[uuid\:%s] = 云主机[uuid:{0}]已经运行于物理机[uuid:{1}]上

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:205
# args: 
the\ VM\ cannot\ do\ online\ cpu/memory\ update\ because\ it\ is\ not\ of\ NUMA\ architecture.\ Please\ stop\ the\ VM\ then\ do\ the\ cpu/memory\ update\ again = 云主机无法执行在线升级CPU/内存，因为不是NUMA架构。请关闭该云主机再尝试

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:211
# args: vo.getUuid(),vo.getState(),StringUtils.join(list(VmInstanceState.Running, VmInstanceState.Stopped), ",")
The\ state\ of\ vm[uuid\:%s]\ is\ %s.\ Only\ these\ state[%s]\ is\ allowed\ to\ update\ cpu\ or\ memory. = 云主机[uuid:{0}]的状态为{1}。只有这些状态[{2}]允许在线升级CPU/内存

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:182
# args: vo.getUuid()
can't\ decrease\ capacity\ when\ vm[uuid\:%s]\ is\ running = 无法在云主机[uuid:{0}]运行时减少容量

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:222
# args: vo.getUuid()
can't\ decrease\ cpu\ of\ vm[uuid\:%s]\ when\ it\ is\ running = 无法在云主机[uuid:{0}]运行时减少CPU数目

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:228
# args: vo.getUuid()
can't\ decrease\ memory\ size\ of\ vm[uuid\:%s]\ when\ it\ is\ running = 无法在云主机[uuid:{0}]运行时减少容量

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:239
# args: 
either\ l3NetworkUuids\ or\ imageUuid\ must\ be\ set = L3网络的uuid们或者镜像的uuid必须被设置

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:254
# args: ip
%s\ is\ not\ a\ valid\ IPv4\ address = {0}不是有效的IPv4地址

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:280
# args: ip,vmNicVO.getUuid()
ip\ address\ [%s]\ already\ set\ to\ vmNic\ [uuid\:%s] = IP地址[{0}]已经设置到网卡[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:265
# args: ip,rangeVO.getNetworkCidr()
ip\ address\ [%s]\ is\ not\ in\ ip\ range\ [%s] = IP地址[{0}]不在IP地址段[{1}]范围内

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:274
# args: ip
%s\ is\ not\ a\ valid\ IPv6\ address = {0}不是有效的IPv6地址

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:285
# args: ip,rangeVO.getStartIp(),rangeVO.getEndIp()
ip\ address\ [%s]\ is\ not\ in\ ip\ range\ [startIp\ %s,\ endIp\ %s] = IP地址[{0}]不在IP地址段[{1}-{2}]范围内

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:319
# args: msg.getVmInstanceUuid(),msg.getL3NetworkUuid()
the\ VM[uuid\:%s]\ has\ no\ nic\ on\ the\ L3\ network[uuid\:%s] = 云主机[uuid:{0}]在L3网络[uuid:{1}]上没有任何网卡

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:330
# args: o,msg.getBootOrder()
invalid\ boot\ device[%s]\ in\ boot\ order%s = 在启动列表{1}中的设备[{0}]启动失败

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:354
# args: cdRomUuid
The\ cdRom[uuid\:%s]\ does\ not\ exist = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:358
# args: msg.getVmInstanceUuid(),cdRomUuid
VM[uuid\:%s]\ cdRom[uuid\:%s]\ has\ mounted\ the\ ISO = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:376
# args: msg.getVmInstanceUuid()
VM[uuid\:%s]\ has\ multiple\ ISOs\ attached,\ specify\ the\ isoUuid\ when\ detaching = 云主机[uuid:{0}]已经加载了多个ISO，卸载ISO时需要指定ISO的Uuid

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:584
# args: l3NetworkVO.getUuid()
unable\ to\ attach\ a\ L3\ network.\ The\ L3\ network[uuid\:%s]\ is\ disabled = 不能挂载L3网络，因为该L3网络[uuid:{0}]处于未启动状态

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:534
# args: staticIp,l3Uuid
the\ static\ IP[%s]\ is\ not\ in\ any\ IP\ range\ of\ the\ L3\ network[uuid\:%s] = 该静态IP[{0}]不在L3网络[uuid:{1}]的任何IP段

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:541
# args: staticIp,l3Uuid
the\ static\ IP[%s]\ has\ been\ occupied\ on\ the\ L3\ network[uuid\:%s] = 该静态IP[{0}]已经存在在L3网络[uuid:{1}]中

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:564
# args: msg.getVmInstanceUuid(),state
unable\ to\ attach\ a\ L3\ network.\ The\ vm[uuid\:\ %s]\ is\ not\ Running\ or\ Stopped;\ the\ current\ state\ is\ %s = 无法挂载L3网络。云主机[uuid: {0}]既不处于Running也不处于Stopped状态中，当前状态为{1}

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:444
# args: newAddedL3Uuids,l2Uuids
unable\ to\ attach\ a\ L3\ network.\ The\ L3\ network[uuid\:%s]\ are\ belonged\ to\ different\ l2\ networks\ [uuids\:%s] = 不能挂载L3网络，L3网络[uuid:{0}]属于不同的L2网络

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:575
# args: vmNicVO.getL3NetworkUuid(),msg.getVmInstanceUuid()
unable\ to\ attach\ a\ L3\ network.\ The\ L3\ network[uuid\:%s]\ is\ already\ attached\ to\ the\ vm[uuid\:\ %s] = 不能挂载L3网络，l3网络[uuid:{0}]已经挂载到云主机[uuid: {1}]上了

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:587
# args: l3NetworkVO.getUuid()
unable\ to\ attach\ a\ L3\ network.\ The\ L3\ network[uuid\:%s]\ is\ a\ system\ network\ and\ vm\ is\ a\ user\ vm = 不能连接三层网络。这个三层网络[uuid:{0}]是系统网络，但虚拟机是一个用户虚拟机

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:484
# args: statefulIpv6
there\ are\ %d\ ipv6\ stateful\ or\ stateless\ network\ on\ same\ nic = 不能挂载L3网络，有{0}个Stateful-DHCP类型或者Stateless-DHCP类型的网络属于同一个网卡

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:516
# args: e.getKey(),newAddedL3Uuids
static\ ip\ l3\ uuid[%s]\ is\ not\ included\ in\ nic\ l3\ [%s] = 静态IP的L3网络[uuid:{0}]不在网卡的L3列表[uuid:{1}]中

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:602
# args: msg.getVmInstanceUuid(),state
unable\ to\ detach\ a\ L3\ network.\ The\ vm[uuid\:\ %s]\ is\ not\ Running\ or\ Stopped;\ the\ current\ state\ is\ %s = 不能挂载L3网络，云主机[uuid: {0}]不是运行状态或者暂停状态，状态为{1}

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:628
# args: msg.getVmInstanceUuid(),state
vm[uuid\:%s]\ can\ only\ attach\ volume\ when\ state\ is\ Running\ or\ Stopped,\ current\ state\ is\ %s = 云主机[uuid:{0}]挂载盘时状态只能是运行或者暂停状态，而现在的状态是{1}

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:636
# args: 
image\ mediaType\ is\ ISO\ but\ missing\ root\ disk\ settings = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:640
# args: 
Unexpected\ root\ disk\ settings = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:651
# args: 
Missing\ CPU/memory\ settings = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:655
# args: 
Unexpected\ CPU/memory\ settings = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:843
# args: cdRomIsoUuid
The\ image[uuid\=%s]\ does\ not\ exist = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:848
# args: 
Do\ not\ allow\ to\ mount\ duplicate\ ISO = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:863
# args: 
The\ console\ password\ cannot\ start\ with\ 'password'\ which\ may\ trigger\ a\ VNC\ security\ issue = 控制台密码不能以password开头，这样可能导致一个VNC安全问题

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:872
# args: msg.getVmNicUuid()
vmNic[uuid\:%s]\ is\ not\ attached\ to\ vmInstance = 网卡[uuid{0}]还没有绑定到云主机

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:879
# args: msg.getL3NetworkUuid(),msg.getVmNicUuid()
L3\ network[uuid\:%s]\ has\ already\ been\ to\ attached\ vmNic[uuid\:%s] = 三层网络[uuid:{0}]已经绑定到网卡[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:899
# args: ipVO.getL3NetworkUuid(),msg.getVmNicUuid()
there\ is\ another\ IPv6\ stateful-dhcp\ network[uuid\:%s]\ attached\ vmNic[uuid\:%s] = 已经有另外一个有状态的IPv6网络[uuid:{0}]绑定到网卡[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:888
# args: ipVO.getL3NetworkUuid(),msg.getVmNicUuid()
there\ is\ another\ IPv4\ network[uuid\:%s]\ attached\ vmNic[uuid\:%s] = 已经有另外一个IPv4网络[uuid:{0}]绑定到网卡[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:917
# args: l3Vo.getL2NetworkUuid(),oldL3.getL2NetworkUuid()
l2Network\ [uuid\:%s]\ to\ be\ attached\ is\ different\ from\ l2Network\ [uuid\:%s]\ of\ the\ nic = 将被添加的二层网络[uuid:{0}]和网卡当前的二层网络[uuid:{1}]不同

# at: src/main/java/org/zstack/compute/vm/VmInstanceApiInterceptor.java:936
# args: vmCdRomVO.getUuid()
The\ CdRom[%s]\ Already\ the\ default = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:6050
# args: msg.getVmInstanceUuid(),msg.getIsoUuid()
VM[uuid\:%s]\ already\ has\ an\ ISO[uuid\:%s]\ attached = 云主机[uuid:{0}]已经挂载了ISO[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:231
# args: vo.getUuid(),vo.getName()
vm[uuid\:%s,\ name\:%s]\ has\ been\ deleted = 云主机[uuid:{0}, name:{1}]已经被删除了

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:711
# args: self.getUuid(),l3Uuid
the\ vm[uuid\:%s]\ has\ no\ nic\ on\ the\ L3\ network[uuid\:%s] = 云主机[uuid:{0}] 没有网卡在L3网络[uuid:{1}]上

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:1084
# args: 
the\ vm\ has\ been\ deleted = 云主机已经被删除了

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:3662
# args: isoUuid,psUuid,self.getName(),self.getUuid()
the\ ISO[uuid\:%s]\ is\ on\ backup\ storage\ that\ is\ not\ compatible\ of\ the\ primary\ storage[uuid\:%s]\ where\ the\ VM[name\:%s,\ uuid\:%s]\ is\ on = ISO[uuid:{0}]在镜像服务器上，这个ISO不能兼容主存储[uuid:{1}]在云主机[name:{2}, uuid:{3}]上

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:4034
# args: self.getHostUuid(),cpuNum - oldCpuNum,struct.alignedMemory - oldMemorySize
host[uuid\:%s]\ capacity\ is\ not\ enough\ to\ offer\ cpu[%s],\ memory[%s\ bytes] = 物理机[uuid:{0}]无法提供CPU: [{1}]，内存: [{2} bytes]

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:4254
# args: isoUuid,self.getUuid()
ISO[uuid\:%s]\ is\ not\ attached\ to\ VM[uuid\:%s] = ISO[uuid:{0}]未被加载到云主机[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:4936
# args: self.getUuid()
unable\ to\ start\ the\ vm[uuid\:%s].\ It\ doesn't\ have\ any\ nic,\ please\ attach\ a\ nic\ and\ try\ again = 无法启动虚拟机[uuid:{0}]。该虚拟机没有网卡，请添加网卡后再试

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:5173
# args: cdRomSpecs.size(),max
One\ vm\ cannot\ create\ %s\ CDROMs,\ vm\ can\ only\ add\ %s\ CDROMs = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceBase.java:6063
# args: msg.getVmInstanceUuid(),max
VM[uuid\:%s]\ can\ only\ add\ %s\ CDROMs = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:57
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceStartNewCreatedVmExtensionPoint[%s]\ refuses\ to\ create\ vm[uuid\:%s]\ because\ %s = VmInstanceStartNewCreatedVmExtensionPoint[{0}] 因为{2} 拒绝创建虚拟机[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:141
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceRebootExtensionPoint[%s]\ refuses\ to\ reboot\ vm[uuid\:%s]\ because\ %s = VmInstanceRebootExtensionPoint[{0}] 因为{2} 拒绝重启虚拟机[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:183
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceDestroyVmExtensionPoint[%s]\ refuses\ to\ destroy\ vm[uuid\:%s]\ because\ %s = VmInstanceDestroyVmExtensionPoint[{0}] 因为{2} 拒绝删除虚拟机[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceExtensionPointEmitter.java:224
# args: ext.getClass().getName(),inv.getUuid(),err
VmInstanceStartExtensionPoint[%s]\ refuses\ to\ start\ vm[uuid\:%s]\ because\ %s = VmInstanceStartExtensionPoint[{0}] 因为{2} 拒绝启动虚拟机[uuid:{1}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1510
# args: ipv4Count
there\ are\ %d\ ipv4\ network\ on\ same\ nic = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:407
# args: msg.getImageUuid(),msg.getZoneUuid()
the\ image[uuid\:%s]\ is\ not\ on\ any\ backup\ storage\ that\ has\ been\ attached\ to\ the\ zone[uuid\:%s] = 镜像[uuid:{0}]不在任何加载到区域[uuid:{1}]的镜像服务器上

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:475
# args: image.getName(),image.getUuid()
the\ image[name\:%s,\ uuid\:%s]\ is\ an\ ISO,\ rootDiskOfferingUuid\ must\ be\ set = 镜像[name:{0}, uuid:{1}]是一个IOS, 必须设置根云盘规格

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:515
# args: image.getName(),image.getUuid()
zoneUuid\ must\ be\ set\ because\ the\ image[name\:%s,\ uuid\:%s]\ is\ on\ multiple\ backup\ storage = zoneUuid必须被设置，因为image[name:{0}, uuid:{1}]在多个镜像服务器上

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1413
# args: hostname,tag
hostname[%s]\ specified\ in\ system\ tag[%s]\ is\ not\ a\ valid\ domain\ name = 在系统标签[{1}]中特别声明的主机名[{0}]不是一个有效的域名

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1425
# args: hostnameCount
only\ one\ hostname\ system\ tag\ is\ allowed,\ but\ %s\ got = 只允许通过系统标签设置一个主机名，但是实际上有{0}

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1461
# args: ip,sysTag
%s\ is\ not\ a\ valid\ IPv6\ address.\ Please\ correct\ your\ system\ tag[%s]\ of\ static\ IP = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1455
# args: ip,sysTag
%s\ is\ not\ a\ valid\ IPv4\ address.\ Please\ correct\ your\ system\ tag[%s]\ of\ static\ IP = {0}不是一个有效的IPv4地址。请修改你关于静态IP的系统标签

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1477
# args: ip,l3Uuid,cr.getReason()
IP[%s]\ is\ not\ available\ on\ the\ L3\ network[uuid\:%s]\ because\:\ %s = 在L3网络[uuid:{1}]中，IP[{0}]不可用, 因为'{{2}'}

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1520
# args: uuid
l3\ network\ [uuid\:\ %s]\ is\ added\ to\ vm\ more\ than\ once = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1514
# args: statefulIpv6Count
there\ are\ %d\ ipv6\ stateful\ network\ on\ same\ nic = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1537
# args: primaryL3Uuid,sysTag
L3\ network[uuid\:%s]\ not\ found.\ Please\ correct\ your\ system\ tag[%s]\ of\ dualStackNic = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1542
# args: primaryL3Uuid,secondaryL3Uuid
L3\ networks[primaryL3Uuid\:%s,\ secondaryL3Uuid\:%s]\ of\ dualStackNic\ is\ not\ on\ same\ l2\ network = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1553
# args: secondaryL3Uuid
L3\ networks[uuid\:%s]\ does\ not\ have\ ip\ range = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1576
# args: tag,sameTag.getResourceUuid(),hostname,l3Uuid
conflict\ hostname\ in\ system\ tag[%s];\ there\ has\ been\ a\ VM[uuid\:%s]\ having\ hostname[%s]\ on\ L3\ network[uuid\:%s] = 系统标签的主机名存在冲突[{0}]；已经存在以一个主机名为[{2}]的VM[uuid:{1}]出现在L3网络[uuid:{3}]中

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1609
# args: o,order
invalid\ boot\ device[%s]\ in\ boot\ order[%s] = 在引导顺序[{1}]中存在无效的引导设备[{0}]

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1627
# args: resourceUuid
Already\ have\ one\ userdata\ systemTag\ for\ vm[uuid\:\ %s]. = 在虚拟机[uuid:{0}]已经存在一个userdata的系统标签

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1647
# args: 
Shouldn't\ be\ more\ than\ one\ userdata\ systemTag\ for\ one\ vm. = 在一个虚拟机中不能存在多个userdata的系统标签

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:1770
# args: type
vm\ machine\ type\ requires\ [q35,\ pc],\ but\ get\ [%s] = 

# at: src/main/java/org/zstack/compute/vm/VmInstanceManagerImpl.java:2182
# args: ref.getResourceUuid()
the\ resource[uuid\:%s]\ is\ a\ ROOT\ volume,\ you\ cannot\ change\ its\ owner,\ instead,change\ the\ owner\ of\ the\ VM\ the\ root\ volume\ belongs\ to = 当前资源[uuid:{0}]是一个根云盘，你不能改变它的所有者，但是你能够修改对应VM的所有者

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:148
# args: msg.getMac()
Duplicate\ mac\ address\ [%s] = 重复的MAC地址[{0}]

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:158
# args: vmType
clean\ traffic\ is\ not\ supported\ for\ vm\ type\ [%s] = 

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:84
# args: 
The\ operation\ only\ allows\ on\ user\ vm = 

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:114
# args: msg.getVmInstanceUuid(),volumeVOS.stream().map(VolumeVO::getUuid).collect(Collectors.toList()),primaryStorageUuid,(totalCapacity - snapshotsCapacity) * msg.getNames().size(),primaryStorageVO.getCapacity().getAvailableCapacity()
there\ are\ not\ enough\ capacity\ for\ full\ vm\ clone\ to\ vm[uuid\:\ %s],\ volumes[uuid\:\ %s]\ on\ primary\ storage[uuid\:\ %s]\ required\:\ %s\ bytes,\ current\ available\ capacity\ is\ %s\ bytes = 没有足够的空间对虚拟机[uuid: {0}]做整机克隆，主存储[uuid: {2}]上的云盘[uuid: {1}]共需要[{3}]字节的空间，目前主存储的可用空间为[{4}]字节

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:128
# args: msg.getVmNicUuid()
The\ nic\ [%s%s]\ is\ not\ mounted\ on\ the\ VM = 网卡[{0}]不能被挂载到虚拟机上

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:134
# args: 
The\ operation\ only\ allows\ on\ user\ vm\  = 该操作只能在用户虚拟机上进行

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:139
# args: vmInstanceVO.getUuid()
The\ operation\ only\ allows\ when\ vm\ [%s]\ state\ is\ stopped\  = 该操作只有虚拟机[{0}]状态为已停止才能进行

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:168
# args: msg.getVmInstanceUuid()
user\ has\ no\ privilege\ to\ change\ image\ of\ vm\ %s = 当前用户不能修改虚拟机{0}的镜像

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:181
# args: 
Can't\ change\ vm\ image\ when\ it's\ not\ stopped = 

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:187
# args: 
Can't\ change\ vm\ image\ without\ L3\ network = 

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:202
# args: msg.getVmInstanceUuid()
make\ sure\ the\ primary\ storage\ vm[uuid\:%s]\ was\ on\ is\ Enabled\ and\ Connected = 确认主存储[uuid:{0}]是可用的且已连接

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:217
# args: msg.getVmInstanceUuid()
make\ sure\ the\ last\ host\ vm[uuid\:%s]\ was\ on\ is\ Enabled\ and\ Connected = 确定物理机[uuid:{0}]是可用的且已连接

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:236
# args: msg.getVmInstanceUuid(),msg.getImageUuid()
user\ has\ no\ privilege\ to\ change\ root\ volume\ of\ vm\ %s\ using\ image\ %s = 当前用户不能修改使用镜像{1}的虚拟机{0}的根云盘

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:247
# args: 
either\ uuid\ or\ account\ or\ password\ must\ be\ set = uuid或者账户或者密码需要被设置

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:255
# args: msg.getDirection()
direction\ must\ be\ set\ in\ (in,\ out),\ but\ was\ %s = 方向必须设置在(in, out)，但是输入的是{0}

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:261
# args: 
Monitor\ number\ must\ be\ 1\ or\ 2\ or\ 4. = 监听器数量必须是1、2或4

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:269
# args: 
outboundBandwidth\ and\ inboundBandwidth\ must\ be\ set\ at\ lease\ one. = 上行带宽和下行带宽至少有一个需要被设置

# at: src/main/java/org/zstack/compute/vm/VmMevocoApiInterceptor.java:278
# args: msg.getUuid()
nic\ id\:\ %s\ does\ not\ exist... = 网卡id: {0}不存在

# at: src/main/java/org/zstack/configuration/ConfigurationApiInterceptor.java:86
# args: msg.getAllocatorStrategy()
unsupported\ host\ allocation\ strategy[%s] = 不被支持的主机分配策略[{0}]

# at: src/main/java/org/zstack/configuration/ConfigurationApiInterceptor.java:72
# args: msg.getType()
unsupported\ instance\ offering\ type[%s] = 不被支持的计算规格类型[{0}]

# at: src/main/java/org/zstack/configuration/ConfigurationApiInterceptor.java:76
# args: msg.getCpuNum()
cpu\ num[%s]\ is\ less\ than\ 1 = cpu数量[{0}]少于1

# at: src/main/java/org/zstack/configuration/ConfigurationApiInterceptor.java:80
# args: msg.getMemorySize()
memory\ size[%s\ bytes]\ is\ less\ than\ 16M,\ no\ modern\ operating\ system\ is\ likely\ able\ to\ boot\ with\ such\ small\ memory\ size = 内存大小[{0} bytes]少于16M，没有一个现代操作系统能够在如此小的内存里被引导

# at: src/main/java/org/zstack/configuration/ConfigurationApiInterceptor.java:92
# args: msg.getAllocationStrategy()
unsupported\ primary\ storage\ allocation\ strategy[%s] = 不被支持的主存储分配策略[{0}]

# at: src/main/java/org/zstack/console/AbstractConsoleProxyBackend.java:101
# args: 
the\ console\ agent\ is\ not\ connected;\ it's\ mostly\ like\ the\ management\ node\ just\ starts,\ please\ wait\ for\ the\ console\ agent\ connected. = 控制台代理失联，很有可能管理节点刚刚启动，请等待控制台代理的连接

# at: src/main/java/org/zstack/console/AbstractConsoleProxyBackend.java:122
# args: vm.getUuid()
cannot\ find\ host\ IP\ of\ the\ vm[uuid\:%s],\ is\ the\ vm\ running??? = 无法找到vm[uuid:{0}]的主机IP，请确认该vm是否在运行？？？

# at: src/main/java/org/zstack/console/ConsoleApiInterceptor.java:52
# args: msg.getVmInstanceUuid(),state
Console\ is\ only\ available\ when\ the\ VM[uuid\:%s]\ is\ Running,\ but\ the\ current\ state\ is\ %s = 仅当VM[uuid:{0}]处于运行状态时控制台可用，但是现在的状态为{1}

# at: src/main/java/org/zstack/console/ConsoleProxyBase.java:62
# args: uri.toString()
establish\ VNC\:\ unexpected\ uri\:\ %s = 

# at: src/main/java/org/zstack/console/ConsoleProxyBase.java:148
# args: ret.getError()
unable\ to\ check\ console\ proxy\ availability,\ because\ %s = 无法检查控制台代理是否可用，因为{0}

# at: src/main/java/org/zstack/console/ManagementServerConsoleProxyBackend.java:146
# args: 
Ansible\ private\ key\ not\ found. = 

# at: src/main/java/org/zstack/console/ManagementServerConsoleProxyBackend.java:339
# args: uuid
invalid\ management\ node\ UUID[%s] = 非法的管理节点UUID[{0}]

# at: src/main/java/org/zstack/console/ManagementServerConsoleProxyBackend.java:460
# args: 
failed\ to\ configure\ consoleProxyOverriddenIp = 设置consoleProxyOverriddenIp失败

# at: src/main/java/org/zstack/console/ManagementServerConsoleProxyBackend.java:483
# args: 
failed\ to\ reconnect\ console\ proxy = 重连控制台代理失败

# at: src/main/java/org/zstack/core/ansible/AnsibleRunner.java:383
# args: 
User\ name\ or\ password\ or\ port\ number\ may\ be\ problematic = 用户名、密码或者端口可能是错误的

# at: src/main/java/org/zstack/core/ansible/CallBackNetworkChecker.java:61
# args: targetIp,callbackIp,callBackPort
cannot\ nmap\ from\ agent\:\ %s\ to\ callback\ address\:\ %s\:%s = 

# at: src/main/java/org/zstack/core/ansible/SshFolderMd5Checker.java:107
# args: srcFolder,srcRes.getStdout(),srcRes.getStderr()
cannot\ check\ md5sum\ of\ files\ in\ the\ folder[%s].\nstdout\:%s\nstderr\:%s = 无法检查文件夹[{0}]下文件的md5sum.\nstdout:{1}\nstderr:{2}

# at: src/main/java/org/zstack/core/ansible/SshFolderMd5Checker.java:122
# args: dstFolder,hostname,dstRes.getStdout(),dstRes.getStderr()
cannot\ check\ md5sum\ of\ files\ in\ the\ folder[%s]\ on\ the\ host[ip\:%s].\nstdout\:%s\nstderr\:%s = 无法检查主机[ip:{1}]的文件夹[{0}]下文件的md5sum.\nstdout:{2}\nstderr:{3}

# at: src/main/java/org/zstack/core/cloudbus/CloudBusImpl2.java:680
# args: errMsg
message\ is\ not\ in\ corrected\ JSON\ mediaType,\ %s = 消息是错误的JSON格式，{0}

# at: src/main/java/org/zstack/core/cloudbus/CloudBusImpl3.java:542
# args: rsp.getStatusCode(),rsp.getBody()
HTTP\ ERROR,\ status\ code\:\ %s,\ body\:\ %s = 

# at: src/main/java/org/zstack/core/cloudbus/EventFacadeImpl.java:68
# args: EventFacade.WEBHOOK_TYPE
for\ webhooks\ with\ type[%s],\ the\ field\ opaque\ cannot\ be\ null = 对于[{0}]类型的webhooks，opaque字段不能为null

# at: src/main/java/org/zstack/core/config/GlobalConfigFacadeImpl.java:82
# args: msg.getCategory(),msg.getName()
Unable\ to\ find\ GlobalConfig[category\:\ %s,\ name\:\ %s] = 无法找到全局变量[category:{0}, name:{1}]

# at: src/main/java/org/zstack/core/errorcode/ElaborationManagerImpl.java:77
# args: 
non\ file\ or\ jsoncontent\ input = 

# at: src/main/java/org/zstack/core/errorcode/ElaborationManagerImpl.java:82
# args: 
file\ or\ jsoncontent\ cannot\ both\ nonempty = 

# at: src/main/java/org/zstack/core/errorcode/ElaborationManagerImpl.java:114
# args: e.getMessage()
Unable\ to\ scan\ folder\:\ %s = 

# at: src/main/java/org/zstack/core/errorcode/ElaborationManagerImpl.java:118
# args: filename
%s\ is\ not\ existed\ or\ is\ empty\ folder = 

# at: src/main/java/org/zstack/core/errorcode/ElaborationManagerImpl.java:282
# args: 
elaboration\ code\ must\ be\ number! = 

# at: src/main/java/org/zstack/core/errorcode/ElaborationManagerImpl.java:355
# args: 
arg\ 'startTime'\ should\ format\ like\ 'yyyy-MM-dd\ HH\:mm\:ss'\ or\ '1545380003000' = 

# at: src/main/java/org/zstack/core/errorcode/ElaborationManagerImpl.java:352
# args: from
%s\ is\ not\ a\ Long\ value\ Number = 

# at: src/main/java/org/zstack/core/errorcode/ElaborationManagerImpl.java:493
# args: 
input\ args\ 'regex'\ or\ 'category'\ must\ be\ set = 

# at: src/main/java/org/zstack/core/externalservice/ExternalServiceManagerImpl.java:17
# args: service.getName()
service[%s]\ has\ been\ registered = 服务(service)[{0}]已经被注册

# at: src/main/java/org/zstack/core/gc/GarbageCollectorManagerImpl.java:243
# args: vo.getUuid(),vo.getName()
cannot\ trigger\ a\ finished\ GC\ job[uuid\:%s,\ name\:%s] = 无法触发一个完成过的GC任务

# at: src/main/java/org/zstack/core/progress/ProgressApiInterceptor.java:38
# args: msg.getApiId()
parameter\ apiId[%s]\ is\ not\ a\ valid\ uuid. = 参数apiId[{0}]不是一个有效的UUID

# at: src/main/java/org/zstack/core/rest/RESTFacadeImpl.java:517
# args: method.toString().toLowerCase(),url,rsp.getStatusCode(),rsp.getBody()
failed\ to\ %s\ to\ %s,\ status\ code\:\ %s,\ response\ body\:\ %s = 访问{1}时执行{0}方法失败，状态码: {2}，响应体: {3}

# at: src/main/java/org/zstack/core/rest/RESTFacadeImpl.java:512
# args: method.toString().toLowerCase(),url,e.getMessage()
failed\ to\ %s\ to\ %s,\ IO\ Error\:\ %s = 访问{1}时执行{0}方法失败，IO错误: {2}

# at: src/main/java/org/zstack/core/rest/RESTFacadeImpl.java:560
# args: url,finalTimeout
unable\ to\ echo\ %s\ in\ %sms = 无法在{1}ms内返回{0}

# at: src/main/java/org/zstack/core/retry/Retry.java:102
# args: __name__,times,interval
an\ operation[%s]\ fails\ after\ retrying\ %s\ times\ with\ the\ interval\ %s\ seconds = 在重试{1}次间隔时间为{2}后操作[{0}]失败

# at: src/main/java/org/zstack/core/salt/SaltRunner.java:296
# args: stateName,targetIp,retry
failed\ to\ run\ salt\ state[%s]\ on\ system[%s],\ failed\ after\ %s\ retries = 重试{2}次之后，在系统[{1}]上运行加盐状态[{0}]失败

# at: src/main/java/org/zstack/core/salt/SaltSetupMinionJob.java:84
# args: targetIp
scp\ is\ not\ found\ on\ system[%s],\ unable\ to\ setup\ salt = 

# at: src/main/java/org/zstack/core/timeout/ApiTimeoutManagerImpl.java:81
# args: ApiTimeoutGlobalProperty.MINIMAL_TIMEOUT
api\ timeout\ cannot\ be\ set\ smaller\ than\ %s = 

# at: src/main/java/org/zstack/core/webhook/WebhookApiInterceptor.java:28
# args: url
Invalid\ url[%s] = 无效的URL[{0}]

# at: src/main/java/org/zstack/daho/core/DahoApiInterceptor.java:99
# args: 
parameters\ [accountUuid]\ only\ can\ be\ used\ by\ admin\ user! = 参数[accountUuid]必须被admin用户设置

# at: src/main/java/org/zstack/daho/core/DahoApiInterceptor.java:54
# args: msg.getExpirePolicy()
expire\ policy\:\ %s\ is\ not\ valid = 无效的过期策略:{0}

# at: src/main/java/org/zstack/daho/core/DahoApiInterceptor.java:57
# args: msg.getVlan()
vlanId[%s]\ has\ been\ existed! = 

# at: src/main/java/org/zstack/daho/core/DahoSdkImpl.java:129
# args: 
create\ daho\ vll\ task\ failed! = 创建daho vll任务失败

# at: src/main/java/org/zstack/daho/core/DahoSdkImpl.java:170
# args: msg.getAccountUuid()
no\ aliyun\ account\ found\ for\ accountUuid\:\ %s = 找不到当前账户{0}对应的阿里云账户

# at: src/main/java/org/zstack/externalservice/cronjob/CronJobImpl.java:54
# args: 
crond\ is\ not\ running = crond任务未在运行

# at: src/main/java/org/zstack/ha/HaKvmHostSiblingChecker.java:230
# args: struct.getHostUuid(),struct.getHostIp(),errors
hosts\ failed\ to\ port\ scan\ the\ failure\ host[uuid\:%s,\ ip\:%s],\ errors\ are\ %s = 扫描物理机失败[uuid:{0}, ip:{1}]，错误原因是 {2}

# at: src/main/java/org/zstack/ha/HaKvmWorker.java:79
# args: checkers.indexOf(checker) + 1,checkers.size(),checker.getClass().getSimpleName(),s.getMaxTimes() * s.getInterval()
(%d/%d)\ start\ HaHostChecker\ %s\:\ predict\ time\ is\ [%d]\ seconds = 

# at: src/main/java/org/zstack/ha/HaKvmWorker.java:135
# args: self.getName(),self.getUuid()
cannot\ find\ the\ host\ of\ the\ vm[name\:%s,\ uuid\:%s],\ hostUuid\ is\ null = 找不到vm[name:{0}, uuid:{1}]的物理机, 因为hostUuid为null

# at: src/main/java/org/zstack/ha/HaKvmWorker.java:142
# args: 
no\ HaHostChecker\ found,\ cannot\ do\ HA = 找不到HaHostChecker，无法执行HA

# at: src/main/java/org/zstack/ha/HaKvmWorker.java:148
# args: completion.getVmUuid()
can\ not\ ha\ because\ device\ still\ attached\ to\ vm[%s] = 

# at: src/main/java/org/zstack/ha/HaManagementNodeChecker.java:79
# args: 
the\ management\ node\ fails\ to\ scan\ the\ host = 管理节点扫描物理机失败

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:224
# args: newValue
the\ value[%s]\ is\ lesser\ than\ 0 = 值[{0}]比0小

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:405
# args: 
there\ is\ already\ a\ HA\ GC\ job\ for\ the\ VM,\ wait\ it\ to\ run = VM已经有一个HA GC任务，等待运行

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:413
# args: HaGlobalConfig.NEVER_STOP_VM_FAILURE_RETRY_DELAY.value(Long.class)
A\ GC\ job\ is\ submitted\ to\ HA\ the\ VM[retry\ delay\:\ %s\ seconds] = 提交GC任务来高可用VM[重试间隔: {0} 秒]

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:892
# args: 
HA\ is\ successfully\ completed = 

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:900
# args: 
Failed\ to\ HA\ the\ VM = 高可用VM失败

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:801
# args: 
vm\ stopped\ unexpectedly,\ double\ check\ state = 

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:810
# args: vmUuid,hostUuid
cannot\ determine\ VM[%s]\ status\ on\ host[%s],\ try\ to\ start\ it = 

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:1006
# args: 
vm\ state\ is\ stopped,\ try\ to\ start\ it = 

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:827
# args: vmUuid,hostUuid
VM[%s]\ is\ running\ on\ host[%s] = 

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:840
# args: vmUuid,hostUuid
VM[%s]\ is\ paused\ on\ host[%s] = 

# at: src/main/java/org/zstack/ha/HaManagerImpl.java:869
# args: vm.getHypervisorType()
the\ hypervisor[%s]\ does\ not\ support\ VM\ HA = 当前虚拟机监视器(hypervisor)[{0}]不支持VM HA

# at: src/main/java/org/zstack/ha/HostCheckResult.java:49
# args: ratio,threshold,hostUuid,errors
[HA\ Worker]\:\ the\ success\ ratio[%s]\ below\ the\ threshold[%s],\ the\ host[uuid\:%s]\ is\ judged\ as\ dead,\ errors\ are\ %s.\ Start\ HA\ all\ the\ vms\ on\ this\ host\ before = 

# at: src/main/java/org/zstack/ha/HostCheckResult.java:46
# args: ratio,threshold
[HA\ worker]\:\ all\ host\ checkers\ are\ finished\ and\ the\ success\ ratio\ is\ %s\ that\ is\ greater\ than\ the\ threshold[%s];\ no\ HA\ need\ for\ the\ vms\ on\ this\ host\ before.\ Please\ wait\ for\ the\ host\ reconnected = 

# at: src/main/java/org/zstack/ha/NeverStopVmGC.java:78
# args: 
Failed\ to\ start\ the\ NeverStop\ VM = 

# at: src/main/java/org/zstack/ha/NeverStopVmGC.java:81
# args: 
VM\ is\ started\ successfully = 

# at: src/main/java/org/zstack/ha/NeverStopVmGC.java:66
# args: 
VM\ state\ is\ not\ running,\ try\ to\ start\ it = 

# at: src/main/java/org/zstack/header/baremetal/chassis/BatchCreateBaremetalChassisJob.java:60
# args: 
create\ baremetal\ chassis\ from\ config\ file\ job\ do\ not\ support\ cancel = 

# at: src/main/java/org/zstack/header/host/AddKVMHostFromConfigFileLongJob.java:58
# args: 
add\ host\ from\ file\ job\ do\ not\ support\ cancel = 

# at: src/main/java/org/zstack/hybrid/account/HybridAccountApiInterceptor.java:45
# args: type
keyType\ not\ supported\ type\ [%s] = 

# at: src/main/java/org/zstack/hybrid/account/HybridAccountApiInterceptor.java:92
# args: msg.getKey(),accountUuid
key\:\ [%s]\ already\ existed\ by\ accountUuid\:\ [%s] = key: [{0}]已经存在于accountUuid: [{1}]

# at: src/main/java/org/zstack/hybrid/account/HybridAccountApiInterceptor.java:68
# args: msg.getName()
name\:\ [%s]\ already\ existed,\ please\ choose\ another\ name = 

# at: src/main/java/org/zstack/hybrid/datacenter/DataCenterApiInterceptor.java:63
# args: msg.getRegionId(),ak
regionId\ [%s]\ already\ created\ by\ ak\ [%s] = 区域ID[{0}]已经被AccessKey[{1}]创建

# at: src/main/java/org/zstack/hybrid/datacenter/DataCenterApiInterceptor.java:46
# args: type
dcType\ not\ supported\ type\ [%s] = 

# at: src/main/java/org/zstack/hybrid/datacenter/DataCenterManagerImpl.java:96
# args: msg.getUuid()
DataCenter\ [%s]\ is\ still\ in\ sync\ progress,\ please\ wait. = 数据中心[{0}]仍在同步进程中，请稍后

# at: src/main/java/org/zstack/hybrid/identityzone/IdentityZoneApiInterceptor.java:55
# args: msg.getZoneId(),izo.getUuid()
identity\ zone\ [%s]\ already\ existed,\ uuid\ is\:\ %s = 可用区[{0}]已经存在，uuid是{1}

# at: src/main/java/org/zstack/hybrid/identityzone/IdentityZoneApiInterceptor.java:72
# args: type,dvo.getDcType().toString()
type\ [%s]\ is\ not\ matched\ datacenter\ type\ [%s] = 

# at: src/main/java/org/zstack/hybrid/identityzone/IdentityZoneApiInterceptor.java:82
# args: 
either\ dataCenterUuid\ or\ regionId\ should\ be\ set,\ please\ check\ the\ parameters. = 数据中心Uuid和区域Id应该被设置，请检查参数

# at: src/main/java/org/zstack/hybrid/identityzone/IdentityZoneManagerImpl.java:111
# args: msg.getUuid()
IdentityZone\ [%s]\ is\ still\ in\ sync\ progress,\ please\ wait. = 可用区[{0}]仍在同步进程中，请稍后

# at: src/main/java/org/zstack/hybrid/network/HybridEipCascadeExtension.java:88
# args: 
EcsInstance\ must\ be\ running\ or\ stopped\ while\ deleting\ eip\  = 删除弹性IP时云主机必须时允许中或者已停止

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:86
# args: vbri.getUuid(),vbri.getDataCenterUuid(),vrouteri.getUuid(),vrouteri.getDataCenterUuid()
router\ interface\ must\ be\ in\ the\ same\ datacenter,\ but\ ri[%s]\ is\ in\ dc[%s]\ and\ ri[%s]\ is\ in\ dc[%s] = 路由接口必须在相同的数据中心，但是接口[{0}]在数据中心[{1}]而接口[{2}]在数据中心[{3}]

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:96
# args: vrouteri.getUuid(),vrouteri.getStatus()
router\ interface[%s]\ status\ is\ not\ idle,\ it\ is\ %s = 路由接口[{0}]并非闲置状态，当前状态为{1}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:104
# args: vrouteri.getUuid(),vrouteri.getOppositeInterfaceUuid()
router\ interface[%s]\ already\ has\ a\ connection,\ it\ is\ %s = 路由接口[{0}]已经有链接{1}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:112
# args: 
accessPointUuid\ cannot\ be\ null\ if\ the\ router\ interface\ on\ VBR\ type\ router = 当路由接口的类型为VBR路由时，accessPointUuid不能为空

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:186
# args: 
cannot\ delete\ system\ entry = 不能删除系统路由条目

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:192
# args: 
only\ support\ intranet\ rule\ in\ vpc = 在VPC中仅仅支持内网规则

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:197
# args: msg.getCidr()
%s\ is\ not\ a\ valid\ cidr = {0}是一个无效的CIDR

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:207
# args: 
security\ group\ rule\ already\ existed = 安全组已经存在了

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:213
# args: msg.getDstCidrBlock()
dstCidrBlock[%s]\ is\ not\ a\ valid\ cidr = dstCidrBlock[{0}]是一个无效的CIDR

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:242
# args: msg.getNextHopType()
next\ hop\ type\ [%s]\ not\ supported\ create\ route\ entry\ now! = 

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:238
# args: msg.getNextHopUuid()
no\ such\ vpn\ gateway\:\ %s = 没有这样的VPN网关: {0}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:227
# args: rivo.getvRouterType().toString(),msg.getvRouterType()
nexthop\ routerInterface\ belongs\ to\ %s,\ but\ the\ entry\ belongs\ to\ %s = 下一跳路由接口类型是{0}，但是该路由类型是{1}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:220
# args: msg.getNextHopUuid()
no\ such\ ecs\ instance\:\ %s = 没有这样的ESC云主机: {0}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:252
# args: 
virtual\ border\ router\ only\ support\ routerinterface\ as\ next\ hop\ type = 作为下一跳类型，虚拟边界路由只支持路由接口

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:272
# args: msg.getCidrBlock(),vpcCidr
vswitch's\ cidr\ [%s]\ not\ in\ the\ vpc's\ [%s] = 虚拟交换机的CIDR没有在VPC[{1}]中

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:279
# args: old.getUuid()
cidr\ is\ overlap\ by\ another\ vswitch\:\ %s = CIDR和其他的虚拟交换机{0}有重叠

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:292
# args: msg.getCidrBlock()
invalid\ CidrBlock\:\ %s,\ which\ must\ subnet\ in\ '10.0.0.0/8',\ '172.16.0.0/12',\ '192.168.0.0/16' = 无效的CIDR块: {0}，CIDR必须在10.0.0.0/8、172.16.0.0/12和192.168.0.0/16子网内

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:308
# args: msg.getvRouterUuid()
no\ such\ virtual\ router\:\ %s = 没有这个的虚拟路由: {0}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:303
# args: msg.getvRouterUuid()
no\ such\ virtual\ border\ router\:\ %s = 没有这个虚拟边界路由器: {0}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:315
# args: msg.getLocalGatewayIp()
localGateway\ is\ not\ IPv4\:\ %s = 本地网关地址不是IPV4: {0}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:318
# args: msg.getPeerGatewayIp()
peerGateway\ is\ not\ IPv4\:\ %s = 对端网关地址不是IPV4: {0}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:321
# args: msg.getPeeringSubnetMask()
peerGateway\ is\ not\ subnet\ mask\:\ %s = 对端网关地址不是在子网掩码{0}中

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:325
# args: msg.getVlanId()
vlanId\ is\ not\ number\:\ %s = vlanId不是一个数字:{0}

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:335
# args: msg.getEcsUuid(),msg.getEipUuid(),hevo.getAllocateResourceUuid()
couldn't\ attach\ eip\ to\ ecs\:\ [%s]\ ,\ eip\ \:[%s]\ already\ attached\ ecs\:[%s]\  = 不能绑定弹性IP到ECS云主机[{0}]，弹性IP[{1}]已经绑定到ECS云主机[{2}]

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:340
# args: msg.getEcsUuid()
ecs\ [%s]\ already\ has\ public\ ip\ now = ECS云主机[{0}]已经拥有拥有IP

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:346
# args: msg.getEipUuid(),msg.getEcsUuid()
couldn't\ attach\ eip\ [%s]\ to\ ecs\:\ [%s]\ ,\ ecs\ is\ already\ attached = 不能绑定弹性IP[{0}]到ECS云主机[{1}]，ECS云主机已经绑定了弹性IP

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:353
# args: msg.getEipUuid(),msg.getEcsUuid()
eip[%s]\ and\ ecs[%s]\ should\ be\ in\ the\ same\ dataCenter\  = 弹性IP[{0}]和ECS云主机[{1}]应该在同一个数据中心

# at: src/main/java/org/zstack/hybrid/network/HybridNetworkApiInterceptor.java:362
# args: msg.getEipUuid()
couldn't\ detach\ eip\ \:[%s],\ it\ is\ not\ attached\ on\ any\ instance\  = 不能解绑弹性IP[{0}]，因为它没有绑定任何云主机

# at: src/main/java/org/zstack/hybrid/network/vpn/VpcVpnApiInterceptor.java:45
# args: msg.getId()
%s\ is\ not\ a\ valid\ ipv4\ address = {0}是一个无效的IPV4地址

# at: src/main/java/org/zstack/hybrid/network/vpn/VpcVpnApiInterceptor.java:51
# args: 
localCidr\ must\ be\ Cidr! = 本地CIDR必须是CIDR

# at: src/main/java/org/zstack/hybrid/network/vpn/VpcVpnApiInterceptor.java:55
# args: 
remoteCidr\ must\ be\ Cidr! = 远程CIDR必须是CIDR

# at: src/main/java/org/zstack/hybrid/network/vpn/VpcVpnApiInterceptor.java:62
# args: 
localCidr\ and\ remoteCidr\ must\ be\ Cidr! = 本地CIDR和远程CIDR必须是CIDR

# at: src/main/java/org/zstack/hybrid/network/vpn/VpcVpnGatewayCascadeExtension.java:80
# args: gateways.get(0).getUuid()
vpngateway\ [%s]\ existed,\ cannot\ delete\ remote = VPN网关[{0}]已经存在，不能删除远程的

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:214
# args: msg.getName()
wrong\ virtual\ ID[name\:%s],\ not\ existing\ or\ wrong\ password = 错误的virtual ID[名称:{0}], 密码不存在或者密码错误

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:221
# args: 
additional\ authentication\ failed = 附加认证失败

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:268
# args: msg.getProjectName()
project[name\:%s]\ not\ existing = 项目[name:{0}]不存在

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:276
# args: puuid,msg.getProjectName()
no\ account\ found\ for\ project[uuid\:%s,\ name\:%s] = 

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:282
# args: msg.getSession().getUserUuid()
wrong\ virtual\ ID[uuid\:%s],\ not\ existing\ or\ wrong\ password = 错误的virtual ID[uuid:{0}], 密码不存在或者密码错误

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:287
# args: vid.getName()
virtual\ ID[name\:%s]\ is\ disabled = virtual ID[名称:{0}]不可用

# at: src/main/java/org/zstack/iam2/IAM2ManagerImpl.java:293
# args: vid.getName(),msg.getProjectName()
virtual\ ID[name\:%s]\ not\ belonging\ to\ the\ project[name\:%s] = virtual ID[名称:{0}]不属于项目[name:{1}]

# at: src/main/java/org/zstack/iam2/IAM2OrganizationBase.java:108
# args: puuid,self.getUuid()
organization[uuid\:%s]\ is\ parent\ of\ the\ organization[uuid\:%s],\ cannot\ set\ it\ as\ a\ child\ organization = 部门[uuid:{0}]是部门[uuid:{1}]的上级部门，无法被设置为子部门

# at: src/main/java/org/zstack/iam2/IAM2ProjectBase.java:97
# args: self.getUuid(),self.getName(),self.getState(),msg.getClass()
the\ project[uuid\:\ %s,\ name\:%s]\ is\ in\ state\ of\ %s\ which\ disallows\ the\ operation[%s] = 项目[[uuid: {0}, 名称:{1}]]是{2}状态，不允许执行[{3}]操作

# at: src/main/java/org/zstack/iam2/IAM2VirtualIDBase.java:294
# args: 
only\ admin\ and\ the\ virtual\ ID\ itself\ can\ do\ the\ update = 只有admin和virtual ID本身可以执行更新操作

# at: src/main/java/org/zstack/iam2/IAM2VirtualIDBase.java:298
# args: msg.getVirtualIDUuid()
old\ password\ is\ not\ equal\ to\ the\ original\ password,\ cannot\ update\ the\ password\ of\ virtual\ ID[uuid\:%s] = 

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:33
# args: attr.getValue()
attribute\ name\ cannot\ be\ null,\ value[%s] = 属性不能为null，输入值[{0}]

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:37
# args: attr.getName()
attribute\ name[%s]\ exceed\ the\ max\ length\ of\ 2048\ chars = 属性名称[{0}]不能超过2048个字符

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:40
# args: attr.getName(),attr.getValue()
attribute[name\:%s]\ value[%s]\ exceed\ the\ max\ length\ of\ 2048\ chars = 属性[name:{0}] value[{1}]不能超过2048个字符

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:124
# args: 
admin\ is\ a\ reserved\ name,\ please\ use\ another\ name = admin是保留名称，请使用其他名称

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:132
# args: msg.getName()
invalid\ name[%s],\ there\ has\ been\ a\ project\ or\ account\ with\ the\ same\ name = 无效的名称[{0}],已经存在同名的项目或账户

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:147
# args: attrs.get(0).getVirtualIDUuid()
virtual\ ID[uuid\:%s]\ is\ project\ admin\ that\ cannot\ be\ removed\ from\ the\ project = virtual ID[uuid:{0}]是项目管理员，无法被移除

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:158
# args: msg.getUuid()
attribute[uuid\:%s]\ is\ not\ for\ any\ group = 

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:166
# args: msg.getUuid()
attribute[uuid\:%s]\ is\ not\ for\ any\ organization = 

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:174
# args: msg.getUuid()
attribute[uuid\:%s]\ is\ not\ for\ any\ project = 

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:182
# args: msg.getUuid()
attribute[uuid\:%s]\ is\ not\ for\ any\ virtual\ ID = 

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:202
# args: 
retire\ policy\ must\ be\ deleted\ before\ pull\ the\ project\ out\ of\ Retired\ state = 

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:214
# args: state
login\ is\ prohibited\ because\ the\ project\ is\ in\ state\ of\ %s = 

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:228
# args: name
no\ quota[name\:%s]\ found = 

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:252
# args: msg.getUuid()
organization[uuid\:%s]\ is\ a\ Company\ that\ cannot\ have\ parent\ organization = 

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:264
# args: msg.getName()
duplicate\ virtualID\ name[%s] = 

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:282
# args: msg.getName()
duplicate\ project\ name[%s] = 

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:290
# args: msg.getName()
invalid\ project\ name[%s],\ there\ has\ been\ an\ account\ or\ project\ with\ the\ same\ name = 

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:307
# args: uuids
organizations%s\ are\ company\ that\ cannot\ be\ children\ of\ other\ organization = 

# at: src/main/java/org/zstack/iam2/api/IAM2ApiInterceptor.java:370
# args: wrong,msg.getGroupUuid()
virtual\ ids%s\ not\ in\ the\ project\ the\ group[uuid\:%s]\ belongs\ to = 

# at: src/main/java/org/zstack/iam2/attribute/SystemAttributes.java:68
# args: 
attribute[name\:%s]\ is\ a\ system\ attribute\ that\ cannot\ be\ updated = 

# at: src/main/java/org/zstack/iam2/attribute/organization/OrganizationSupervisor.java:32
# args: inv.getValue()
virtual\ ID[uuid\:%s]\ not\ existing = 

# at: src/main/java/org/zstack/iam2/attribute/organization/OrganizationSupervisor.java:37
# args: oinv.getOrganizationUuid()
organization[uuid\:%s]\ already\ has\ a\ supervisor = 

# at: src/main/java/org/zstack/iam2/attribute/project/Retire.java:64
# args: pinv.getUuid(),pinv.getName()
the\ project[uuid\:%s,\ name\:%s]\ already\ has\ a\ retire\ policy = 

# at: src/main/java/org/zstack/iam2/attribute/project/RetirePolicy.java:52
# args: 
invalid\ value,\ no\ 'at',\ 'after'\ or\ 'exceed'\ found = 

# at: src/main/java/org/zstack/iam2/attribute/project/RetirePolicy.java:57
# args: value
invalid\ value,\ %s = 

# at: src/main/java/org/zstack/iam2/attribute/project/RetirePolicy.java:63
# args: ss[0],Means.values()
invalid\ means[%s],\ allowed\ means\ are\ %s = 

# at: src/main/java/org/zstack/iam2/attribute/project/RetirePolicy.java:98
# args: policyValue
invalid\ spending\ value[%s],\ it\ should\ be\ in\ format\ of\ for\ example\ 10.001 = 

# at: src/main/java/org/zstack/iam2/attribute/project/RetirePolicy.java:92
# args: policyValue,Double.MAX_VALUE
invalid\ spending\ value[%s],\ spending\ value\ should\ between\ 0\ and\ %f = 

# at: src/main/java/org/zstack/iam2/attribute/project/RetirePolicy.java:85
# args: policyValue
invalid\ time[%s],\ it\ should\ be\ in\ format\ of\ for\ example\ 10m,\ 1h,\ 2d = 

# at: src/main/java/org/zstack/iam2/attribute/project/RetirePolicy.java:76
# args: policyValue
invalid\ date[%s],\ it\ should\ be\ in\ format\ of\ yyyy-MM-dd\ HH\:mm\:ss = 

# at: src/main/java/org/zstack/iam2/attribute/project/RetirePolicy.java:105
# args: policyValue,dateFormat.format(new Timestamp(System.currentTimeMillis()))
invalid\ date\ or\ time[%s],\ it\ cannot\ be\ before\ current\ time[%s] = 

# at: src/main/java/org/zstack/iam2/attribute/virtualid/AbstractAdminAttribute.java:24
# args: vid,attributeName
virtual\ ID[uuid\:%s]\ already\ has\ admin\ related\ attributes,\ can\ not\ add\ %s = 

# at: src/main/java/org/zstack/iam2/attribute/virtualid/PlatformAdminZoneRelation.java:36
# args: inv.getValue()
cannot\ find\ zone[uuid\:%s] = 

# at: src/main/java/org/zstack/iam2/attribute/virtualid/ProjectAdmin.java:70
# args: inv.getValue()
project[uuid\:%s]\ already\ has\ a\ project\ admin = 

# at: src/main/java/org/zstack/iam2/attribute/virtualid/ProjectAdmin.java:82
# args: inv.getValue()
project[uuid\:%s]\ not\ existing = 

# at: src/main/java/org/zstack/iam2/privilege/admin/IAM2PrivilegeAdminPolicyHelper.java:226
# args: String.join(",", privilegeAdminUuids),msg.getProjectUuid()
can\ not\ add\ privilege\ admin[uuids\:%s]\ to\ project[uuid\:%s] = 

# at: src/main/java/org/zstack/iam2/rbac/IAM2PrivilegeAdminAPIRequestChecker.java:49
# args: rbacEntity.getApiMessage().getSession().getUserUuid()
the\ operation\ is\ not\ permitted\ by\ white\ list\ of\ virtual-id[uuid\:%s] = 

# at: src/main/java/org/zstack/iam2/rbac/IAM2PrivilegeAdminAPIRequestChecker.java:61
# args: rbacEntity.getApiMessage().getSession().getUserUuid()
the\ operation\ is\ denied\ by\ black\ list\ of\ virtual-id[uuid\:%s] = 

# at: src/main/java/org/zstack/iam2/rbac/IAM2SessionAPIRequestChecker.java:28
# args: session.getAccountUuid()
project\ of\ account[uuid\:%s]\ not\ exists = 

# at: src/main/java/org/zstack/iam2/rbac/IAM2SessionAPIRequestChecker.java:37
# args: projectUuid
project[uuid\:%s]\ is\ retired,\ reject\ all\ operations = 

# at: src/main/java/org/zstack/identity/AccountBase.java:304
# args: group.getUuid(),msg.getAccountUuid()
the\ user\ group[uuid\:%s]\ does\ not\ belong\ to\ the\ account[uuid\:%s] = 这个用户组[uuid:{0}]不属于当前账户[uuid:{1}]

# at: src/main/java/org/zstack/identity/AccountBase.java:406
# args: msg.getName(),msg.getIdentityUuid()
cannot\ find\ Quota[name\:\ %s]\ for\ the\ account[uuid\:\ %s] = 无法为当前账户[uuid: {1}]找到Quota

# at: src/main/java/org/zstack/identity/AccountBase.java:485
# args: self.getUuid(),ruuid
the\ account[uuid\:\ %s]\ doesn't\ have\ a\ resource[uuid\:\ %s] = 账户[uuid: {0}]没有资源[uuid: {1}]

# at: src/main/java/org/zstack/identity/AccountBase.java:542
# args: user.getUuid(),msg.getAccountUuid()
the\ user[uuid\:%s]\ does\ not\ belong\ to\ the\ account[uuid\:%s] = 当前用户[uuid:{0}]不属于当前账户[uuid:{1}]

# at: src/main/java/org/zstack/identity/AccountBase.java:547
# args: user.getUuid()
old\ password\ is\ not\ equal\ to\ the\ original\ password,\ cannot\ update\ the\ password\ of\ user[uuid\:%s] = 

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1606
# args: JSONObjectUtil.toJsonString(s)
a\ statement\ must\ have\ effect\ field.\ Invalid\ statement[%s] = 声明必须含有'effect'字段。 无效的声明

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1609
# args: JSONObjectUtil.toJsonString(s)
a\ statement\ must\ have\ action\ field.\ Invalid\ statement[%s] = 声明必须含有'action'字段。 无效的声明

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1612
# args: JSONObjectUtil.toJsonString(s)
a\ statement\ must\ have\ a\ non-empty\ action\ field.\ Invalid\ statement[%s] = 声明必须含有不为空的'action'字段。 无效的声明

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:148
# args: resourceUuid
cannot\ find\ the\ resource[uuid\:%s];\ wrong\ resourceUuid\ or\ the\ resource\ is\ admin\ resource = 无法找到资源[uuid:{0}]: 错误的资源uuid或者资源是管理员资源

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:296
# args: msg.getUserUuid()
the\ user\ specified\ by\ the\ userUuid[%s]\ does\ not\ belong\ to\ the\ current\ account,\ and\ the\ current\ account\ is\ not\ an\ admin\ account,\ so\ it\ has\ no\ permission\ to\ check\ the\ user'spermissions = 当前通过userUuid获得的user不属于当前账户，而且当前账户不是管理员账户

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:969
# args: accountUuid
cannot\ find\ the\ account[uuid\:%s] = 找不到账户[uuid:{0}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1441
# args: 
accountName\ and\ accountUuid\ cannot\ both\ be\ null,\ you\ must\ specify\ at\ least\ one = 账户名和账户Uuid不能同时为空，您必须定义至少一个

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1452
# args: msg.getName(),msg.getAccountUuid()
unable\ to\ create\ a\ group.\ A\ group\ called\ %s\ is\ already\ under\ the\ account[uuid\:%s] = 不能创建用户组，用户组“{0}”已经在账户“{0}”下了

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1462
# args: msg.getName(),msg.getAccountUuid()
unable\ to\ create\ a\ user.\ A\ user\ called\ %s\ is\ already\ under\ the\ account[uuid\:%s] = 不能创建用户，用户“{0}”已经在账户“{0}”下了

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1471
# args: msg.getName()
unable\ to\ create\ an\ account.\ An\ account\ already\ called\ %s = 不能创建账户，“{0}”已经被使用

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1478
# args: 
account\ cannot\ delete\ itself = 账户不能删除自己

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1484
# args: 
cannot\ delete\ builtin\ admin\ account. = 

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1490
# args: 
Only\ admin\ can\ delete\ account. = 只有admin能删除账户

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1498
# args: 
the\ current\ session\ is\ an\ account\ session.\ You\ need\ to\ specify\ the\ field\ 'uuid'\ of\ the\ user\ you\ want\ to\ update = 当前会话是一个账户会话，你需要定义一个'uuid'字段来指定你要更新的用户

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1513
# args: msg.getUuid()
your\ are\ login\ as\ a\ user,\ you\ cannot\ another\ user[uuid\:%s] = 你已经登录为一个用户，不能成为另一个用户[uuid:{0}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1521
# args: 
all\ is\ set\ to\ false,\ accountUuids\ cannot\ be\ null\ or\ empty = all参数被设为false时，账户uuid不能为空

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1529
# args: 
toPublic\ is\ set\ to\ false,\ accountUuids\ cannot\ be\ null\ or\ empty = toPublic参数被设为false时，账户uuid不能为空

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1578
# args: policy.getName(),policy.getUuid(),msg.getSession().getAccountUuid()
policy[name\:\ %s,\ uuid\:\ %s]\ doesn't\ belong\ to\ the\ account[uuid\:\ %s] = 策略[名称: {0}, uuid: {1}]不属于账户[uuid: {2}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1592
# args: user.getName(),user.getUuid(),msg.getSession().getAccountUuid()
user[name\:\ %s,\ uuid\:\ %s]\ doesn't\ belong\ to\ the\ account[uuid\:\ %s] = 用户[名称: {0}, uuid: {1}]不属于账户[uuid: {2}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1596
# args: group.getName(),group.getUuid(),msg.getSession().getAccountUuid()
group[name\:\ %s,\ uuid\:\ %s]\ doesn't\ belong\ to\ the\ account[uuid\:\ %s] = 用户组[名称: {0}, uuid: {1}]不属于账户[uuid: {2}]

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1639
# args: msg.getUuid()
old\ password\ is\ not\ equal\ to\ the\ original\ password,\ cannot\ update\ the\ password\ of\ account[uuid\:\ %s] = 

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1644
# args: 
the\ name\ of\ admin\ account\ cannot\ be\ updated = 不能更改管理员账户名称

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1650
# args: 
only\ admin\ account\ can\ update\ it's\ password = 

# at: src/main/java/org/zstack/identity/AccountManagerImpl.java:1657
# args: account.getUuid(),account.getName(),msg.getUuid()
account[uuid\:\ %s,\ name\:\ %s]\ is\ a\ normal\ account,\ it\ cannot\ reset\ the\ password\ of\ another\ account[uuid\:\ %s] = [uuid: {0}, 名称: {1}]是一个普通账户，不能被其他普通账户重设密码

# at: src/main/java/org/zstack/identity/Session.java:56
# args: 
Login\ sessions\ hit\ limit\ of\ max\ allowed\ concurrent\ login\ sessions = 登录会话数量已经达到最大值

# at: src/main/java/org/zstack/identity/rbac/OperationTargetAPIRequestChecker.java:190
# args: rbacEntity.getApiMessage().getSession().getAccountUuid(),uuid,resourceType.getSimpleName()
permission\ denied,\ the\ account[uuid\:%s]\ is\ not\ the\ owner\ of\ the\ resource[uuid\:%s,\ type\:%s] = 操作错误，账户[uuid:{0}]不是资源[uuid:{1}, type:{2}]的所有者

# at: src/main/java/org/zstack/identity/rbac/OperationTargetAPIRequestChecker.java:210
# args: rbacEntity.getApiMessage().getSession().getAccountUuid(),resourceWithNoAccess,resourceType.getSimpleName()
the\ account[uuid\:%s]\ has\ no\ access\ to\ the\ resources[uuid\:%s,\ type\:%s] = 账户[uuid:{0}]无法使用资源[uuid:{1}, type:{2}]

# at: src/main/java/org/zstack/identity/rbac/RBACAPIRequestChecker.java:90
# args: 
operation\ is\ denied\ by\ default = 无法执行当前操作

# at: src/main/java/org/zstack/identity/rbac/RBACAPIRequestChecker.java:187
# args: p.getName(),p.getUuid()
the\ operation\ is\ denied\ by\ the\ policy[name\:%s\ uuid\:%s] = 

# at: src/main/java/org/zstack/identity/rbac/RBACAPIRequestChecker.java:200
# args: p.getName(),p.getUuid(),fname
the\ operation\ is\ denied\ by\ the\ policy[name\:%s,\ uuid\:%s],\ field[%s]\ is\ not\ permitted\ to\ set = 

# at: src/main/java/org/zstack/identity/rbac/RBACApiInterceptor.java:74
# args: 
cannot\ update\ a\ system\ or\ predefined\ role = 

# at: src/main/java/org/zstack/identity/rbac/RBACApiInterceptor.java:81
# args: 
cannot\ delete\ a\ system\ or\ predefined\ role = 

# at: src/main/java/org/zstack/image/BackupStorageDeleteBitGC.java:35
# args: backupStorageUuid,bsStatus
the\ backup\ storage[uuid\:%s]\ is\ not\ in\ status\ of\ Connected,\ current\ status\ is\ %s = 镜像服务器[uuid:{0}]不是Connected状态，当前状态为{1}

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:88
# args: vol.getUuid(),vol.getStatus()
volume[uuid\:%s]\ is\ not\ Ready,\ it's\ %s = 云盘[uuid:{0}]未Ready，它现在为{1}

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:92
# args: vol.getUuid(),vol.getState()
volume[uuid\:%s]\ is\ not\ Enabled,\ it's\ %s = 云盘[uuid:{0}]未Enabled，它现在为{1}

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:99
# args: vsvo.getUuid(),vsvo.getStatus()
volume\ snapshot[uuid\:%s]\ is\ not\ Ready,\ it's\ %s = 

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:103
# args: vsvo.getUuid(),vsvo.getState()
volume\ snapshot[uuid\:%s]\ is\ not\ Enabled,\ it's\ %s = 

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:174
# args: 
ISO\ cannot\ be\ used\ as\ system\ image = ISO不能被作为一个系统标签

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:180
# args: msg.getFormat()
unknown\ format[%s] = 未知格式[{0}]

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:184
# args: msg.getType()
unsupported\ image\ type[%s] = 不支持的镜像类型[{0}]

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:203
# args: msg.getBackupStorageUuids(),BackupStorageStatus.Connected,BackupStorageState.Enabled
no\ backup\ storage\ specified\ in\ uuids%s\ is\ available\ for\ adding\ this\ image;\ they\ are\ not\ in\ status\ %s\ or\ not\ in\ state\ %s,\ or\ the\ uuid\ is\ invalid\ backup\ storage\ uuid = 镜像服务器uuids{0}不满足添加镜像的条件；它们的状态不同时满足{1}和{2},亦或者是无效的uuid

# at: src/main/java/org/zstack/image/ImageApiInterceptor.java:214
# args: 
url\ must\ starts\ with\ 'file\:///',\ 'http\://',\ 'https\://'，\ 'ftp\://',\ 'sftp\://'\ or\ '/' = url必须以下列格式开头'file:///', 'http://', 'https://'， 'ftp://', 'sftp://' or '/'

# at: src/main/java/org/zstack/image/ImageBase.java:164
# args: self.getUuid(),self.getName()
the\ image[uuid\:%s,\ name\:%s]\ is\ not\ on\ any\ backup\ storage = 镜像[uuid:{0}, 名称:{1}]不在任一镜像服务器上

# at: src/main/java/org/zstack/image/ImageBase.java:174
# args: self.getUuid(),self.getName()
No\ connected\ backup\ storage\ found\ for\ image[uuid\:%s,\ name\:%s] = 在所有 Connected 状态的镜像服务器上都找不到镜像[uuid:{0}, name:{1}]

# at: src/main/java/org/zstack/image/ImageBase.java:362
# args: msg.getImageUuid(),JSONObjectUtil.toJsonString(errors)
detach\ iso[uuid\=%s]\ from\ vm\ failed,\ errors\ are\ %s = 

# at: src/main/java/org/zstack/image/ImageBase.java:668
# args: self.getUuid(),self.getName(),bsUuid
the\ image[uuid\:%s,\ name\:%s]\ is\ not\ on\ the\ backup\ storage[uuid\:%s] = 镜像[uuid:{0}, 名称:{1}]不在镜像服务器[uuid:{2}]上

# at: src/main/java/org/zstack/image/ImageBase.java:610
# args: self.getUuid(),self.getName(),ref.getStatus(),bsUuid
the\ image[uuid\:%s,\ name\:%s]'s\ status[%s]\ is\ not\ Deleted\ on\ the\ backup\ storage[uuid\:%s] = 镜像[uuid:{0}, 名称:{1}]的状态[{2}]在镜像服务器[uuid:{3}]上不是Deleled

# at: src/main/java/org/zstack/image/ImageBase.java:652
# args: self.getUuid(),self.getName()
the\ image[uuid\:%s,\ name\:%s]\ is\ not\ deleted\ on\ any\ backup\ storage = 镜像[uuid:{0}, 名称:{1}]未在任一镜像服务器上被删除

# at: src/main/java/org/zstack/image/ImageBase.java:673
# args: self.getUuid(),self.getName(),bsUuid
the\ image[uuid\:%s,\ name\:%s]\ is\ not\ deleted\ on\ the\ backup\ storage[uuid\:%s] = 镜像[uuid:{0}, 名称:{1}]未在镜像服务器[uuid:{2}]上被删除

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:513
# args: bootModeCount
only\ one\ bootMode\ system\ tag\ is\ allowed,\ but\ %d\ got = 

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:531
# args: bootMode,systemTag
[%s]\ specified\ in\ system\ tag\ [%s]\ is\ not\ a\ valid\ boot\ mode = 

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:1010
# args: 
upload\ session\ expired = 上传session失效了

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:1501
# args: msgData.getBackupStorageUuids(),JSONObjectUtil.toJsonString(errs)
unable\ to\ allocate\ backup\ storage\ specified\ by\ uuids%s,\ list\ errors\ are\:\ %s = 不能根据[uuids:{0}]分配镜像服务器，错误清单为: {1}

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:1612
# args: msgData.getRootVolumeUuid()
failed\ to\ create\ image\ from\ root\ volume[uuid\:%s]\ on\ all\ backup\ storage,\ see\ cause\ for\ one\ of\ errors = 在所有镜像服务器上从根云盘[uuid:{0}]创建镜像失败，查看错误原因

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:1879
# args: msgData.getBackupStorageUuids(),JSONObjectUtil.toJsonString(errs)
failed\ to\ allocate\ all\ backup\ storage[uuid\:%s],\ a\ list\ of\ error\:\ %s = 镜像服务器[uuid:{0}]分配失败，错误清单:{1}

# at: src/main/java/org/zstack/image/ImageManagerImpl.java:1980
# args: msgData.getVolumeUuid(),msgData.getBackupStorageUuids()
failed\ to\ create\ data\ volume\ template\ from\ volume[uuid\:%s]\ on\ all\ backup\ storage%s.\ See\ cause\ for\ one\ of\ errors = 在所有镜像服务器[uuid:{1}]上创建云盘[uuid:{0}]的云盘模版失败，查看错误原因

# at: src/main/java/org/zstack/imagereplicator/ImageReplicatorImpl.java:256
# args: targetBsUuid
target\ backup\ storage[uuid\:%s]\ became\ unavailable = 

# at: src/main/java/org/zstack/imagereplicator/ReplicationGroupApiInterceptor.java:30
# args: String.join(",", msg.getBackupStorageUuids()),msg.getReplicationGroupUuid()
One\ or\ more\ backup\ storage[uuids\:%s]\ has\ been\ added\ to\ replication\ group[uuid\:%s] = 

# at: src/main/java/org/zstack/imagereplicator/ReplicationGroupApiInterceptor.java:41
# args: bsUuid
Backup\ storage[uuids\:%s]\ is\ not\ of\ type\ ImageStore = 

# at: src/main/java/org/zstack/imagereplicator/ReplicationGroupApiInterceptor.java:51
# args: bsUuid
Backup\ storage[uuids\:%s]\ is\ not\ attached\ to\ any\ Zone = 

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:63
# args: l3NetworkUuid
Network\ [uuid\:\ %s]\ does't\ not\ have\ IPsec\ service = 网络[uuid: {0}]没有IPsec服务

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:73
# args: rcidr,tempCidr
the\ remote\ CIDR[%s]\ and\ remote\ CIDR[%s]\ are\ overlaped = 远程的CIDR[{0}]和远端CIDR[{1}]存在覆盖

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:97
# args: lcidr,tempCidr
the\ CIDR[%s]\ of\ local\ router\ and\ remote\ CIDR[%s]\ are\ overlaped = 本地路由的CIDR[{0}]和远端CIDR存在覆盖

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:110
# args: 
all\ networks\ in\ same\ IPsecConnection\ should\ be\ same\ type = 在相同的IPsec连接中的所有连接应该是相同类型

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:116
# args: L3NetworkConstant.L3_BASIC_NETWORK_TYPE
IPsecConnection\ can\ ONLY\ have\ 1\ network\ for\ %s = IPsec连接只能有一个网络服务

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:127
# args: l3Uuid
L3Network\ [uuid\:\ %s]\ has\ not\ been\ attached\ to\ vpc\ router = 三层网络[uuid:{0}]还没有绑定VPC路由

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:133
# args: 
all\ networks\ in\ same\ IPsecConnection\ must\ be\ attached\ to\ same\ VPC\ router = 在相同的IPsec连接中的所有网络必须绑定在相同的VPC路由

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:150
# args: tuples.get(0).get(0, String.class),tuples.get(0).get(1, String.class)
there\ already\ have\ ipsec\ connection[uuid\:%s,\ name\:%s]\ with\ the\ same\ vrouter\ and\ peerAddress = 这里已经有相同云路由和对端地址的IPsec连接[uuid:{0}, name:{1}]

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:174
# args: msg.getVipUuid(),useForList.toString()
the\ vip[uuid\:%s]\ has\ been\ used\ for\ %s = 虚拟IP[uuid:{0}]已经用作网络服务 {1}

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:179
# args: msg.getPeerAddress()
the\ peerAddress[%s]\ cannot\ be\ the\ same\ to\ the\ VIP\ address = 对端地址[{0}]不能和虚拟IP地址相同

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:183
# args: msg.getPeerAddress()
the\ peerAddress[%s]\ is\ not\ an\ IPv4\ address = 对端地址[{0}]不是一个IPv4地址

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:195
# args: 
the\ authKey\ cannot\ contain\ white\ space\ and\ special\ characters\ of\ '\"`\\ = 验证码不能包含空格和以下字符:'\"`\\

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:229
# args: 
must\ include\ l3\ networks\ in\ APIAttachL3NetworksToIPsecConnectionMsg = 参数中缺少三层网络的uuid

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:236
# args: l3NetworkUuid
L3\ network\ [%s]\ is\ not\ vpc\ network,\ can\ not\ be\ attached\ or\ detached\ to\ ipsec = 三层网络[{0}]不是VPC网络，不能绑定或解绑IPsec

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:217
# args: l3NetworkUuid,msg.getIPsecConnectionUuid()
L3\ network\ [%s]\ can\ not\ be\ attached\ to\ ipsec\ [uuid\ \:%s]twice = 三层网络[{0}]不能绑定IPsec[uuid :{1}]两次

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:240
# args: l3NetworkUuid,msg.getIPsecConnectionUuid()
L3\ network\ [%s]\ is\ not\ be\ attached\ to\ ipsec\ [uuid\ \:%s] = 三层网络[{0}]不能绑定IPsec[uuid :{1}]

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:250
# args: cidr,msg.getIPsecConnectionUuid()
Cidr\ [%s]\ is\ already\ in\ the\ Cidrs\ of\ ipsec\ [uuid\ \:%s] = CIDR[{0}]已经在IPsec[uuid :{1}]的CIDR中

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:264
# args: cidr,msg.getIPsecConnectionUuid()
Cidr\ [%s]\ is\ not\ in\ Cidrs\ of\ ipsec\ [uuid\ \:%s] = CIDR[{0}]没有在IPsec[uuid :{1}]的CIDR中

# at: src/main/java/org/zstack/ipsec/IPsecApiInterceptor.java:272
# args: msg.getUuid()
can\ not\ change\ state\ because\ ipsec\ [uuid\:%s]\ status\ is\ not\ ready = 不能修改IPsec的状态，因为IPsec的状态没有准备

# at: src/main/java/org/zstack/ipsec/IPsecManagerImpl.java:129
# args: msg.getIPsecConnectionUuid()
cannot\ find\ the\ IPsecconnection[uuid\:%s],\ it\ may\ have\ been\ deleted = 未找到IPsec连接[uuid:{0}],它可能会被删除了

# at: src/main/java/org/zstack/ipsec/IPsecManagerImpl.java:333
# args: Long.toString(range2.getStart()),Long.toString(range2.getEnd()),Long.toString(cur.getStart()),Long.toString(cur.getEnd()),msg.getVipUuid()
Current\ port\ range[%s,\ %s]\ is\ conflicted\ with\ used\ port\ range\ [%s,\ %s]\ with\ vip[uuid\:\ %s]\ protocol\:\ UDP = 当前的端口范围以UDP使用的端口范围冲突了

# at: src/main/java/org/zstack/ipsec/IPsecManagerImpl.java:366
# args: cidr,l3Inv.getUuid(),uuid,rCidr
cidr[%s]\ of\ attached\ L3Network\ [uuid\:%s]\ is\ overlapped\ with\ ipsec\ [uuid\:%s]\ remote\ cidr[%s] = 已绑定在三层网络[uuid:{1}]的CIDR与IPSec[uuid:{2}]远程CIDR存在重叠

# at: src/main/java/org/zstack/ipsec/vyos/VyosIPsecBackend.java:279
# args: 
vyos\ doesn't\ support\ aes-192\ as\ IkeEncryptionAlgorithm,\ available\ options\ aes-128,\ aes-256,\ 3des = vyos不支持aes-192作为密钥交换加密算法，可用选择为aes-128, aes-256, 3des

# at: src/main/java/org/zstack/ipsec/vyos/VyosIPsecBackend.java:285
# args: 
vyos\ doesn't\ support\ aes-192\ as\ PolicyEncryptionAlgorithm,\ available\ options\ aes-128,\ aes-256,\ 3des = vyos不支持aes-192作为加密算法协议，可用选择为aes-128, aes-256, 3des

# at: src/main/java/org/zstack/ipsec/vyos/VyosIPsecBackend.java:291
# args: msg.getIkeDhGroup()
vyos\ doesn't\ support\ %d\ as\ Ike\ DhGroup\  = vyos不支持[{0}]作为Ike DhGroup

# at: src/main/java/org/zstack/kvm/KVMApiInterceptor.java:37
# args: msg.getManagementIp()
there\ has\ been\ a\ kvm\ host\ having\ management\ ip[%s] = 已经存在一个拥有管理节点IP[{0}]的物理机

# at: src/main/java/org/zstack/kvm/KVMConnectExtensionForL2Network.java:127
# args: l2.getType()
KVMConnectExtensionForL2Network\ wont's\ support\ L2Network[type\:%s] = 物理机二层网络连接插件不支持二层网络[类型:{0}]

# at: src/main/java/org/zstack/kvm/KVMConsoleHypervisorBackend.java:68
# args: rsp.getPort(),vm.getUuid()
unexpected\ VNC\ port\ number[%d]\ for\ VM\ [uuid\:%s] = 

# at: src/main/java/org/zstack/kvm/KVMHost.java:618
# args: self.getManagementIp(),getSelf().getUsername(),getSelf().getPort(),result.getExitErrorMessage()
unable\ to\ connect\ to\ KVM[ip\:%s,\ username\:%s,\ sshPort\:%d\ ]\ to\ do\ DNS\ check,\ please\ check\ if\ username/password\ is\ wrong;\ %s = 无法连接物理机[ip:{0}, 用户名:{1}, ssh端口:{2} ]做DNS检查，请检查用户名密码是否正确；{3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:660
# args: self.getUuid(),self.getStatus()
the\ host[uuid\:%s,\ status\:%s]\ is\ not\ Connected = 物理机[uuid:{0}, 状态:{1}]不是Connected状态

# at: src/main/java/org/zstack/kvm/KVMHost.java:930
# args: volume.getUuid(),state
cannot\ do\ volume\ snapshot\ merge\ when\ vm[uuid\:%s]\ is\ in\ state\ of\ %s.\ The\ operation\ is\ only\ allowed\ when\ vm\ is\ Running\ or\ Stopped = 当云主机[uuid:{0}]处于{1}状态的时候不能做云盘快照合并。此操作只能在云主机处在Running和Stopped状态时进行

# at: src/main/java/org/zstack/kvm/KVMHost.java:937
# args: KVMConstant.MIN_LIBVIRT_LIVE_BLOCK_COMMIT_VERSION,libvirtVersion
live\ volume\ snapshot\ merge\ needs\ libvirt\ version\ greater\ than\ %s,\ current\ libvirt\ version\ is\ %s.\ Please\ stop\ vm\ and\ redo\ the\ operation\ or\ detach\ the\ volume\ if\ it's\ data\ volume = 实时云盘快照合并需要libvirt版本高于{0}，现在libvirt版本为{1}。请停止云主机后重试或卸载云盘（仅当为数据云盘时）

# at: src/main/java/org/zstack/kvm/KVMHost.java:1026
# args: msg.getVmUuid(),vmState
vm[uuid\:%s]\ is\ not\ Running\ or\ Stopped,\ current\ state[%s] = 云主机[uuid:{0}]未处在Running或Stopped状态, 现在状态为[{1}]

# at: src/main/java/org/zstack/kvm/KVMHost.java:1378
# args: msg.getVmInstanceUuid(),self.getUuid(),self.getManagementIp(),ret.getError()
failed\ to\ update\ nic[vm\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],because\ %s = 

# at: src/main/java/org/zstack/kvm/KVMHost.java:1425
# args: msg.getNicInventory().getUuid(),msg.getNicInventory().getVmInstanceUuid(),self.getUuid(),self.getManagementIp(),ret.getError()
failed\ to\ attach\ nic[uuid\:%s,\ vm\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],because\ %s = 在物理机[uuid:{3},IP:{3}]上加载网卡[uuid:{0},云主机:{1}]失败，因为:{4}

# at: src/main/java/org/zstack/kvm/KVMHost.java:1472
# args: vol.getUuid(),vol.getInstallPath(),vm.getUuid(),vm.getName(),getSelf().getUuid(),getSelf().getManagementIp(),ret.getError()
failed\ to\ detach\ data\ volume[uuid\:%s,\ installPath\:%s]\ from\ vm[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = 无法在KVM物理机[uuid:{4}, ip:{5}]上为云主机[uuid:{2}, name:{3}]卸载数据云盘[uuid:{0}, installPath:{1}]，因为: {6}

# at: src/main/java/org/zstack/kvm/KVMHost.java:1559
# args: vol.getUuid(),vol.getInstallPath(),vm.getUuid(),vm.getName(),getSelf().getUuid(),getSelf().getManagementIp(),ret.getError()
failed\ to\ attach\ data\ volume[uuid\:%s,\ installPath\:%s]\ to\ vm[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = 无法在KVM物理机[uuid:{4}, ip:{5}]上为云主机[uuid:{2}, name:{3}]挂载数据云盘[uuid:{0}, installPath:{1}]，因为: {6}

# at: src/main/java/org/zstack/kvm/KVMHost.java:1599
# args: vminv.getUuid(),vminv.getName(),self.getUuid(),self.getManagementIp(),e.getMessage()
failed\ to\ destroy\ vm[uuid\:%s\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = 无法在物理机[uuid:{2}, ip:{3}]上删除云主机[uuid:{0} name:{1}]，原因: {4}

# at: src/main/java/org/zstack/kvm/KVMHost.java:1726
# args: vminv.getUuid(),vminv.getName(),self.getUuid(),self.getManagementIp(),e.getMessage()
failed\ to\ stop\ vm[uuid\:%s\ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = 在物理机[uuid:{2}, ip:{3}]上停止云主机[uuid:{0} 名称:{1}]失败，因为:{4}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2166
# args: msg.getPhysicalInterface(),context.getInventory().getUuid(),context.getInventory().getManagementIp()
failed\ to\ check\ physical\ network\ interfaces[names\ \:\ %s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s] = 

# at: src/main/java/org/zstack/kvm/KVMHost.java:2229
# args: self.getUuid(),ret.getHostUuid()
detected\ abnormal\ status[host\ uuid\ change,\ expected\:\ %s\ but\:\ %s]\ of\ kvmagent,it's\ mainly\ caused\ by\ kvmagent\ restarts\ behind\ zstack\ management\ server.\ Report\ this\ to\ ping\ task,\ it\ will\ issue\ a\ reconnect\ soon = 监测到kvmagent异常的状态[host uuid改变，期望: {0}, 实际: {1}], 这很有可能是kvmagent重启导致的, 报告这个情况给ping, 它会触发重连

# at: src/main/java/org/zstack/kvm/KVMHost.java:2352
# args: self.getUuid(),self.getManagementIp(),connectPath,rsp.getError()
unable\ to\ connect\ to\ kvm\ host[uuid\:%s,\ ip\:%s,\ url\:%s],\ because\ %s = 连接物理机[uuid:{0}, ip:{1}，url:{2}]失败，因为:{3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2408
# args: 
host\ can\ not\ access\ any\ primary\ storage,\ please\ check\ network = 物理机无法访问任何主存储，请检查网络

# at: src/main/java/org/zstack/kvm/KVMHost.java:2556
# args: getSelf().getPort(),KVMGlobalConfig.TEST_SSH_PORT_ON_OPEN_TIMEOUT.value(Long.class)
the\ host'\ ssh\ port[%s]\ not\ open\ after\ %s\ seconds,\ connect\ timeout = 物理机的ssh端口[{0}]在{1}秒后仍未开启，连接超时

# at: src/main/java/org/zstack/kvm/KVMHost.java:2611
# args: checkList
failed\ to\ ping\ all\ DNS/IP\ in\ %s;\ please\ check\ /etc/resolv.conf\ to\ make\ sure\ your\ host\ is\ able\ to\ reach\ public\ internet = 在{0}中的所有DNS/IP都ping失败了，请检查 /etc/resolv.conf 来确保你的主机能连接到公网

# at: src/main/java/org/zstack/kvm/KVMHost.java:2609
# args: self.getManagementIp(),getSelf().getUsername(),getSelf().getPort(),ret.getExitErrorMessage()
unable\ to\ connect\ to\ KVM[ip\:%s,\ username\:%s,\ sshPort\:\ %d,\ ]\ to\ do\ DNS\ check,\ please\ check\ if\ username/password\ is\ wrong;\ %s = 无法连接物理机[ip:{0}, 用户名:{1}, ssh端口:{2} ]做DNS检查，请检查用户名密码是否正确；{3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2637
# args: self.getManagementIp(),restf.getHostName(),ret.getStderr(),ret.getExitErrorMessage()
the\ KVM\ host[ip\:%s]\ cannot\ access\ the\ management\ node's\ callback\ url.\ It\ seems\ that\ the\ KVM\ host\ cannot\ reach\ the\ management\ IP[%s].\ %s\ %s = 物理机[ip:{0}] 不能连接到管理节点 。 看起来是这个物理机无法到达管理节点的IP [{1}]. {2} {3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2634
# args: self.getManagementIp(),getSelf().getUsername(),getSelf().getPort(),ret.getExitErrorMessage()
unable\ to\ connect\ to\ KVM[ip\:%s,\ username\:%s,\ sshPort\:%d]\ to\ check\ the\ management\ node\ connectivity,please\ check\ if\ username/password\ is\ wrong;\ %s = 不能连接到物理机[ip:{0}, username:{1}, sshPort:{2}] 去检查与管理节点是否连通  ,请检查您的用户名或者密码是否有误; {3}

# at: src/main/java/org/zstack/kvm/KVMHost.java:2831
# args: 
cannot\ find\ either\ 'vmx'\ or\ 'svm'\ in\ /proc/cpuinfo,\ please\ make\ sure\ you\ have\ enabled\ virtualization\ in\ your\ BIOS\ setting = 不能发现以下任意一个  'vmx' or 'svm' 在路径 /proc/cpuinfo 里, 请检查你是否在你的BIOS设置里开启了virtualization选项

# at: src/main/java/org/zstack/kvm/KVMHost.java:2490
# args: self.getUuid(),self.getClusterUuid()
host\ [uuid\:%s]\ cannot\ be\ added\ to\ cluster\ [uuid\:%s]\ because\ qemu/libvirt\ version\ does\ not\ match = 物理机[uuid:{0}]不能添加到集群[uuid:{1}]中，因为qemu/libvirt不匹配

# at: src/main/java/org/zstack/kvm/KVMHost.java:2511
# args: self.getUuid(),self.getClusterUuid()
host\ [uuid\:%s]\ cannot\ be\ added\ to\ cluster\ [uuid\:%s]\ because\ cpu\ model\ name\ does\ not\ match = 物理机[uuid:{0}]无法被添加到集群[uuid:{1}]因为cpu型号不一致

# at: src/main/java/org/zstack/kvm/KVMHost.java:2991
# args: 
host\ is\ not\ in\ the\ connected\ status,\ cannot\ update\ os = 物理机当前并不是已连接状态，不能升级操作系统

# at: src/main/java/org/zstack/kvm/KVMHost.java:2989
# args: 
host\ is\ in\ the\ premaintenance\ state,\ cannot\ update\ os = 物理机正处于预维护状态，不能升级操作系统

# at: src/main/java/org/zstack/kvm/KVMHostAllocatorFilterExtensionPoint.java:63
# args: 
cannot\ adapt\ version\ for\ the\ bellow\ rpm\:\ livirt\ /\ qemu\ /\ cpumodel = 源和目的之间的以下组件版本不兼容：livirt、qemu、cpumodel

# at: src/main/java/org/zstack/kvm/KVMHostCapacityExtension.java:53
# args: host.getUuid(),rsp.getTotalMemory(),SizeUtils.sizeStringToBytes(KVMGlobalConfig.RESERVED_MEMORY_CAPACITY.value())
The\ host[uuid\:%s]'s\ available\ memory\ capacity[%s]\ is\ lower\ than\ the\ reserved\ capacity[%s] = 物理机[uuid:{0}]的可用内存[{1}]少于保留内存[{2}]

# at: src/main/java/org/zstack/kvm/KVMHostFactory.java:105
# args: e.getMessage()
fail\ to\ load\ host\ info\ from\ file.\ because\n%s = 

# at: src/main/java/org/zstack/kvm/KVMHostFactory.java:294
# args: str.toString()
there\ are\ still\ hosts\ not\ have\ the\ same\ cpu\ model,\ details\:\ %s = 仍存在host有不同的cpu模型，详细信息：{0}

# at: src/main/java/org/zstack/kvm/KVMHostFactory.java:315
# args: hostUuid
host[uuid\:%s]\ does\ not\ have\ cpu\ model\ information,\ you\ can\ reconnect\ the\ host\ to\ fix\ it = 物理机[uuid:{0}]无cpu模型信息，你可以尝试重连来解决这个问题

# at: src/main/java/org/zstack/kvm/KVMRealizeL2NoVlanNetworkBackend.java:69
# args: cmd.getBridgeName(),l2Network.getUuid(),l2Network.getType(),hostUuid,rsp.getError()
failed\ to\ create\ bridge[%s]\ for\ l2Network[uuid\:%s,\ type\:%s]\ on\ kvm\ host[uuid\:%s],\ because\ %s = 在物理机[uuid:{3}]上为L2网络[uuid:{1}, type:{2}]创建网桥[{0}]失败，原因: {4}

# at: src/main/java/org/zstack/kvm/KVMRealizeL2NoVlanNetworkBackend.java:119
# args: cmd.getBridgeName(),l2Network.getUuid(),l2Network.getName(),hostUuid,rsp.getError()
failed\ to\ check\ bridge[%s]\ for\ l2NoVlanNetwork[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:\ %s],\ %s = 在L2网络[uuid:{1}中检查网桥[{0}]失败，名字为[{2}]在物理机t[uuid: {3}]上, {4}

# at: src/main/java/org/zstack/kvm/KVMRealizeL2VlanNetworkBackend.java:64
# args: cmd.getBridgeName(),l2Network.getUuid(),l2Network.getType(),l2vlan.getVlan(),hostUuid,rsp.getError()
failed\ to\ create\ bridge[%s]\ for\ l2Network[uuid\:%s,\ type\:%s,\ vlan\:%s]\ on\ kvm\ host[uuid\:%s],\ because\ %s = 创建L2网络[uuid:{1}中的网桥[{0}]失败 , 类型为: {2}, vlan:{3}] 在物理机[uuid:{4}]上, 原因:  {5}

# at: src/main/java/org/zstack/kvm/KVMRealizeL2VlanNetworkBackend.java:115
# args: cmd.getBridgeName(),l2vlan.getUuid(),l2vlan.getName(),hostUuid,rsp.getError()
failed\ to\ check\ bridge[%s]\ for\ l2VlanNetwork[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:%s],\ %s = 检查在物理机[uuid:{3}]上L2网络[uuid:{1}, name:{2}]中的网桥[{0}]失败, {4}

# at: src/main/java/org/zstack/kvm/KVMSecurityGroupBackend.java:110
# args: hto.getHostUuid(),rsp.getError()
failed\ to\ apply\ rules\ of\ security\ group\ rules\ to\ kvm\ host[uuid\:%s],\ because\ %s = 不能应用安全组规则在物理机t[uuid:{0}]上, 因为 {1}

# at: src/main/java/org/zstack/kvm/KVMSecurityGroupBackend.java:152
# args: hostUuid,rsp.getError()
failed\ to\ check\ default\ rules\ of\ security\ group\ on\ kvm\ host[uuid\:%s],\ because\ %s = 在host[uuid:{0}]上检查默认安全组规则失败

# at: src/main/java/org/zstack/kvm/KvmVmSyncPingTask.java:161
# args: host.getUuid(),host.getManagementIp(),ret.getError()
unable\ to\ do\ vm\ sync\ on\ host[uuid\:%s,\ ip\:%s]\ because\ %s = 不能在物理机[uuid:{0}, ip:{1}]上执行云主机状态同步操作，因为{2}

# at: src/main/java/org/zstack/ldap/LdapApiInterceptor.java:115
# args: type,LdapConstant.OpenLdap.TYPE,LdapConstant.WindowsAD.TYPE
Wrong\ LdapServerType[%s],\ valid\ values\:\ [%,%s] = 错误的LDAP服务类型[{0}]，有效的值: [%,{1}]

# at: src/main/java/org/zstack/ldap/LdapApiInterceptor.java:122
# args: 
There\ is\ no\ ldap\ server\ in\ the\ system,\ Please\ add\ a\ ldap\ server\ first. = 在系统中没有LDAP服务，请先添加一个LDAP服务

# at: src/main/java/org/zstack/ldap/LdapApiInterceptor.java:140
# args: 
Cannot\ connect\ to\ LDAP\ server,\ Invalid\ Credentials,\ please\ checkout\ User\ DN\ and\ password = 

# at: src/main/java/org/zstack/ldap/LdapApiInterceptor.java:143
# args: 
Cannot\ connect\ to\ LDAP\ server,\ communication\ false,\ please\ checkout\ IP,\ port\ and\ Base\ DN = 

# at: src/main/java/org/zstack/ldap/LdapApiInterceptor.java:146
# args: e.toString()
Cannot\ connect\ to\ LDAP\ server,\ %s = 不能连接LDAP服务，{0}

# at: src/main/java/org/zstack/ldap/LdapManagerImpl.java:397
# args: vo.getAccountUuid()
Account[uuid\:%s]\ Not\ Found!!! = 

# at: src/main/java/org/zstack/ldap/LdapManagerImpl.java:639
# args: filter,e.toString()
query\ ldap\ entry[filter\:\ %s]\ fail,\ %s = 查询LDAP条目[filter: {0}]失败，{1}

# at: src/main/java/org/zstack/ldap/LdapManagerImpl.java:615
# args: e.toString()
query\ ldap\ entry\ fail,\ %s = 查询LDAP条目失败，{0}

# at: src/main/java/org/zstack/license/LicenseChecker.java:119
# args: 
Parse\ license\ error,\n1.\ check\ your\ private\ key\ and\ application\ code\ is\ correct\n2.\ check\ your\ license\ is\ not\ corrupted\n3.\ use\ zstack-ctl\ clear_license\ to\ clear\ your\ licenses\ and\ try\ to\ reinstall\n = 

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:203
# args: e.getMessage()
Decode\ fail\ because\ %s = 解码失败，因为{0}

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:200
# args: bytes.length
Unexpected\ decoded\ license\ file\ length\:\ %d = 

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:753
# args: kvmHostNum - miniHostNum
Unexpected\ number\ (%d)\ of\ hosts\ found = 

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:1018
# args: info.isCpuNumEnabled() ? "CPU sockets" : "host"
unexpected\ license\ policy\:\ %s\ based. = 

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:1048
# args: info.getProdInfo(),info.getCpuNum()
Addon[%s]\ licensed\ %d\ CPU\ sockets,\ but\ platform\ is\ licensed\ with\ host = 

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:1043
# args: info.getProdInfo(),info.getHostNum()
Addon[%s]\ licensed\ %d\ hosts,\ but\ platform\ is\ licensed\ with\ CPU\ socket = 

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:1333
# args: 
Add-on\ license\ is\ not\ supported\ when\ license\ type\ is\ Community = 

# at: src/main/java/org/zstack/license/LicenseManagerImpl.java:1507
# args: 
License\ expired = 

# at: src/main/java/org/zstack/loginControl/LoginControlManagerImpl.java:198
# args: results.size()
Consult\ result\ expect\ to\ be\ 1,\ but\ actually\ %s = 查询结果期望是1，但是实际上是{0}

# at: src/main/java/org/zstack/loginControl/LoginControlManagerImpl.java:245
# args: 
Wrong\ verify\ code = 错误的验证码

# at: src/main/java/org/zstack/loginControl/LoginControlManagerImpl.java:318
# args: msg.getCaptchaUuid(),msg.getResourceName()
can\ not\ get\ suitable\ captcha\ with[uuid\:%s],\ related\ to\ resourceName[uuid\:%s] = 找不到和名称[uuid:{1}]对应的验证码[uuid:{0}]

# at: src/main/java/org/zstack/longjob/LongJobApiInterceptor.java:69
# args: msg.getJobName()
%s\ is\ not\ an\ API = {0}不是一个API

# at: src/main/java/org/zstack/longjob/LongJobApiInterceptor.java:127
# args: 
cannot\ cancel\ longjob\ that\ is\ succeeded = 不能取消已经成功的longjob

# at: src/main/java/org/zstack/longjob/LongJobApiInterceptor.java:130
# args: 
cannot\ cancel\ longjob\ that\ is\ already\ canceled = 不能取消已经准备取消的longjob

# at: src/main/java/org/zstack/longjob/LongJobApiInterceptor.java:133
# args: 
cannot\ cancel\ longjob\ that\ is\ failed = 不能取消已经失败的longjob

# at: src/main/java/org/zstack/longjob/LongJobApiInterceptor.java:144
# args: 
delete\ longjob\ only\ when\ it's\ succeeded,\ canceled,\ or\ failed = 只能删除已经成功、取消、失败的longjob

# at: src/main/java/org/zstack/longjob/LongJobApiInterceptor.java:155
# args: 
rerun\ longjob\ only\ when\ it's\ succeeded,\ canceled,\ or\ failed = 

# at: src/main/java/org/zstack/longjob/LongJobFactoryImpl.java:31
# args: jobName
%s\ has\ no\ corresponding\ longjob = {0}没有与之对应的longjob

# at: src/main/java/org/zstack/mediator/ApiValidator.java:109
# args: l3NetworkUuid,vmNicVO.getL3NetworkUuid()
unable\ to\ attach\ a\ L3\ network.\ The\ cidr\ of\ l3[%s]\ to\ attach\ overlapped\ with\ l3[%s]\ already\ attached\ to\ vm = 不能绑定这个三层网络。这个虚拟机上已经绑定的三层网络[{1}]和这个三层网络[{0}]的CIDR存在重叠

# at: src/main/java/org/zstack/mediator/ApiValidator.java:141
# args: vm.getName(),vm.getUuid(),StringUtils.join(pfStr, ",")
the\ vm[name\:%s,\ uuid\:%s]\ already\ has\ some\ port\ forwarding\ rules%s\ attached = 云主机[name:{0}, uuid:{1}] 已经设置了一些端口转发规则{2}

# at: src/main/java/org/zstack/mediator/ApiValidator.java:162
# args: vm.getName(),vm.getUuid(),StringUtils.join(eipStr, ",")
the\ vm[name\:%s,\ uuid\:%s]\ already\ has\ some\ EIPs%s\ attached = 云主机[name:{0}, uuid:{1}] 已经配置了弹性IP{2}

# at: src/main/java/org/zstack/mediator/ApiValidator.java:177
# args: msg.getVipUuid(),useForList.toString()
the\ vip[uuid\:%s]\ already\ has\ bound\ to\ other\ service[%s] = 该虚拟IP[uuid:{0}]已经绑定了其他服务

# at: src/main/java/org/zstack/mediator/ApiValidator.java:213
# args: Long.toString(range.getStart()),Long.toString(range.getEnd()),Long.toString(cur.getStart()),Long.toString(cur.getEnd()),vipUuid,protocol
Current\ port\ range[%s,\ %s]\ is\ conflicted\ with\ used\ port\ range\ [%s,\ %s]\ with\ vip[uuid\:\ %s]\ protocol\:\ %s\  = 现在的端口范围[{0}, {1}]和虚拟IP使用的端口范围[{2}, {3}]

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:733
# args: l3Uuid,systemTag
L3\ network[uuid\:%s]\ not\ found.\ Please\ correct\ your\ system\ tag[%s]\ of\ static\ IP = 找不到L3网络[uuid:0]。请确认静态IP的系统标签

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:277
# args: supportSharedVolumePrimaryStorage,psType
for\ shareable\ volume,\ the\ only\ supported\ primary\ storage\ type\ is\ %s,\ current\ is\ %s = 共享云盘仅支持在主存储类型为{0}的主存储上使用，当前的类型为{1}

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:695
# args: bandwidth,Long.MAX_VALUE
invalid\ volume\ bandwidth[%s]\ is\ larger\ than\ %d = 云盘带宽[{0}]大于{1}是无效的

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:693
# args: bandwidth
invalid\ volume\ bandwidth[%s]\ is\ not\ a\ number = 错误的云盘带宽 ，[{0}] 这个不是数字

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:690
# args: bandwidth
invalid\ volume\ bandwidth[%s],\ it\ must\ be\ greater\ than\ 1024\ (include\ 1024) = 无效的云盘带宽，它必须大于等于1M

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:714
# args: bandwidth
invalid\ volume\ IOPS[%s]\ is\ not\ a\ number = 错误的云盘每秒读写速度[{0}]，它应该是个数字

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:716
# args: bandwidth,Long.MAX_VALUE
invalid\ volume\ IOPS[%s]\ is\ larger\ than\ %d = 云盘IOPS[{0}]大于{1}是无效的

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:711
# args: bandwidth
invalid\ volume\ IOPS[%s],\ it\ must\ be\ greater\ than\ 0 = 错误的云盘每秒读写速度[{0}]，它应该大于0

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:767
# args: cidr
[%s]\ is\ not\ a\ standard\ cidr = 

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:784
# args: hostUuid,distro,version
the\ host[uuid\:%s]'s\ operating\ system\ %s\ %s\ is\ too\ old,\ the\ QEMU\ doesn't\ support\ QoS\ of\ network\ or\ disk\ IO.\ Please\ choose\ another\ instance\ offering\ with\ no\ QoS\ configuration = 物理机[uuid:{0}] 的操作系统{1} {2} 过老,  QEMU 不支持云盘的QOS IO设置 。 请选择别的没有Qos的计算规格

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:934
# args: newValue
invalid\ value[%s],\ it's\ not\ a\ double = 错误的值[{0}]，这个不是双精度值

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:902
# args: newValue
invalid\ value[%s],\ it\ must\ be\ a\ double\ greater\ than\ 0 = 错误的值[{0}]，必须是一个大于0的双精度值

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:931
# args: newValue
invalid\ value[%s],\ it\ must\ be\ a\ double\ between\ (0,\ 1] = 错误的值[{0}]，这个必须在0~1之间的双精度值

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:945
# args: newValue
invalid\ value[%s],\ ZStack\ doesn't\ have\ such\ host\ allocator\ type = 错误值[{0}]，Zstack没有这样的分配器类型

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:967
# args: MevocoGlobalConfig.AIO_NATIVE.getCanonicalName(),MevocoGlobalConfig.AIO_NATIVE.value(),KVMGlobalConfig.LIBVIRT_CACHE_MODE.getCanonicalName(),KVMGlobalConfig.LIBVIRT_CACHE_MODE.value()
%s\ value\ is[%s],\ which\ is\ conflict\ with\ %s\ value\ [%s] = 

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1223
# args: 
obj\ is\ not\ instanceof\ NicQos! = 

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1543
# args: String.join(",", ips)
unexpected\ host\ management\ IPs\:\ [%s] = 

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1715
# args: 
can\ not\ find\ node\ A\ config\ info = 

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1725
# args: 
can\ not\ find\ node\ A\ address\ info\ from\ bootstrap\ agent = 

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:1780
# args: s.getJobUuid()
can\ not\ get\ bootstrap\ job\ %s\ result\ after\ 900s = 

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:2238
# args: bandwidth
networkInboundBandwidth\ format\ error\ %s = 下行网络带宽格式错误{0}

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:2250
# args: bandwidth
networkOutboundBandwidth\ format\ error\ %s = 上行网络带宽超格式错误{0}

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:2247
# args: 
networkOutboundBandwidth\ execeds\ the\ max\ value\ 32G\ bps = 超过上行网络带宽超过最大值32G bps

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:2441
# args: volume.getUuid(),vm.getUuid()
Shareable\ Volume[uuid\:%s]\ has\ already\ been\ attached\ to\ VM[uuid\:%s] = 共享云盘[uuid:{0}]已经挂载到云主机[uuid:{1}]上

# at: src/main/java/org/zstack/mevoco/MevocoManagerImpl.java:2459
# args: 
shareable\ disk\ only\ support\ virtio-scsi\ type\ for\ now = 目前共享盘只支持virtio-scsi

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:272
# args: vmInstanceVO.getUuid()
How\ can\ a\ Running\ VM[uuid\:%s]\ has\ no\ hostUuid? = 

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:270
# args: vmInstanceVO.getUuid()
Unexpectedly,\ VM[uuid\:%s]\ is\ not\ running\ any\ more,\ please\ try\ again\ later = 

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:645
# args: msg.getVolumeSnapshotJobs().stream().map(CreateVolumesSnapshotsJobStruct::getVolumeUuid).collect(Collectors.toList()),job.getVolumeUuid()
can\ not\ take\ snapshot\ for\ volumes[%s]\ while\ volume[uuid\:\ %s]\ not\ attached = 当云盘[uuid:{1}]未加载时，无法给云盘[{0}]创建快照

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:651
# args: msg.getVolumeSnapshotJobs().stream().map(CreateVolumesSnapshotsJobStruct::getVolumeUuid).collect(Collectors.toList()),job.getVolumeUuid()
can\ not\ take\ snapshot\ for\ volumes[%s]\ while\ volume[uuid\:\ %s]\ appears\ twice = 当云盘[uuid:{1}]出现多次时，无法给云盘[{0}]创建快照

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:658
# args: msg.getVolumeSnapshotJobs().stream().map(CreateVolumesSnapshotsJobStruct::getVolumeUuid).collect(Collectors.toList()),job.getVolumeUuid(),volumeVOS.get(0).getVmInstanceUuid()
can\ not\ take\ snapshot\ for\ volumes[%s]\ attached\ multiple\ vms[%s,\ %s] = 当云盘[uuid:{1}]加载到多个虚拟机上时，无法给云盘[{0}]创建快照

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:665
# args: 
no\ volumes\ found = 找不到云盘

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:961
# args: SizeUnit.BYTE.toGigaByte((double) resize)
this\ snapshot\ recording\ the\ volume\ state\ before\ resize\ to\ %fG\ is\ created\ automatically = 该快照记录云盘扩容到{0}G之前的状态，由系统自动创建

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:1214
# args: msg.getUuid()
DeleteVolumeQos\ [%s]\ ingor\ because\ of\ account\ privilege. = 

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:1400
# args: VolumeQos.getVolumeQosByMode(self.getVolumeQos(), msg.getMode())
non\ admin\ account\ cannot\ set\ bandwidth\ more\ than\ %s = 

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:1441
# args: self.getUuid()
volume\ [%s]\ isn't\ attached\ to\ any\ vm,\ cannot\ get\ qos\ by\ forceSync = 

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:1447
# args: self.getUuid()
volume\ [%s]\ isn't\ attached\ to\ any\ vm\ (or\ vm\ is\ not\ existed\ now),\ cannot\ sync\ volume\ qos = 

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:1452
# args: vm.getUuid()
vm\ [%s]'\ state\ must\ be\ Running\ or\ Paused\ to\ sync\ volume\ qos = 

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:1457
# args: 
vm\ [%s]'s\ HostUuid\ is\ null,\ cannot\ sync\ volume\ qos = 

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:1567
# args: msg.getVolume().getUuid(),msg.getVmInstanceUuid()
failed\ to\ detach\ shareable\ volume[uuid\:%s]\ from\ VmInstance[uuid\:%s] = 不能卸载云主机[uuid:{1}]上的共享盘[uuid:{0}]

# at: src/main/java/org/zstack/mevoco/MevocoVolumeBase.java:1579
# args: StringUtils.join(errors, "\n\n")
failed\ to\ detach\ shareable\ volume\ from\ VmInstance\:[\n%s] = 不能卸载云主机[uuid:{0}]上的共享盘

# at: src/main/java/org/zstack/mevoco/PremiumGlobalConfig.java:27
# args: getName()
the\ current\ version\ of\ license\ does\ not\ support\ modifying\ this\ global\ config\ [name\:%s] = 当前license版本不支持修改此全局设置[name:{0}]

# at: src/main/java/org/zstack/mevoco/PremiumResourceConfig.java:22
# args: globalConfig.getName()
the\ current\ version\ of\ license\ does\ not\ support\ modifying\ this\ resource\ config\ [name\:%s] = 

# at: src/main/java/org/zstack/mevoco/VolumeQos.java:229
# args: mode
invalid\ volume\ qos\ mode\:\ %s = 

# at: src/main/java/org/zstack/mevoco/VolumeQos.java:199
# args: 
cannot\ find\ mode\ from\ null\ VolumeQos = 

# at: src/main/java/org/zstack/monitoring/MonitorManagerImpl.java:190
# args: msg.getMonitorTriggerUuid()
cannot\ find\ monitor\ trigger[uuid\:%s],\ it\ may\ have\ been\ deleted = 不能找到触发监控器[uuid:{0}]，它可能已经被删除了

# at: src/main/java/org/zstack/monitoring/MonitorManagerImpl.java:199
# args: msg.getMonitorTriggerActionUuid()
cannot\ find\ monitor\ trigger\ action[uuid\:%s],\ it\ may\ have\ been\ deleted = 为找到这个监控触发行为[uuid:{0}]，它可能已经被删除了

# at: src/main/java/org/zstack/monitoring/MonitorManagerImpl.java:243
# args: msg.getResourceType()
the\ resource[type\:%s]\ doesn't\ have\ any\ monitoring\ items = 该资源[type:{0}]没有任何监控条目

# at: src/main/java/org/zstack/monitoring/MonitorManagerImpl.java:335
# args: msg.getTargetResourceUuid(),msg.getSession().getAccountUuid()
the\ resource[uuid\:%s]\ doesn't\ belong\ to\ the\ account[uuid\:%s] = 该资源[uuid:{0}]不属于账户[uuid:{1}]

# at: src/main/java/org/zstack/monitoring/MonitorManagerImpl.java:386
# args: resourceUuid
cannot\ find\ type\ for\ the\ resource[uuid\:%s] = 未找到资源[uuid:{0}]这种类型

# at: src/main/java/org/zstack/monitoring/MonitorManagerImpl.java:391
# args: resourceType,triggerExpression.getItem()
no\ monitoring\ item\ found\ for\ the\ resourceType[%s]\ and\ item[%s] = 未找到资源类型[{0}]和条目[{1}]这种监控条目

# at: src/main/java/org/zstack/monitoring/items/AlertText.java:50
# args: args
A\ resource[name\:{resourceName},\ uuid\:{resourceUuid},\ type\:{resourceType}]'s\ monitoring\ trigger[uuid\:{triggerUuid}]\ changes\ status\ to\ {triggerStatus} = 资源[name:'{resourceName}', uuid:'{resourceUuid}', type:'{resourceType}']的监听触发器[uuid:'{triggerUuid}']修改状态为'{triggerStatus}'

# at: src/main/java/org/zstack/monitoring/items/AlertText.java:55
# args: 
\n\=\=\=\ BELOW\ ARE\ DETAILS\ OF\ THE\ PREVIOUS\ ALERT\ \=\=\= = \n=== 以下是上一次警告内容 ===

# at: src/main/java/org/zstack/monitoring/items/AlertText.java:58
# args: 
\nalert\ details\: = \n警告内容: 

# at: src/main/java/org/zstack/monitoring/items/AlertText.java:59
# args: args
\ncondition\:\ {itemName}\ {operator}\ {threshold} = \n环境: '{itemName}' '{operator}' '{threshold}'

# at: src/main/java/org/zstack/monitoring/items/AlertText.java:60
# args: args
\ncurrent\ value\:\ {value} = \n当前值: '{value}'

# at: src/main/java/org/zstack/monitoring/items/host/HostCpuUtilItem.java:31
# args: 
Host\ CPU\ utilization = CPU使用率

# at: src/main/java/org/zstack/monitoring/items/vm/VmCpuUtilItem.java:29
# args: 
VM\ CPU\ utilization = 虚拟机CPU使用率

# at: src/main/java/org/zstack/monitoring/prometheus/AlertRuleWriter.java:141
# args: rb.name,r
conflict\ alert\ rule[%s],\ there\ has\ been\ a\ rule[%s]\ with\ the\ same\ name = 冲突提示规则[{0}]，这里已经存在和它一样名称的规则

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusAlert.java:79
# args: resourceName,resourceUuid,toI18nString(resourceType),itemName,toI18nString(expression.getOperator()),expression.getConstant(),value,tvo.getDuration()
ALERT\:\n\ resource[name\:\ %s,\ uuid\:\ %s,\ type\:\ %s]\nevent\:\ %s\ %s\ %s\ncurrent\ value\:\ %s\nduration\:\ %s\ seconds\n = 警告:\n 资源[名称: {0}, uuid: {1}, 类型: {2}]\n 事件: {3} {4} {5}\n 周期: {7}\n

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusApiInterceptor.java:40
# args: msg.getRelativeTime()
the\ relativeTime[%s]\ is\ invalid,\ it\ must\ be\ in\ format\ of,\ for\ example,\ 10s,\ 1h = 相关时间[{0}]不合法,格式必须例如10s，1h

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusApiInterceptor.java:44
# args: msg.getRelativeTime()
the\ relativeTime[%s]\ is\ invalid,\ it's\ too\ big = 相关时间[{0}]不合法，值's 过大

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostCpuUtilAlertWriter.java:88
# args: 
CPU\ Utilization = CPU使用率

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostCpuUtilAlertWriter.java:97
# args: 
CPU\ utilization\ type = CPU使用类型

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostCpuUtilAlertWriter.java:95
# args: 
CPU\ number = CPU数量

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostCpuUtilItem.java:70
# args: cpu,trigger.getTargetResourceUuid(),cpuNum
invalid\ cpu[%s],\ the\ host[uuid\:%s]\ doesn't\ have\ a\ CPU\ numbered\ by\ %s = 无效CPU数目[{0}]，物理机[uuid:{1}]存在的CPU数目是{2}

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostDiskCapacityAlertWriter.java:92
# args: 
Host\ Disk\ Capacity = 物理机磁盘容量

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostDiskCapacityAlertWriter.java:98
# args: 
Host\ Disk\ Capacity\ type = 物理机磁盘容量类型

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostDiskCapacityAlertWriter.java:100
# args: 
Host\ devices = 物理机服务

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostDiskIOAlertWriter.java:86
# args: 
Disk\ IO = 磁盘IO

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostDiskIOAlertWriter.java:92
# args: 
Disk\ IO\ direction = 磁盘IO方向

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostDiskIOAlertWriter.java:93
# args: 
Disk\ IO\ type = 磁盘IO类型

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostMemUtilAlertWriter.java:77
# args: 
Memory\ Utilization = 内存使用率

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostMemUtilItem.java:57
# args: expression.getConstant()
invalid\ right\ value[%s],\ it\ must\ be\ a\ float\ or\ double\ number = 无效的参数值[{0}]，它必须是一个float或者double类型的数值

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostMemUtilItem.java:53
# args: expression.getConstant()
invalid\ right\ value[%s],\ it\ must\ be\ float\ or\ double\ number\ greater\ than\ zero\ and\ lesser\ than\ one = 无效参数值[{0}]，它必须是一个float或者double类型的大于0小于1的数值

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostMemUtilItem.java:47
# args: type,ALLOWED_TYPES
invalid\ type[%s],\ only\ %s\ are\ allowed = 无效类型[{0}]，只有{1}被允许

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostNetworkIOAlertWriter.java:84
# args: 
Network\ IO = 网络IO

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostNetworkIOAlertWriter.java:89
# args: 
Network\ IO\ direction = 网络IO方向

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostNetworkIOAlertWriter.java:77
# args: 
Host = 物理机

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostNetworkIOItem.java:18
# args: dir,ALLOWED_DIRECTION
invalid\ direction[%s],\ only\ %s\ are\ allowed = 无效direction[{0}]，只有{1}被允许

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusHostNetworkIOItem.java:22
# args: expression.getConstant()
invalid\ right\ value[%s],\ it\ must\ be\ a\ number(int,\ long,\ float,\ double) = 无效参数值[{0}]，他应该是一个数字(int, long, float, double)

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusMonitorProviderFactory.java:124
# args: ret.get("errorType"),ret.get("error")
query\ failure,\ errorType\:%s,\ error\:\ %s = 查询失败，错误类型: {0}, 错误: {1}

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusVmMemUtilAlertWriter.java:70
# args: 
Virtual\ Machine = 虚拟机器

# at: src/main/java/org/zstack/monitoring/prometheus/PrometheusVmMemUtilItem.java:47
# args: expression.getArguments().keySet()
invalid\ arguments\ %s,\ no\ argument\ is\ allowed = 无效参数列表{0}，没有被参数被允许

# at: src/main/java/org/zstack/monitoring/trigger/expression/TriggerExpression.java:106
# args: expr,e.getMessage()
invalid\ expression\:\ %s,\ %s = 无效的语句: {0}, {1}

# at: src/main/java/org/zstack/monitoring/trigger/expression/TriggerExpression.java:110
# args: expr
invalid\ expression\:\ %s,\ no\ expression\ found = 无效的语句: {0}，未找到该语句

# at: src/main/java/org/zstack/monitoring/trigger/expression/TriggerExpression.java:127
# args: key
missing\ parameter\ '%s'\ in\ the\ expression = 在语句中缺失参数{0}

# at: src/main/java/org/zstack/monitoring/trigger/expression/TriggerExpression.java:131
# args: key,clz,value.getClass()
wrong\ type\ of\ parameter\ '%s'\ in\ the\ expression,\ it\ must\ be\ type\ of\ %s,\ but\ got\ %s = 在语句中{0}参数类型错误，它必须是{1}这种类型，但是获得的是{2}

# at: src/main/java/org/zstack/nas/NasFileSystemManagerImpl.java:91
# args: msg.getNasFileSystemUuid()
nas\ file\ system\ [%s]\ is\ not\ existed\ yet = 

# at: src/main/java/org/zstack/nas/NasFileSystemManagerImpl.java:139
# args: type
cannot\ find\ nas\ factory\ for\ type\:\ %s = 

# at: src/main/java/org/zstack/nas/NasFileSystemManagerImpl.java:164
# args: f.getClass().getSimpleName(),old.getClass().getSimpleName(),f.getNasFileSystemType()
duplicate\ NasFileSystemFactory[%s,\ %s]\ for\ type[%s] = 

# at: src/main/java/org/zstack/network/l2/L2NetworkApiInterceptor.java:66
# args: msg.getL2NetworkUuid(),msg.getClusterUuid()
l2Network[uuid\:%s]\ has\ attached\ to\ cluster[uuid\:%s],\ can't\ attach\ again = 不能再次挂载l2网络[uuid:{0}]，因为已经挂载到集群[uuid:{1}]上了

# at: src/main/java/org/zstack/network/l2/L2NetworkApiInterceptor.java:75
# args: msg.getL2NetworkUuid(),msg.getClusterUuid()
l2Network[uuid\:%s]\ has\ not\ attached\ to\ cluster[uuid\:%s] = L2网络[uuid:{0}]没有挂载到集群上[uuid:{1}]

# at: src/main/java/org/zstack/network/l2/L2NetworkApiInterceptor.java:89
# args: msg.getType()
unsupported\ l2Network\ type[%s] = 不支持的网络类型[{0}]

# at: src/main/java/org/zstack/network/l2/L2NoVlanNetwork.java:554
# args: vl2.getUuid(),vl2.getName(),msg.getClusterUuid(),vl2.getPhysicalInterface(),vl2.getVlan(),tl2.getUuid()
There\ has\ been\ a\ L2VlanNetwork[uuid\:%s,\ name\:%s]\ attached\ to\ cluster[uuid\:%s]\ that\ has\ physical\ interface[%s],\ vlan[%s].\ Failed\ to\ attach\ L2VlanNetwork[uuid\:%s] = L2网络挂载失败[uuid:{5}]: L2网络[uuid:{0}, name:{1}]的物理接口[{3}], vlan[{4}]已经挂载到集群[uuid:{2}]上

# at: src/main/java/org/zstack/network/l2/L2NoVlanNetwork.java:536
# args: l2.getUuid(),l2.getName(),msg.getClusterUuid(),l2.getPhysicalInterface(),tl2.getUuid()
There\ has\ been\ a\ l2Network[uuid\:%s,\ name\:%s]\ attached\ to\ cluster[uuid\:%s]\ that\ has\ physical\ interface[%s].\ Failed\ to\ attach\ l2Network[uuid\:%s] = L2网络挂载失败[uuid:{4}]: L2网络[uuid:{0}, name:{1}]的物理接口[{3}]]已经挂载到集群[uuid:{2}]上

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetwork/VxlanNetworkFactory.java:216
# args: inv.getUuid(),destHostUuid
cannot\ configure\ vxlan\ network\ for\ vm[uuid\:%s]\ on\ the\ destination\ host[uuid\:%s] = 无法为云主机[uuid:{0}]在目标物理机[uuid:{1}]上配置VXLAN网络

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetworkPool/KVMRealizeL2VxlanNetworkBackend.java:79
# args: vtepIps,hostUuid
find\ multiple\ vtep\ ips[%s]\ for\ one\ host[uuid\:%s],\ need\ to\ delete\ host\ and\ add\ again = 在一个物理机[uuid:{1}]发现多个VTEP IP，需要删除物理机在进行添加

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetworkPool/KVMRealizeL2VxlanNetworkBackend.java:119
# args: cmd.getBridgeName(),l2Network.getUuid(),l2Network.getType(),l2vxlan.getVni(),hostUuid,rsp.getError()
failed\ to\ create\ bridge[%s]\ for\ l2Network[uuid\:%s,\ type\:%s,\ vni\:%s]\ on\ kvm\ host[uuid\:%s],\ because\ %s = 为L2网络[uuid:{1}, type:{2}, vni:{3}]在KVM物理机[uuid:{4}]上创建网桥[{0}]失败，错误细节: {5}

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetworkPool/KVMRealizeL2VxlanNetworkBackend.java:183
# args: cmd.getCidr(),l2vxlan.getUuid(),l2vxlan.getName(),hostUuid,rsp.getError()
failed\ to\ check\ cidr[%s]\ for\ l2VxlanNetwork[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:%s],\ %s = 为KVM物理机[uuid:{3}]上的L2 VXLAN 网络[uuid:{1}, name:{2}]检查CIDR[{0}]失败，错误细节: {4}

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetworkPool/KVMRealizeL2VxlanNetworkPoolBackend.java:253
# args: l2Network.getUuid(),l2Network.getType(),vnis,hostUuid,rsp.getError()
failed\ to\ realize\ vxlan\ network\ pool[uuid\:%s,\ type\:%s,\ vnis\:%s]\ on\ kvm\ host[uuid\:%s],\ because\ %s = 在kvm物理机[uuid:{3}]实现vxlan network pool[uuid:{0}, type:{1}, vnis:{2}]失败，因为{4}

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetworkPool/KVMRealizeL2VxlanNetworkPoolBackend.java:110
# args: cmd.getCidr(),vxlanPool.getUuid(),vxlanPool.getName(),hostUuid,rsp.getError()
failed\ to\ check\ cidr[%s]\ for\ l2VxlanNetworkPool[uuid\:%s,\ name\:%s]\ on\ kvm\ host[uuid\:%s],\ %s = 检查在kvm物理机[uuid:{3}]上的l2VxlanNetworkPool[uuid:{1}, name:{2}]的CIDR[{0}]失败，{4}

# at: src/main/java/org/zstack/network/l2/vxlan/vxlanNetworkPool/VxlanPoolApiInterceptor.java:50
# args: msg.getHostUuid(),msg.getPoolUuid()
vxlan\ vtep\ address\ for\ host\ [uuid\ \:\ %s]\ and\ pool\ [uuid\ \:\ %s]\ pair\ already\ existed = 物理机[uuid : {0}]在vxlan资源池[uuid : {1}]中隧道端点地址已经配置

# at: src/main/java/org/zstack/network/l3/IpNotAvailabilityReason.java:27
# args: 
it\ is\ used = 被占用

# at: src/main/java/org/zstack/network/l3/IpNotAvailabilityReason.java:25
# args: 
it\ is\ not\ in\ this\ range = 不在IP地址范围内

# at: src/main/java/org/zstack/network/l3/IpNotAvailabilityReason.java:23
# args: 
it\ is\ gateway = 网关不能分配

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:116
# args: 
you\ must\ update\ system\ and\ category\ both = 必须同时更行system属性和category属性

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:351
# args: L3NetworkCategory.validCombination
not\ valid\ combination\ of\ system\ and\ category,only\ %s\ are\ valid = 无效的system属性和category属性的组合，只有{0}是有效的

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:161
# args: msg.getIp()
invalid\ IP[%s] = 错误的IP值[{0}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:145
# args: msg.getL3NetworkUuid()
no\ ip\ range\ in\ l3[%s] = 没有IP在三层网络范围中

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:149
# args: msg.getRouterInterfaceIp(),ipRangeVO.getUuid(),ipRangeVO.getNetworkCidr(),msg.getL3NetworkUuid()
ip[%s]\ is\ not\ in\ the\ cidr\ of\ ip\ range[uuid\:%s,\ cidr\:%s]\ which\ l3\ network[%s]\ attached = IP[{0}]没有在三层网络[{3}]的CIDR的IP范围内[uuid:{1}, cidr:{2}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:153
# args: msg.getRouterInterfaceIp(),ipRangeVO.getUuid(),ipRangeVO.getStartIp(),ipRangeVO.getEndIp(),msg.getL3NetworkUuid()
ip[%s]\ in\ ip\ range[uuid\:%s,\ startIp\:%s,\ endIp\:%s]\ which\ l3\ network[%s]\ attached,\ this\ is\ not\ allowed = IP[{0}]在三层网络[{4}]绑定的IP范围内[uuid:{1}, startIp:{2}, endIp:{3}]，这是不被允许的

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:167
# args: 
ipRangeUuid\ and\ l3NetworkUuid\ cannot\ both\ be\ null;\ you\ must\ set\ either\ one. = IP段和L3的uuid不能都为空，您必须选择一个填上

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:289
# args: msg.getNetworkCidr()
%s\ is\ not\ a\ valid\ network\ cidr = {0}不是有效的无类别域间路由

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:214
# args: msg.getGateway()
%s\ is\ not\ a\ valid\ ipv6\ address = {0}不是有效的IPv6地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:218
# args: msg.getStartIp(),msg.getEndIp(),msg.getPrefixLen(),msg.getGateway()
[startIp\ %s,\ endIp\ %s,\ prefixLen\ %d,\ gateway\ %s]\ is\ not\ a\ valid\ ipv6\ range = IPv6地址段{0}-{1}/{2}, 网关{3}不是有效的IPv6地址段

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:228
# args: IPv6Constants.IPV6_PREFIX_LEN_MIN,IPv6Constants.IPV6_PREFIX_LEN_MAX
ip\ range\ prefix\ length\ is\ out\ of\ range\ [%d\ -\ %d]\  = IPv6地址前缀长度不在有效范围内[{0}-{1}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:234
# args: l3Vo.getUuid(),l3Vo.getName()
l3\ network\ [uuid\ %s\:\ name\ %s]\ is\ not\ a\ ipv6\ network = 三层网络[uuid:{0},名称{1}]不是IPv6网络

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:240
# args: ipr.getAddressMode(),rangeVOS.get(0).getAddressMode()
addressMode[%s]\ is\ different\ from\ L3Netowork\ address\ mode[%s] = 地址模式[{0}]和三层网络的地址模式[{1}]不同

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:246
# args: IPv6Constants.IPV6_STATELESS_PREFIX_LEN
ipv6\ prefix\ length\ must\ be\ %d\ for\ Stateless-DHCP\ or\ SLAAC = Stateless-DHCP or SLAAC地址模式IPv6网络前缀长度必须是{0}

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:256
# args: ipr.getStartIp(),ipr.getEndIp(),r.getStartIp(),r.getEndIp()
new\ ip\ range\ [startip\ \:%s,\ endip\ \:%s]\ is\ overlaped\ with\ old\ ip\ range[startip\ \:%s,\ endip\ \:%s] = 新的IP地址段[{0}-{1}]和旧的IP地址段[{2}-{3}]冲突

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:266
# args: r.getNetworkCidr(),ipr.getNetworkCidr()
new\ network\ CIDR\ [%s]\ is\ different\ from\ old\ network\ cidr\ [%s] = 新的IP地址段[{0}]和旧的IP地址段冲突[{1}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:464
# args: ipr.getGateway(),r.getGateway()
new\ add\ ip\ range\ gateway\ %s\ is\ different\ from\ old\ gateway\ %s = 新ip段的网关地址{0}和已有ip段的网关地址{1}冲突

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:286
# args: msg.getNetworkCidr()
%s\ is\ not\ an\ allowed\ network\ cidr,\ because\ it\ doesn't\ have\ usable\ ip\ range = {0}是不允许的无类别域间路由，因为它不支持可用的IP段

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:309
# args: 
ipRangeUuids,\ L3NetworkUuids,\ zoneUuids\ must\ have\ at\ least\ one\ be\ none-empty\ list,\ or\ all\ is\ set\ to\ true = ipRangeUuids, L3NetworkUuids, zoneUuids 至少一个不是为空列表，或者全部不为空

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:330
# args: msg.getType()
unsupported\ l3network\ type[%s] = 不支持的L3网络类型[{0}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:336
# args: msg.getDnsDomain()
%s\ is\ not\ a\ valid\ domain\ name = {0}不是有效的域名

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:378
# args: l3Vo.getUuid(),l3Vo.getName()
l3\ network\ [uuid\ %s\:\ name\ %s]\ is\ not\ a\ ipv4\ network = 三层网络[uuid:{0},name:{1}]不是IPv4网络

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:382
# args: ipr.getStartIp(),ipr.getEndIp()
the\ IP\ range[%s\ ~\ %s]\ contains\ D\ class\ addresses\ which\ are\ for\ multicast = 这个IP段[{0} ~ {1}]包含了D类的多播地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:386
# args: ipr.getStartIp(),ipr.getEndIp()
the\ IP\ range[%s\ ~\ %s]\ contains\ E\ class\ addresses\ which\ are\ reserved = 这个IP段[{0} ~ {1}]包含了E类的保留地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:390
# args: ipr.getStartIp(),ipr.getEndIp()
the\ IP\ range[%s\ ~\ %s]\ contains\ link\ local\ addresses\ which\ are\ reserved = 这个IP段[{0} ~ {1}]包含了本地的保留地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:396
# args: ipr.getGateway(),ipr.getStartIp(),ipr.getNetmask()
the\ gateway[%s]\ is\ not\ in\ the\ subnet\ %s/%s = 网关[{0}]不在子网{1}/{2}

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:400
# args: ipr.getEndIp(),ipr.getStartIp(),ipr.getNetmask()
the\ endip[%s]\ is\ not\ in\ the\ subnet\ %s/%s = IP段结束地址不在子网{1}/{2}范围内

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:404
# args: ipr.getStartIp()
start\ ip[%s]\ is\ not\ a\ IPv4\ address = 开始的ip[{0}] 不是IPV4的地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:408
# args: ipr.getEndIp()
end\ ip[%s]\ is\ not\ a\ IPv4\ address = 结束的ip[{0}] 不是IPV4的地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:412
# args: ipr.getGateway()
gateway[%s]\ is\ not\ a\ IPv4\ address = 网关[{0}]不是IPV4的地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:416
# args: ipr.getNetmask()
netmask[%s]\ is\ not\ a\ netmask,\ and\ the\ IP\ range\ netmask\ cannot\ be\ 0.0.0.0 = 子网掩码[{0}]不是子网掩码，并且IP段的子网掩码不能是0.0.0.0

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:420
# args: 
ip\ allocation\ can\ not\ contain\ network\ address\ or\ broadcast\ address = ip 地址分配不能包含网络地址或广播的地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:428
# args: ipr.getStartIp(),ipr.getEndIp()
start\ ip[%s]\ is\ behind\ end\ ip[%s] = 起始ip[{0}]在尾ip[{1}]后

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:433
# args: ipr.getGateway(),ipr.getStartIp(),ipr.getEndIp()
gateway[%s]\ can\ not\ be\ part\ of\ range[%s,\ %s] = 网关[{0}]不能是IP段[{1}, {2}]的一部分

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:444
# args: r.getUuid(),r.getStartIp(),r.getEndIp()
overlap\ with\ ip\ range[uuid\:%s,\ start\ ip\:%s,\ end\ ip\:\ %s] = 重叠的IP段[uuid:{0}, 起始ip:{1}, 尾ip: {2}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:454
# args: r.getUuid(),rcidr,cidr
multiple\ CIDR\ on\ the\ same\ L3\ network\ is\ not\ allowed.\ There\ has\ been\ a\ IP\ range[uuid\:%s,\ CIDR\:%s],\ the\ new\ IP\ range[CIDR\:%s]\ is\ not\ in\ the\ CIDR\ with\ the\ existing\ one = 在相同的三层网络上多个CIDR是不允许的，已有的IP范围 [uuid: {0}，CIDR: {1}]。新的IP范围 [CIDR: {2}] 不在现有的一个CIDR

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:486
# args: manner,ip
%s[%s]\ is\ not\ a\ IPv6\ address = {0}[{1}]不是IPv6地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:482
# args: manner,ip
%s[%s]\ is\ not\ a\ IPv4\ address = {0}[{1}]不是IPv4地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:498
# args: msg.getDns(),msg.getL3NetworkUuid()
there\ has\ been\ a\ DNS[%s]\ on\ L3\ network[uuid\:%s] = 在L3网络[uuid:{1}]上已经存在一个DNS[{0}]

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:521
# args: msg.getL3NetworkUuid()
prefix\ [%s]\ is\ not\ a\ IPv4\ network\ cidr = 网络段{0}不是合法的网络段

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:508
# args: msg.getNexthop()
nexthop[%s]\ is\ not\ a\ IPv4\ address = 下一跳{0}不是有效的IP地址

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:515
# args: msg.getPrefix(),msg.getL3NetworkUuid()
there\ has\ been\ a\ hostroute\ for\ prefix[%s]\ on\ L3\ network[uuid\:%s] = 三层网络{1}已配置主机路由{0}

# at: src/main/java/org/zstack/network/l3/L3NetworkApiInterceptor.java:528
# args: msg.getPrefix(),msg.getL3NetworkUuid()
there\ is\ no\ hostroute\ for\ prefix[%s]\ on\ L3\ network[uuid\:%s] = 三层网络{1}没有主机路由{0}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:69
# args: msg.getSecurityGroupUuid(),msg.getL3NetworkUuid()
security\ group[uuid\:%s]\ has\ not\ attached\ to\ l3Network[uuid\:%s],\ can't\ detach = 不能卸载安全组[uuid:{0}]到L3[uuid:{1}]网络上，因为还未挂载

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:117
# args: msg.getSecurityGroupUuid(),msg.getL3NetworkUuid()
security\ group[uuid\:%s]\ has\ attached\ to\ l3Network[uuid\:%s],\ can't\ attach\ again = 不能再次挂载安全组[uuid:{0}]到L3[uuid:{1}]网络上，因为已经挂载了

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:125
# args: msg.getL3NetworkUuid(),SecurityGroupConstant.SECURITY_GROUP_NETWORK_SERVICE_TYPE
the\ L3\ network[uuid\:%s]\ doesn't\ have\ the\ network\ service\ type[%s]\ enabled = L3网络[uuid:{0}]没有开启[{1}]类型的网络服务

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:131
# args: msg.getL3NetworkUuid(),l3Vo.getIpVersion(),msg.getSecurityGroupUuid(),sgVo.getIpVersion()
the\ L3\ network[uuid\:%s]\ ipVersion\ [%d]\ is\ different\ from\ securityGroup\ [uuid\:%s]\ ipVersion\ [%d] = 

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:214
# args: JSONObjectUtil.toJsonString(ao)
rule\ type\ can\ not\ be\ null.\ rule\ dump\:\ %s = 规则类型(rule type)不能为空(null)。规则内容为: {0}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:219
# args: ao.getType(),JSONObjectUtil.toJsonString(ao)
unknown\ rule\ type[%s],\ rule\ can\ only\ be\ Ingress/Egress.\ rule\ dump\:\ %s = 未知的规则类型(rule type)[{0}]，规则类型只能为Ingress/Egress。规则内容为: {1}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:225
# args: JSONObjectUtil.toJsonString(ao)
protocol\ can\ not\ be\ null.\ rule\ dump\:\ %s = 协议(protocol)不能为空(null)。规则内容为: {0}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:231
# args: ao.getProtocol(),JSONObjectUtil.toJsonString(ao)
invalid\ protocol[%s].\ Valid\ protocols\ are\ [TCP,\ UDP,\ ICMP,\ ALL].\ rule\ dump\:\ %s = 无效的协议(protocol)[{0}]。有效的协议类型为[TCP,UDP,ICMP,ALL]。规则内容为: {1}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:238
# args: JSONObjectUtil.toJsonString(ao)
can\ not\ set\ port\ for\ protocol\ [type\:ALL].\ rule\ dump\:\ %s = 不能为协议类型为 ALL 的规则指定端口号，规则为:{0}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:236
# args: JSONObjectUtil.toJsonString(ao)
startPort\ can\ not\ be\ null.\ rule\ dump\:\ %s = 起始端口(startPort)不能为空(null)。规则内容为: {0}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:250
# args: ao.getStartPort(),JSONObjectUtil.toJsonString(ao)
invalid\ startPort[%s].\ Valid\ range\ is\ [0,\ 65535].\ rule\ dump\:\ %s = 无效的起始端口(startPort)[{0}]。有效的范围为[0,65535]。规则内容为: {1}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:243
# args: ao.getStartPort(),JSONObjectUtil.toJsonString(ao)
invalid\ ICMP\ type[%s].\ Valid\ type\ is\ [-1,\ 255].\ rule\ dump\:\ %s = 无效的ICMP类型[{0}]。有效的类型为[-1,255]。规则内容为: {1}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:269
# args: ao.getEndPort(),JSONObjectUtil.toJsonString(ao)
invalid\ endPort[%s].\ Valid\ range\ is\ [0,\ 65535].\ rule\ dump\:\ %s = 无效的结束端口(endPort)[{0}]。有效的范围为[0,65535]。规则内容为: {1}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:262
# args: ao.getEndPort(),JSONObjectUtil.toJsonString(ao)
invalid\ ICMP\ code[%s].\ Valid\ range\ is\ [-1,\ 3].\ rule\ dump\:\ %s = 无效的ICMP编码[{0}]。有效的范围为[-1,3]。规则内容为: {1}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:279
# args: ao.getAllowedCidr(),JSONObjectUtil.toJsonString(ao)
invalid\ CIDR[%s].\ rule\ dump\:\ %s = 无效的CIDR[{0}]。规则内容为: {1}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:283
# args: sgVo.getIpVersion(),ao.getIpVersion()
security\ group\ rule\ ipVersion\ [%d]\ is\ different\ from\ security\ group\ version\ [%d] = 远端安全组IP协议号[{0}]和本地安全组的IP协议号[{1}]

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:292
# args: JSONObjectUtil.toJsonString(msg.getRules().get(j))
rule\ should\ not\ be\ duplicated.\ rule\ dump\:\ %s = 规则不应该重复。规则内容为: {0}

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:318
# args: JSONObjectUtil.toJsonString(sao),svo.getRemoteSecurityGroupUuid()
rule\ exist.\ rule\ dump\:\ %s,\ remoteSecurityGroupUuid\:[%s] = 规则已存在，规则内容为:{0}，源安全组[uuid:{1}]

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupApiInterceptor.java:345
# args: rsgVo.getIpVersion(),sgVo.getIpVersion()
remote\ security\ group\ ipVersion\ [%d]\ is\ different\ from\ security\ group\ version\ [%d] = 远端安全组IP协议号[{0}]和安全组协议号[{1}]不一致

# at: src/main/java/org/zstack/network/securitygroup/SecurityGroupManagerImpl.java:1126
# args: wrongUuids,securityGroupUuid
VM\ nics[uuids\:%s]\ are\ not\ on\ L3\ networks\ that\ have\ been\ attached\ to\ the\ security\ group[uuid\:%s] = 云主机网卡[uuids:{0}]不在安全组[uuid:{1}]挂载的L3网络上

# at: src/main/java/org/zstack/network/service/HostRouteExtension.java:88
# args: msg.getL3NetworkUuid()
L3Network\ [uuid\:\ %s]\ provide\ type\ null = 三层网络{0}后端为空

# at: src/main/java/org/zstack/network/service/HostRouteExtension.java:113
# args: msg.getL3NetworkUuid()
L3Network\ [uuid\:\ %s]\ does\ not\ have\ host\ route\ service = 三层网络{0}没有主机路由功能

# at: src/main/java/org/zstack/network/service/NetworkServiceApiInterceptor.java:41
# args: 
networkServices\ cannot\ be\ empty = 网络服务(networkServices)不能为空

# at: src/main/java/org/zstack/network/service/NetworkServiceApiInterceptor.java:62
# args: puuid
network\ service\ for\ provider[uuid\:%s]\ must\ be\ specified = 服务提供器[uuid:{0}]的网络服务必须被指定

# at: src/main/java/org/zstack/network/service/NetworkServiceApiInterceptor.java:67
# args: puuid
cannot\ find\ network\ service\ provider[uuid\:%s]\ or\ it\ provides\ no\ services = 无法找到网络服务提供器[uuid:{0}]或它没有提供任何服务

# at: src/main/java/org/zstack/network/service/NetworkServiceApiInterceptor.java:81
# args: puuid,notSupported
network\ service\ provider[uuid\:%s]\ doesn't\ provide\ services%s = 网络服务提供器[uuid:{0}]无法提供服务{1}

# at: src/main/java/org/zstack/network/service/NetworkServiceApiInterceptor.java:93
# args: type,msg.getL3NetworkUuid()
there\ has\ been\ a\ network\ service[%s]\ attached\ to\ L3\ network[uuid\:%s] = 已经有一个网络服务[{0}]被挂载到L3网络[uuid:{1}]

# at: src/main/java/org/zstack/network/service/NetworkServiceManagerImpl.java:342
# args: l3NetworkUuid,serviceType
L3Network[uuid\:%s]\ doesn't\ have\ network\ service[type\:%s]\ enabled\ or\ no\ provider\ provides\ this\ network\ service = L3网络[uuid:{0}]上没有网络服务[type:{1}]被启用或没有服务提供器提供该网络服务

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:82
# args: 
either\ eipUuid\ or\ vipUuid\ must\ be\ set = eipUuid或vipUuid必须有一个被指定

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:88
# args: msg.getEipUuid()
eip[uuid\:%s]\ is\ not\ in\ state\ of\ Enabled,\ cannot\ get\ attachable\ vm\ nic = eip[uuid:{0}]没有被启用，无法获取可挂载的虚拟机网卡

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:103
# args: guestIpUuid,vmNicUuid
ip\ [uuid\:%s]\ is\ attached\ to\ vm\ nic\ [%s] = IP地址[uuid:{0}]已经绑定到网卡[{1}]

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:114
# args: msg.getEipUuid(),vmNicUuid
eip[uuid\:%s]\ has\ attached\ to\ another\ vm\ nic[uuid\:%s],\ can't\ attach\ again = eip[uuid:{0}]已经被挂载到另外一台虚拟机网卡[uuid:{1}]，无法再次挂载

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:120
# args: msg.getEipUuid(),EipState.Enabled,state
eip[uuid\:\ %s]\ can\ only\ be\ attached\ when\ state\ is\ %s,\ current\ state\ is\ %s = eip[uuid:{0}]只有在状态(state)为{1}的情况下可以被挂载，当前状态是{2}

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:150
# args: msg.getVmNicUuid(),msg.getEipUuid()
guest\ l3Network\ of\ vm\ nic[uuid\:%s]\ and\ vip\ l3Network\ of\ EIP[uuid\:%s]\ are\ the\ same\ network = 虚拟机网卡[uuid:{0}]的客户L3网络，和EIP[uuid:{1}]的虚拟ip L3网络是同一个网络

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:167
# args: msg.getEipUuid(),msg.getVmNicUuid()
Ip\ address\ [uuid\:%s]\ is\ not\ belonged\ to\ nic\ [uuid\:%s] = IP地址[uuid:{0}]没有绑定到网卡[uuid:{1}]

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:180
# args: msg.getUuid()
eip[uuid\:%s]\ has\ not\ attached\ to\ any\ vm\ nic = eip[uuid:{0}]还没有被挂载到任意虚拟机网卡

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:203
# args: vipIp.getIpVersion(),guestIp.getIpVersion()
vip\ ipVersion\ [%d]\ is\ different\ from\ guestIp\ ipVersion\ [%d]. = 虚拟IP的协议号[{0}]和网卡的IP协议号[{1}]不同

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:210
# args: vipIp.getIp(),guestRange.getStartIp(),guestRange.getEndIp()
Vip[%s]\ is\ in\ the\ guest\ ip\ range\ [%s,\ %s] = 虚拟IP[{0}]和网卡的IP不能在相同地址段[{1}-{2}]

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:230
# args: vmUuid,vip.getL3NetworkUuid(),vip.getUuid(),vip.getName(),vip.getIp()
the\ vm[uuid\:%s]\ that\ the\ EIP\ is\ about\ to\ attach\ is\ already\ on\ the\ public\ network[uuid\:%s]\ from\ which\ the\ vip[uuid\:%s,\ name\:%s,\ ip\:%s]\ comes = EIP将要挂载到的虚拟机[uuid:{0}]已经处于公共网络[uuid:{1}]上，该网络上已有vip[uuid:{2}, name:{3}, ip:{4}]

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:241
# args: msg.getVipUuid(),useForList.toString()
vip[uuid\:%s]\ has\ been\ occupied\ other\ network\ service\ entity[%s] = vip[uuid:{0}]已经被其他网络服务实体[{1}]占用

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:246
# args: msg.getVipUuid(),VipState.Enabled,vip.getState()
vip[uuid\:%s]\ is\ not\ in\ state[%s],\ current\ state\ is\ %s = vip[uuid:{0}]不处于状态[{1}]中，当前状态[{2}]

# at: src/main/java/org/zstack/network/service/eip/EipApiInterceptor.java:281
# args: state.toString()
vm\ state[%s]\ is\ not\ allowed\ to\ operate\ eip,\ maybe\ you\ should\ wait\ the\ vm\ process\ complete = 云主机状态[{0}]不允许进行弹性IP操作，你可能需要等待云主机操作完成

# at: src/main/java/org/zstack/network/service/eip/EipManagerImpl.java:924
# args: eip.getGuestIp(),nicIps
cannot\ find\ Eip\ guest\ ip\:\ %s\ in\ vmNic\ ips\ \:%s = 

# at: src/main/java/org/zstack/network/service/eip/EipManagerImpl.java:1285
# args: l3.getUuid(),l3.getName(),vm.getUuid(),vm.getName()
unable\ to\ attach\ the\ L3\ network[uuid\:%s,\ name\:%s]\ to\ the\ vm[uuid\:%s,\ name\:%s],\ because\ the\ L3\ network\ is\ providing\ EIP\ to\ one\ of\ the\ vm's\ nic = 无法将L3网络[uuid:{0}, name:{1}]挂载到虚拟机[uuid:{2}, name:{3}]，因为L3网络正在为虚拟机上的一块网卡提供EIP

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:247
# args: 
l3\ network\ uuid\ cannot\ be\ null = L3网络的uuid不能为空

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:263
# args: msg.getL3NetworkUuid()
Cannot\ find\ DhcpIp\ for\ l3\ network[uuid\:%s] = 无法为L3网络[uuid:{0}]找到DHCP IP

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:349
# args: msg.getL3NetworkUuid()
L3\ network[uuid\:%s]\ does\ not\ have\ any\ iprange = 三层网络[{0}]没有配置ip段

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:605
# args: inv.getUuid(),destHostUuid
cannot\ configure\ DHCP\ for\ vm[uuid\:%s]\ on\ the\ destination\ host[uuid\:%s] = 无法为目标物理机[uuid:{1}]上的虚拟机[uuid:{0}]配置DHCP

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:1459
# args: dhcpServerIp
DHCP\ server\ ip\ [%s]\ is\ not\ a\ IPv6\ address = DHCP服务器地址[{0}]不是一个正确的IPv6地址

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:1455
# args: dhcpServerIp,inv.getNetworkCidr()
DHCP\ server\ ip\ [%s]\ is\ not\ in\ the\ cidr\ [%s] = DHCP服务器地址[{0}]不在网络段[{1}]的范围内

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:1451
# args: dhcpServerIp
DHCP\ server\ ip\ [%s]\ is\ not\ a\ IPv4\ address = DHCP服务器地址[{0}]不是一个正确的IPv4地址

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:1470
# args: IPv6NetworkUtils.ipv6TagValueToAddress(oldDhcpServer),inv.getL3NetworkUuid()
DHCP\ server\ ip\ [%s]\ is\ already\ existed\ in\ l3\ network\ [%s] = 三层网络[{1}]已经配置了DHCP服务器地址[{0}]

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:1475
# args: dhcpServerIp
DHCP\ server\ ip\ [%s]\ can\ not\ be\ equaled\ to\ gateway\ ip = DHCP服务器地址[{0}]不能等于网关地址

# at: src/main/java/org/zstack/network/service/flat/FlatDhcpBackend.java:1481
# args: dhcpServerIp
DHCP\ server\ ip\ [%s]\ can\ not\ be\ configured\ to\ system\ l3 = 系统网络不能配置DHCP服务器地址[{0}]

# at: src/main/java/org/zstack/network/service/flat/FlatEipApiInterceptor.java:99
# args: vmNicUuid
L2Network\ where\ vip's\ L3Network\ based\ hasn't\ attached\ the\ cluster\ where\ vmNic[uuid\:%s]\ located = 基于虚拟IP三层网络的二层网络没有绑定到虚拟机网卡所在的集群

# at: src/main/java/org/zstack/network/service/flat/FlatEipBackend.java:573
# args: vmUuid,vm.getState()
unable\ to\ apply\ the\ EIP\ operation\ for\ the\ the\ vm[uuid\:%s,\ state\:%s],\ because\ cannot\ find\ the\ VM's\ hostUUid = 无法为虚拟机[uuid:{0}, state:{1}]应用EIP操作，因为无法找到该虚拟机的物理机uuid(hostUuid)

# at: src/main/java/org/zstack/network/service/flat/FlatUserdataBackend.java:353
# args: struct.getHostUuid()
host[uuid\:%s]\ is\ not\ connected = 物理机[uuid:{0}]未连接

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:135
# args: l3Uuids,LoadBalancerConstants.LB_NETWORK_SERVICE_TYPE_STRING
L3\ networks[uuids\:%s]\ of\ the\ vm\ nics\ has\ no\ network\ service[%s]\ enabled = 虚拟机网卡的三层网络没有可用的网络服务

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:145
# args: existingNics,msg.getListenerUuid()
the\ vm\ nics[uuid\:%s]\ are\ already\ on\ the\ load\ balancer\ listener[uuid\:%s] = 虚拟机网卡[uuid:{0}]已经处于负载均衡监听器[uuid:{1}]上

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:257
# args: tag,s,LoadBalancerConstants.MAX_CONNECTION_LIMIT
invalid\ max\ connection[%s],\ %s\ is\ larger\ than\ upper\ threshold\ %d = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:279
# args: msg.getLoadBalancerPort(),luuid
conflict\ loadBalancerPort[%s],\ a\ listener[uuid\:%s]\ has\ used\ that\ port = 冲突的负载均衡器端口(loadBalancerPort)[{0}]，一个监听器[uuid:{1}]已经使用了该端口

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:284
# args: 
udp\ port\ 53\ is\ used\ by\ dns\ daemon = udp端口53已经被dns进程使用

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:297
# args: 
tcp\ port\ 22,\ 7272\ is\ used\ by\ vrouter = tcp端口22,7272已经被vrouter管理进程进程使用

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:324
# args: vo.getProtocol()
loadbalancer\ listener\ with\ type\ %s\ does\ not\ need\ certificate = [{0}]类型证书不需要证书

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:328
# args: msg.getListenerUuid(),msg.getCertificateUuid()
loadbalancer\ listener\ [uuid\:%s]\ already\ had\ certificate[uuid\:%s] = 

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:338
# args: msg.getCertificateUuid(),msg.getListenerUuid()
certificate\ [uuid\:%s]\ is\ not\ added\ to\ loadbalancer\ listener\ [uuid\:%s] = 证书[uuid:{0}]未添加到负载均衡监听器[uuid:{1}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerApiInterceptor.java:353
# args: target
healthCheck\ target\ [%s]\ error,\ it\ must\ be\ 'default'\ or\ number\ between[1~65535]\  = 健康检查端口[{0}]错误,值必须是'default'或者数字[1~65535]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerBase.java:1036
# args: msg.getVmNicUuids().get(0)
the\ L3\ network\ of\ vm\ nic[uuid\:%s]\ doesn't\ have\ load\ balancer\ service\ enabled = 虚拟机网卡[uuid:{0}]的L3网络没有启用负载均衡服务

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerBase.java:1063
# args: self.getUuid(),self.getProviderType(),msg.getVmNicUuids().get(0),providerType
service\ provider\ type\ mismatching.\ The\ load\ balancer[uuid\:%s]\ is\ provided\ by\ the\ service\ provider[type\:%s],\ but\ the\ L3\ network\ of\ vm\ nic[uuid\:%s]\ is\ enabled\ with\ the\ service\ provider[type\:\ %s] = 网络服务提供器的类型不匹配。负载均衡器[uuid:{0}]由服务提供器[type:{1}]提供，但虚拟机网卡[uuid:{2}]的L3网络启用服务器类型为[type: {3}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:97
# args: msg.getLoadBalancerUuid()
cannot\ find\ the\ load\ balancer[uuid\:%s] = 无法找到负载均衡器[uuid:{0}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:379
# args: tag.getTag()
cannot\ delete\ the\ system\ tag[%s].\ The\ load\ balancer\ plugin\ relies\ on\ it,\ you\ can\ only\ update\ it = 无法删除系统标签[{0}]。负载均衡器插件依赖于该标签，该标签只能被更新

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:398
# args: algorithm,LoadBalancerConstants.BALANCE_ALGORITHMS
invalid\ balance\ algorithm[%s],\ valid\ algorithms\ are\ %s = 无效的均衡算法[{0}]，有效的为[{1}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:412
# args: systemTag,s
invalid\ unhealthy\ threshold[%s],\ %s\ is\ not\ a\ number = 无效的不健康阈值[{0}]，[{1}]不是一个数字

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:426
# args: systemTag,s
invalid\ healthy\ threshold[%s],\ %s\ is\ not\ a\ number = 无效的健康阈值[{0}]，[{1}]不是一个数字

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:440
# args: systemTag,s
invalid\ healthy\ timeout[%s],\ %s\ is\ not\ a\ number = 无效的健康超时[{0}]，[{1}]不是一个数字

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:454
# args: systemTag,s
invalid\ connection\ idle\ timeout[%s],\ %s\ is\ not\ a\ number = 无效的连接空闲超时[{0}]，[{1}]不是一个数字

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:468
# args: systemTag,s
invalid\ health\ check\ interval[%s],\ %s\ is\ not\ a\ number = 无效的健康检查间隔[{0}]，[{1}]不是一个数字

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:482
# args: systemTag,s
invalid\ max\ connection[%s],\ %s\ is\ not\ a\ number = 无效的最大连接[{0}]，[{1}]不是一个数字

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:495
# args: systemTag
invalid\ health\ target[%s],\ the\ format\ is\ targetCheckProtocol\:port,\ for\ example,\ tcp\:default = 无效的健康检查目标[{0}]，格式为[目标检查协议(targetCheckProtocol):端口(port)], 例如[tcp:default]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:500
# args: systemTag,protocol,LoadBalancerConstants.HEALTH_CHECK_TARGET_PROTOCOLS
invalid\ health\ target[%s],\ the\ target\ checking\ protocol[%s]\ is\ invalid,\ valid\ protocols\ are\ %s = 无效的健康检查目标[{0}]，目标检查协议无效[{1}]，有效的为[{2}]

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:512
# args: systemTag,port
invalid\ invalid\ health\ target[%s],\ port[%s]\ is\ not\ a\ number = 无效的健康检查目标[{0}]，端口[{1}]不是一个数字

# at: src/main/java/org/zstack/network/service/lb/LoadBalancerManagerImpl.java:509
# args: systemTag,port
invalid\ invalid\ health\ target[%s],\ port[%s]\ is\ not\ in\ the\ range\ of\ [1,\ 65535] = 无效的无效健康检查目标[{0}]，端口[{1}]不在范围[1, 65535]内

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:206
# args: msg.getVmNicUuid(),msg.getVipUuid()
guest\ l3Network\ of\ vm\ nic[uuid\:%s]\ and\ vip\ l3Network\ of\ vip[uuid\:\ %s]\ are\ the\ same\ network = 虚拟机网卡[uuid:{0}]的客户L3网络和虚拟IP[uuid:{1}]的虚拟IP L3网络是同一个网络

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:181
# args: msg.getVipUuid(),useForList.toString()
the\ vip[uuid\:%s]\ has\ been\ occupied\ other\ network\ service\ entity[%s] = 虚拟IP[uuid:{0}]已经被其他网络服务占用

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:66
# args: msg.getRuleUuid(),state
Port\ forwarding\ rule[uuid\:%s]\ is\ not\ in\ state\ of\ Enabled,\ current\ state\ is\ %s = 端口转发规则[uuid:{0}]未启用，当前状态[{1}]

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:81
# args: msg.getUuid()
port\ forwarding\ rule\ rule[uuid\:%s]\ has\ not\ been\ attached\ to\ any\ vm\ nic,\ can't\ detach = 端口转发规则[uuid:{0}]尚未被挂载到任何虚拟机网卡，无法卸载

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:95
# args: msg.getRuleUuid(),vmNicUuid
port\ forwarding\ rule[uuid\:%s]\ has\ been\ attached\ to\ vm\ nic[uuid\:%s],\ can't\ attach\ again = 端口转发规则[uuid:{0}]已经被挂载到虚拟机网卡[uuid:{1}]，无法再次挂载

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:100
# args: msg.getRuleUuid(),state
port\ forwarding\ rule[uuid\:%s]\ is\ not\ in\ state\ of\ Enabled,\ \ current\ state\ is\ %s.\ A\ rule\ can\ only\ be\ attached\ when\ its\ state\ is\ Enabled = 端口转发规则[uuid:{0}]没有启用，当前状态为{1}。一个规则只能在启用时被挂载

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:119
# args: msg.getVmNicUuid(),msg.getRuleUuid()
guest\ l3Network\ of\ vm\ nic[uuid\:%s]\ and\ vip\ l3Network\ of\ port\ forwarding\ rule[uuid\:%s]\ are\ the\ same\ network = 虚拟机网卡[uuid:{0}]的客户L3网络和端口转发规则[uuid:{1}]的VIP L3网络是同一个网络

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:166
# args: msg.getVipPortStart(),msg.getVipPortEnd(),msg.getPrivatePortStart(),msg.getPrivatePortEnd()
for\ range\ port\ forwarding,\ the\ port\ range\ size\ must\ match;\ vip\ range[%s,\ %s]'s\ size\ doesn't\ match\ range[%s,\ %s]'s\ size = 对于范围端口转发，端口范围大小必须匹配；VIP范围[{0}, {1}]的大小不匹配范围[{2}, {3}]的大小

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:173
# args: msg.getAllowedCidr()
invalid\ CIDR[%s] = 无效的CIDR[{0}]

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:191
# args: vipStart,vipEnd,vo.getUuid(),vo.getVipPortStart(),vo.getVipPortEnd()
vip\ port\ range[vipStartPort\:%s,\ vipEndPort\:%s]\ overlaps\ with\ rule[uuid\:%s,\ vipStartPort\:%s,\ vipEndPort\:%s] = 虚拟IP（vip）端口范围[vipStartPort:{0}, vipEndPort:{1}]与规则[uuid:{2}, vipStartPort:{3}, vipEndPort:{4}]重叠

# at: src/main/java/org/zstack/network/service/portforwarding/PortForwardingApiInterceptor.java:243
# args: vm.getName(),vm.getUuid(),vipUuid
the\ VM[name\:%s\ uuid\:%s]\ already\ has\ port\ forwarding\ rules\ that\ have\ different\ VIPs\ than\ the\ one[uuid\:%s] = 虚拟机[name:{0} uuid:{1}]已经有端口转发规则，且与[uuid:{2}]有不同的VIPs

# at: src/main/java/org/zstack/network/service/vip/VipApiInterceptor.java:49
# args: msg.getAllocatorStrategy()
unsupported\ ip\ allocation\ strategy[%s] = 不支持的ip分配策略[{0}]

# at: src/main/java/org/zstack/network/service/vip/VipApiInterceptor.java:61
# args: msg.getRequiredIp()
requiredIp[%s]\ is\ not\ in\ valid\ IPv6\ mediaType = 请求的ip[{0}]不是有效的IPv6地址

# at: src/main/java/org/zstack/network/service/vip/VipApiInterceptor.java:56
# args: msg.getRequiredIp()
requiredIp[%s]\ is\ not\ in\ valid\ IPv4\ mediaType = 请求的ip[{0}]不是有效的IPv4地址

# at: src/main/java/org/zstack/network/service/vip/VipApiInterceptor.java:70
# args: msg.getRequiredIp(),msg.getL3NetworkUuid()
there\ is\ already\ a\ vip[%s]\ on\ l3Network[uuid\:%s] = 已有一个vip[{0}]在L3网络[uuid:{1}]上

# at: src/main/java/org/zstack/network/service/vip/VipBase.java:150
# args: self.getUuid(),self.getName(),self.getIp(),self.getServiceProvider()
service\ provider\ of\ the\ vip[uuid\:%s,\ name\:%s,\ ip\:\ %s]\ has\ been\ set\ to\ %s = vip[uuid:{0}, name:{1}, ip: {2}]的服务提供器已经被设置成[{3}]

# at: src/main/java/org/zstack/network/service/vip/VipBase.java:707
# args: self.getUuid(),self.getIp()
Vip\ [uuid\ %s,\ ip\ %s]\ of\ router\ public\ interface\ can\ not\ be\ deleted = 路由公共接口的虚拟IP[uuid {0}, ip {1}]不能删除

# at: src/main/java/org/zstack/network/service/vipQos/VipQosApiInterceptor.java:42
# args: 
VipQos\ for\ ipv6\ wil\ be\ added\ soon = 

# at: src/main/java/org/zstack/network/service/vipQos/VipQosApiInterceptor.java:52
# args: msg.getVipUuid()
VipQos\ for\ Vip\ [uuid\:\ %s]\ already\ existed = 虚拟IP[uuid: {0}]的Qos已经存在了

# at: src/main/java/org/zstack/network/service/vipQos/VipQosApiInterceptor.java:47
# args: msg.getVipUuid(),Integer.toString(msg.getPort())
VipQos\ for\ Vip\ [uuid\:\ %s]\ port\ %s\ already\ existed = 虚拟IP[uuid: {0}]的Qos端口{1}已经存在

# at: src/main/java/org/zstack/network/service/vipQos/VipQosApiInterceptor.java:58
# args: 
SetVipQos\ MUST\ set\ InboundBandwidth\ or\ OutboundBandwidth = 设置虚拟IP的Qos是必须设置上行网络带宽和下行网络带宽

# at: src/main/java/org/zstack/network/service/vipQos/VipQosApiInterceptor.java:70
# args: msg.getUuid()
VipQos\ for\ Vip\ [uuid\:\ %s]\ does\ not\ exist = 虚拟IP[uuid: {0}]的Qos不存在

# at: src/main/java/org/zstack/network/service/vipQos/VipQosApiInterceptor.java:65
# args: msg.getUuid(),Integer.toString(msg.getPort())
VipQos\ for\ Vip\ [uuid\:\ %s]\ port\ %s\ does\ not\ exist = 虚拟IP[uuid: {0}]的Qos端口{1}不存在

# at: src/main/java/org/zstack/network/service/vipQos/VipQosManagerImpl.java:124
# args: vipUuid
Can\ not\ find\ VipQos\ backend\ for\ Vip\ [uuid\:%s] = 未找到虚拟IP的Qos后端

# at: src/main/java/org/zstack/network/service/vipQos/flat/FlatVipQosBackend.java:197
# args: hostUuid
operation\ error,\ vip\ %s\ has\ not\ bind\ to\ vm = 操作失败，虚拟IP{0}没有绑定虚拟机

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouter.java:261
# args: self.getName(),self.getUuid(),self.getState()
the\ virtual\ router[name\:%s,\ uuid\:%s,\ current\ state\:%s]\ is\ not\ running,and\ cannot\ perform\ required\ operation.\ Please\ retry\ your\ operation\ later\ once\ it\ is\ running = 云路由[name:{0}, uuid:{1}, current state:{2}]没有运行，无法执行请求的操作。请在其启动后重试

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouter.java:266
# args: self.getUuid(),getSelf().getStatus(),msg.getPath()
virtual\ router[uuid\:%s]\ is\ in\ status\ of\ %s\ that\ cannot\ make\ http\ call\ to\ %s = 云路由[uuid:{0}]处于状态{1}中，无法向{2}发送http调用

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouter.java:271
# args: self.getUuid(),msg.getPath()
virtual\ router[uuid\:%s]\ has\ no\ management\ nic\ that\ cannot\ make\ http\ call\ to\ %s = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouter.java:381
# args: getSelf().getUuid()
appliance\ vm\ %s\ reconnect\ failed = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouter.java:457
# args: info.getIp(),info.getMac(),vr.getUuid(),vr.getManagementNic().getIp(),rsp.getError()
unable\ to\ add\ nic[ip\:%s,\ mac\:%s]\ to\ virtual\ router\ vm[uuid\:%s\ ip\:%s],\ because\ %s = 不能添加网卡[ip:{0}, mac:{1}]到虚拟路由设备[uuid:{2} ip:{3}]，因为{4}

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouter.java:627
# args: info,vr.getUuid(),vr.getManagementNic().getIp(),rsp.getError()
unable\ to\ detach\ nic[%s]\ from\ virtual\ router\ vm[uuid\:%s\ ip\:%s],\ because\ %s = 无法从云路由设备[uuid:{1} ip:{2}]上卸载网卡[{0}]，错误细节: {3}

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:149
# args: msg.getImageUuid(),type,ImageMediaType.RootVolumeTemplate
image[uuid\:%s]'s\ mediaType\ is\ %s,\ the\ mediaType\ of\ a\ virtual\ router\ image\ must\ be\ %s = 镜像[uuid:{0}]的mediaType为{1}，云路由的mediaType必须为{2}

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:155
# args: msg.getImageUuid(),format
image[uuid\:%s]\ is\ of\ format\ %s,\ cannot\ be\ used\ for\ virtual\ router = 镜像[uuid:{0}]的格式为{1}，无法被用于云路由

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:125
# args: msg.getManagementNetworkUuid(),msg.getZoneUuid()
management\ network[uuid\:%s]\ is\ not\ in\ the\ same\ zone[uuid\:%s]\ this\ offering\ is\ going\ to\ create = 管理网络[uuid:{0}]和将要创建的规格不处于同一个区域（zone）[uuid:{1}]中

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:138
# args: msg.getManagementNetworkUuid(),msg.getZoneUuid()
public\ network[uuid\:%s]\ is\ not\ in\ the\ same\ zone[uuid\:%s]\ this\ offering\ is\ going\ to\ create = 公共网络[uuid:{0}]和将要创建的规格不处于同一个区域（zone）[uuid:{1}]中

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:166
# args: msg.getPublicNetworkUuid()
the\ L3\ network[uuid\:\ %s]\ has\ the\ SNAT\ service\ enabled,\ it\ cannot\ be\ used\ as\ a\ public\ network = L3网络[uuid: {0}]启用了SNAT服务，无法被用作公共网络

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:164
# args: msg.getManagementNetworkUuid()
the\ L3\ network[uuid\:\ %s]\ has\ the\ SNAT\ service\ enabled,\ it\ cannot\ be\ used\ as\ a\ management\ network = L3网络[uuid: {0}]启用了SNAT服务，无法被用作管理网络

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:173
# args: msg.getManagementNetworkUuid(),msg.getPublicNetworkUuid()
the\ L3\ network[uuid\:\ %s]\ is\ same\ network\ address\ with\ [uuid\:\ %s],\ it\ cannot\ be\ used\ for\ virtual\ router = L3网络[uuid: {0}] 和 网络 [uuid: {1}] 具有相同的网络地址，无法被用于云路由

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:183
# args: managementNetworkUuid
the\ management\ network[uuid\:%s]\ doesn't\ have\ any\ IP\ range = 管理网络[uuid:{0}]不包含任何的IP范围

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterApiInterceptor.java:200
# args: managementNetworkUuid,gateway
the\ management\ network[uuid\:%s,\ gateway\:%s]\ is\ not\ reachable = 管理网络[uuid:{0}, gateway:{1}]不可抵达

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterKvmBackend.java:107
# args: iso.getIsoPath(),vrSpec.getDestHost().getUuid(),vrSpec.getDestHost().getManagementIp(),iso.getVirtualRouterUuid(),rsp.getError()
failed\ to\ create\ VirtualRouterBootstrapIso[%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s]\ for\ virtual\ router[uuid\:%s],\ because\ %s = 创建云路由引导镜像（VirtualRouterBootstrapIso）[{0}]失败，该操作是在KVM物理机[uuid:{1}, ip:{2}]上为云路由[uuid:{3}]执行的，原因为{4}

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterKvmBackend.java:140
# args: iso.getIsoPath(),hostUuid,iso.getVirtualRouterUuid(),rsp.getError()
failed\ to\ delete\ VirtualRouterBootstrapIso[%s]\ on\ kvm\ host[uuid\:%s]\ for\ virtual\ router[uuid\:%s],\ because\ %s = 删除云路由引导镜像（VirtualRouterBootstrapIso）[{0}]失败，该操作是在KVM物理机[uuid:{1}]上为云路由[uuid:{2}]执行的，原因为{3}

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterManagerImpl.java:276
# args: 
cannot\ create\ virtual\ Router\ vm\ while\ virtual\ router\ network\ overlaps\ with\ private\ network\ in\ ip\  = 当云路由规格的网络和私有网络IP范围有重叠时，无法创建云路由设备

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterManagerImpl.java:581
# args: offeringUuid
No\ virtual\ router\ instance\ offering\ with\ uuid\:%s\ is\ found = 

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterManagerImpl.java:1139
# args: msg.getL3NetworkUuid()
failed\ tot\ attach\ virtual\ router\ network\ services\ to\ l3Network[uuid\:%s].\ When\ eip\ is\ selected,\ snat\ must\ be\ selected\ too = 挂载虚拟路由网络服务到L3网络[uuid:{0}]失败。选中EIP服务时，SNAT服务也必须被选中

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterManagerImpl.java:1143
# args: msg.getL3NetworkUuid()
failed\ tot\ attach\ virtual\ router\ network\ services\ to\ l3Network[uuid\:%s].\ When\ port\ forwarding\ is\ selected,\ snat\ must\ be\ selected\ too = 挂载虚拟路由网络服务到L3网络[uuid:{0}]失败。选中端口转发服务时，SNAT服务也必须被选中

# at: src/main/java/org/zstack/network/service/virtualrouter/VirtualRouterManagerImpl.java:1550
# args: toDeleteNics.stream().map( n -> n.getUuid()).collect(Collectors.toList())
can\ not\ detach\ nic\ [uuid\:%s] = 无法卸载网卡nic[uuid:{0}]

# at: src/main/java/org/zstack/network/service/virtualrouter/dhcp/VirtualRouterDhcpBackend.java:126
# args: vr.getUuid(),vr.getManagementNic().getIp(),rsp.getError(),struct
unable\ to\ add\ dhcp\ entries\ to\ virtual\ router\ vm[uuid\:%s\ ip\:%s],\ because\ %s,\ dhcp\ entry[%s] = 无法向云路由[uuid:{0} ip:{1}]添加DHCP条目，因为{2}，DHCP条目为[{3}]

# at: src/main/java/org/zstack/network/service/virtualrouter/dhcp/VirtualRouterSyncDHCPOnStartFlow.java:177
# args: vr.getUuid(),vr.getManagementNic().getIp(),ret.getError()
unable\ to\ program\ dhcp\ entries\ served\ by\ virtual\ router[uuid\:%s,\ ip\:%s],\ %s = 无法执行由云路由[uuid:{0}, ip:{1}]提供的DHCP条目{2}.

# at: src/main/java/org/zstack/network/service/virtualrouter/dns/VirtualRouterDnsBackend.java:210
# args: vr.getUuid(),vr.getManagementNic().getIp(),struct,l3.getUuid(),l3.getName(),ret.getError()
virtual\ router[uuid\:%s,\ ip\:%s]\ failed\ to\ configure\ dns%s\ for\ L3Network[uuid\:%s,\ name\:%s],\ %s = 云路由[uuid:{0}, ip:{1}]未能为L3网络[uuid:{3}, name:{4}]配置DNS{2}，错误细节: {5}

# at: src/main/java/org/zstack/network/service/virtualrouter/dns/VirtualRouterSyncDnsOnStartFlow.java:124
# args: vr.getName(),vr.getUuid(),JSONObjectUtil.toJsonString(dns),ret.getError()
virtual\ router[name\:\ %s,\ uuid\:\ %s]\ failed\ to\ configure\ dns%s,\ %s\  = 云路由[name: {0}, uuid: {1}]未能配置DNS{2}，错误细节: {3}

# at: src/main/java/org/zstack/network/service/virtualrouter/eip/VirtualRouterEipBackend.java:162
# args: struct.getEip().getUuid(),struct.getEip().getName(),struct.getVip().getIp(),struct.getNic().getUuid(),vr.getUuid(),ret.getError()
failed\ to\ create\ eip[uuid\:%s,\ name\:%s,\ ip\:%s]\ for\ vm\ nic[uuid\:%s]\ on\ virtual\ router[uuid\:%s],\ %s = 无法为虚拟机网卡[uuid:{3}]在云路由[uuid:{4}]上创建EIP[uuid:{0}, name:{1}, ip:{2}]，错误细节: {5}

# at: src/main/java/org/zstack/network/service/virtualrouter/eip/VirtualRouterEipBackend.java:198
# args: offering.getUuid(),l3inv.getUuid(),l3inv.getZoneUuid(),struct.getVip().getL3NetworkUuid(),struct.getEip().getUuid()
found\ a\ virtual\ router\ offering[uuid\:%s]\ for\ L3Network[uuid\:%s]\ in\ zone[uuid\:%s];\ however,\ the\ network's\ public\ network[uuid\:%s]\ is\ not\ the\ same\ to\ EIP[uuid\:%s]'s;\ you\ may\ need\ to\ use\ system\ tag\ guestL3Network\:\:l3NetworkUuid\ to\ specify\ a\ particular\ virtual\ router\ offering\ for\ the\ L3Network = 在区域（zone）[uuid:{2}]上为L3网络[uuid:{1}]找到了云路由规格[uuid:{0}]；但是，其公共网络[uuid:{3}]和EIP[uuid:{4}]的公共网络不是同一个L3网络。你可能需要使用系统标签[guestL3Network::l3NetworkUuid]为该L3网络指定一个特定的云路有规格

# at: src/main/java/org/zstack/network/service/virtualrouter/eip/VirtualRouterEipBackend.java:299
# args: struct.getEip().getUuid(),struct.getEip().getName(),struct.getVip().getIp(),struct.getNic().getUuid(),vr.getUuid(),ret.getError()
failed\ to\ remove\ eip[uuid\:%s,\ name\:%s,\ ip\:%s]\ for\ vm\ nic[uuid\:%s]\ on\ virtual\ router[uuid\:%s],\ %s = 未能在云路由[uuid:{4}]上为虚拟机网卡[uuid:{3}]移除EIP[uuid:{0}, name:{1}, ip:{2}]，错误细节: {5}

# at: src/main/java/org/zstack/network/service/virtualrouter/eip/VirtualRouterSyncEipOnStartFlow.java:203
# args: vr.getUuid(),ret.getError()
failed\ to\ sync\ eip\ on\ virtual\ router[uuid\:%s],\ %s = 未能在云路由[uuid:{0}]上同步EIP，错误细节: {1}

# at: src/main/java/org/zstack/network/service/virtualrouter/eip/VirtualRouterSyncEipOnStartFlow.java:125
# args: oldRef.getEipUuid(),oldRef.getVirtualRouterVmUuid()
Eip\ [uuid\:%s]\ already\ bound\ to\ router\ [uuid\:%s] = 

# at: src/main/java/org/zstack/network/service/virtualrouter/lb/VirtualRouterLoadBalancerBackend.java:131
# args: msg.getVmNicUuids(),vrUuids
new\ add\ vm\ nics[uuids\:%s]\ and\ attached\ vmnics\ are\ not\ on\ the\ same\ vrouter,\ they\ are\ on\ vrouters[uuids\:%s] = 新添加的虚拟网卡[uuids:{0}]和绑定虚拟机的网卡没有在一个云路由上，它们分别在云路由[uuids:{1}]上

# at: src/main/java/org/zstack/network/service/virtualrouter/lb/VirtualRouterLoadBalancerBackend.java:161
# args: msg.getVmNicUuids(),peerL3NetworkUuids,msg.getLoadBalancerUuid(),vrUuids
new\ add\ vm\ nics[uuids\:%s]\ and\ peer\ l3s[uuids\:%s]\ of\ loadbalancer[uuid\:\ %s]'s\ vip\ are\ not\ on\ the\ same\ vrouter,\ they\ are\ on\ vrouters[uuids\:%s] = 新添加的虚拟机网卡[uuids:{0}]和负载均衡器[uuid: {2}]的弹性IP的三层网络[uuids:{1}]没有在相同的云路由上，它们分别在云路由[uuids:{3}]上

# at: src/main/java/org/zstack/network/service/virtualrouter/lb/VirtualRouterLoadBalancerBackend.java:1264
# args: struct.getLb().getUuid()
cannot\ find\ virtual\ router\ for\ load\ balancer\ [uuid\:%s] = 未能为负载均衡器[uuid:{0}]找到云路由

# at: src/main/java/org/zstack/network/service/virtualrouter/nat/VirtualRouterSnatBackend.java:86
# args: guestL3.getUuid(),guestL3.getName(),offering.getPublicNetworkUuid(),offering.getUuid(),offering.getName()
guest\ l3Network[uuid\:%s,\ name\:%s]\ needs\ SNAT\ service\ provided\ by\ virtual\ router,\ but\ public\ l3Network[uuid\:%s]\ of\ virtual\ router\ offering[uuid\:\ %s,\ name\:%s]\ is\ the\ same\ to\ this\ guest\ l3Network = 用户L3网络[uuid:{0}, name:{1}]需要云路由提供的SNAT服务，但是云路由规格[uuid: {3}, name:{4}]的公共L3网络[uuid:{2}]与该客户L3网络相同

# at: src/main/java/org/zstack/network/service/virtualrouter/nat/VirtualRouterSnatBackend.java:144
# args: vr.getUuid(),vr.getManagementNic().getIp(),JSONObjectUtil.toJsonString(info),spec.getVmInventory().getUuid(),spec.getVmInventory().getName(),struct.getL3Network().getUuid(),struct.getL3Network().getName(),ret.getError()
virtual\ router[uuid\:%s,\ ip\:%s]\ failed\ to\ apply\ snat[%s]\ for\ vm[uuid\:%s,\ name\:%s]\ on\ L3Network[uuid\:%s,\ name\:%s],\ because\ %s = 云路由[uuid:{0}, ip:{1}]无法为虚拟机[uuid:{3}, name:{4}]在L3网络[uuid:{5}, name:{6}]上应用SNAT规则[{2}]，因为: {7}

# at: src/main/java/org/zstack/network/service/virtualrouter/nat/VirtualRouterSyncSNATOnStartFlow.java:108
# args: vr.getName(),vr.getUuid(),JSONObjectUtil.toJsonString(snatInfo),ret.getError()
virtual\ router[name\:\ %s,\ uuid\:\ %s]\ failed\ to\ sync\ snat%s,\ %s = 云路由[name: {0}, uuid: {1}]未能同步SNAT{2}，错误细节: {3}

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/ApplyPortforwardingRuleOnVirtualRouterVmFlow.java:80
# args: to.getVipIp(),to.getPrivateIp(),to.getVipPortStart(),to.getVipPortEnd(),to.getPrivatePortStart(),to.getPrivatePortEnd(),ret.getError()
failed\ to\ create\ port\ forwarding\ rule[vip\ ip\:\ %s,\ private\ ip\:\ %s,\ vip\ start\ port\:\ %s,\ vip\ end\ port\:\ %s,\ private\ start\ port\:\ %s,\ private\ end\ port\:\ %s],\ because\ %s = 无法创建端口转发规则[vip ip: {0}, private ip: {1}, vip start port: {2}, vip end port: {3}, private start port: {4}, private end port: {5}]，错误细节: {6}

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/ReleasePortForwardingRuleOnVirtualRouterVmFlow.java:74
# args: JSONObjectUtil.toJsonString(to),ret.getError()
failed\ to\ revoke\ port\ forwarding\ rules\ %s,\ because\ %s = 未能解除端口转发规则{0}，原因: {1}

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/VirtualRouterPortForwardingBackend.java:160
# args: offering.getUuid(),struct.getGuestL3Network().getUuid(),struct.getGuestL3Network().getZoneUuid(),struct.getVip().getL3NetworkUuid(),struct.getRule().getUuid()
found\ a\ virtual\ router\ offering[uuid\:%s]\ for\ L3Network[uuid\:%s]\ in\ zone[uuid\:%s];\ however,\ the\ network's\ public\ network[uuid\:%s]\ is\ not\ the\ same\ to\ PortForwarding\ rule[uuid\:%s]'s;\ you\ may\ need\ to\ use\ system\ tag\ guestL3Network\:\:l3NetworkUuid\ to\ specify\ a\ particular\ virtual\ router\ offering\ for\ the\ L3Network = 在区域（zone）[uuid:{2}]内为L3网络[uuid:{1}]找到了一个云路由规格[uuid:{0}]；然而，其网络的公共网络[uuid:{3}]和端口转发规则[uuid:{4}]的公共网络不一致。你可能需要使用系统标签[guestL3Network::l3NetworkUuid]为该L3网络指定一个特定的云路有规格

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/VirtualRouterPortForwardingBackend.java:226
# args: rule.getVipPortStart(),rule.getVipPortEnd(),rule.getPrivatePortStart(),rule.getPrivatePortEnd()
virtual\ router\ doesn't\ support\ port\ forwarding\ range\ redirection,\ the\ vipPortStart\ must\ be\ equals\ to\ privatePortStart\ and\ vipPortEnd\ must\ be\ equals\ to\ privatePortEnd;but\ this\ rule\ rule\ has\ a\ mismatching\ range\:\ vip\ port[%s,\ %s],\ private\ port[%s,\ %s] = 云路由不支持范围性的端口转发重定向，vipPortStart和privatePortStart必须一致，vipPortEnd和privatePortEnd必须一致，但这条规则有个不匹配的范围: vip端口范围[{0}, {1}]，私有端口范围[{2}, {3}]

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/VirtualRouterPortForwardingBackend.java:382
# args: vrVO.getUuid(),ret.getError()
failed\ to\ add\ portforwardings\ on\ virtual\ router[uuid\:%s],\ %s = 在云路由[uuid:{0}]添加端口转发失败，{1}

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/VirtualRouterPortForwardingBackend.java:449
# args: vrVO.getUuid(),ret.getError()
failed\ to\ revoke\ port\ forwardings\ on\ virtual\ router[uuid\:%s],\ %s = 取消在云路由[uuid:{0}]上端口转发服务失败，{1}

# at: src/main/java/org/zstack/network/service/virtualrouter/portforwarding/VirtualRouterSyncPortForwardingRulesOnStartFlow.java:196
# args: vr.getName(),vr.getUuid(),ret.getError()
failed\ to\ sync\ port\ forwarding\ rules\ served\ by\ virtual\ router[name\:\ %s,\ uuid\:\ %s],\ because\ %s = 未能同步由云路由[name: {0}, uuid: {1}]提供的端口转发规则，因为: {2}

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterCreateVipForPublicIpFlow.java:65
# args: vr.getName(),vr.getUuid(),nic.getIp(),nic.getL3NetworkUuid()
virtual\ router[name\:\ %s,\ uuid\:\ %s]\ failed\ to\ create\ vip\ for\ public\ ip\ %s\ because\ no\ ip\ range\ for\ l3NetworkUuid\ %s = 虚拟路由[name: {0}, uuid: {1}]为公有IP创建虚拟IP失败，因为三层网络[uuid:{3}]的没有IP段

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBackend.java:175
# args: vipvo.getVirtualRouterVmUuid(),vrState
virtual\ router[uuid\:%s,\ state\:%s]\ is\ not\ running,\ current\ HA\ has\ not\ been\ supported,\ please\ manually\ start\ this\ virtual\ router = 云路由[uuid:{0}, state:{1}]没有运行，当前HA机制尚不支持，请手动启动该云路由

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBackend.java:339
# args: vips.stream().map( v -> v.getIp()).collect(Collectors.toList()),nic.getVmInstanceUuid(),nic.getUuid(),nic.getIp(),ret.getError()
failed\ to\ sync\ vips[ips\:\ %s]\ on\ virtual\ router[uuid\:%s]\ for\ attaching\ nic[uuid\:\ %s,\ ip\:\ %s],\ because\ %s = 为了绑定网卡[uuid: {2}, ip: {3}]在云路由[uuid:{1}]上同步虚拟IP[ips: {0}]失败，因为{4}

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBaseBackend.java:180
# args: tos,vr.getUuid(),ret.getError()
failed\ to\ create\ vip%s\ on\ virtual\ router[uuid\:%s],\ because\ %s = 未能在云路由[uuid:{1}]上创建VIP{0}，因为{2}

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBaseBackend.java:146
# args: tos,ret.getError()
failed\ to\ remove\ vip%s,\ because\ %s = 未能移除VIP{0}，因为{1}

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBaseBackend.java:243
# args: offering.getUuid(),s.getL3Network().getUuid(),s.getL3Network().getZoneUuid(),self.getL3NetworkUuid(),self.getUuid()
found\ a\ virtual\ router\ offering[uuid\:%s]\ for\ L3Network[uuid\:%s]\ in\ zone[uuid\:%s];\ however,\ the\ network's\ public\ network[uuid\:%s]\ is\ not\ the\ same\ to\ VIP[uuid\:%s]'s;\ you\ may\ need\ to\ use\ system\ tag\ guestL3Network\:\:l3NetworkUuid\ to\ specify\ a\ particular\ virtual\ router\ offering\ for\ the\ L3Network = 在区域（zone）[uuid:{2}]内为L3网络[uuid:{1}]找到了一个云路由规格[uuid:{0}]；然而，其网络的公共网络[uuid:{3}]和VIP[uuid:{4}]的公共网络不一致。你可能需要使用系统标签[guestL3Network::l3NetworkUuid]为该L3网络指定一个特定的云路有规格

# at: src/main/java/org/zstack/network/service/virtualrouter/vip/VirtualRouterVipBaseBackend.java:202
# args: vipvo.getVirtualRouterVmUuid(),vrState
virtual\ router[uuid\:%s,\ state\:%s]\ is\ not\ running = 云路由[uuid:{0}, state:{1}]没有运行

# at: src/main/java/org/zstack/network/service/virtualrouter/vyos/VyosChangePrivateL3FirewallDefaultActionExtensionPoint.java:67
# args: nic.getIp(),nic.getMac(),nic.getVmInstanceUuid(),rsp.getError()
failed\ to\ change\ nic[ip\:%s,\ mac\:%s]\ firewall\ default\ action\ of\ virtual\ router\ vm[uuid\:%s],\ because\ %s = 修改云路由[uuid:{2}]的网卡[ip:{0}, mac:{1}]的默认防火墙规则失败，因为{3}

# at: src/main/java/org/zstack/network/service/virtualrouter/vyos/VyosVersionVersionManagerImpl.java:56
# args: vrUuid,ret.getError()
virtual\ router[uuid\:\ %s]\ failed\ to\ get\ version\ because\ %s\  = 获取云路由[uuid: {0}]版本失败，因为{1}

# at: src/main/java/org/zstack/network/service/virtualrouter/vyos/VyosVersionVersionManagerImpl.java:63
# args: vrUuid
virtual\ router[uuid\:\ %s]\ doesn't\ have\ version = 云路由[uuid: {0}]没有版本信息

# at: src/main/java/org/zstack/network/service/virtualrouter/vyos/VyosVersionVersionManagerImpl.java:69
# args: vrUuid,ret.getVersion()
virtual\ router[uuid\:\ %s]\ version\ [%s]\ format\ error = 云路由[uuid{0}]版本号[{1}]格式错误

# at: src/main/java/org/zstack/network/service/virtualrouter/vyos/VyosVersionVersionManagerImpl.java:75
# args: vrUuid,ret.getVersion(),managementVersion
virtual\ router[uuid\:\ %s]\ version\ [%s]\ is\ older\ than\ management\ node\ version\ [%s] = 云路由[uuid: {0}]版本[{1}]比管理节点的版本[{2}]旧

# at: src/main/java/org/zstack/pciDevice/PciDeviceAllocatorFactory.java:81
# args: vo.getUuid(),vo.getHostUuid(),attachedPciUuid,dstHostUuid
specified\ pci\ devices\ not\ on\ same\ host\:\ pci\ device[uuid\:\ %s]\ on\ host[uuid\:\ %s]\ while\ pci\ device[uuid\:\ %s]\ on\ host[uuid\:\ %s] = 云主机试图挂载来自不同物理机的PCI设备：设备[uuid: {0}]来自物理机[uuid: {1}]，而设备[uuid: {2}]来自物理机[uuid: {3}]

# at: src/main/java/org/zstack/pciDevice/PciDeviceAllocatorFactory.java:112
# args: vmUuid,specMap.keySet()
failed\ to\ start\ vm[uuid\:%s]\ because\ not\ all\ pci\ specs[uuids\:%s]\ exist = 云主机[uuid:{0}]启动失败，因为所设置的PCI设备规格[uuids:{1}]中有部分不存在

# at: src/main/java/org/zstack/pciDevice/PciDeviceAllocatorFactory.java:217
# args: 
cannot\ find\ required\ pci\ device\ on\ hosts = 没有物理机满足需要的pci 设备条件

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:420
# args: msg.getPciDeviceUuid()
pci\ device[uuid\:%s]\ doesn't\ exist = PCI设备[uuid:{0}]不存在

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:430
# args: pci.getHostUuid()
pci\ devices\ in\ host[uuid\:%s]\ already\ sriov\ virtualized = 物理机[uuid:{0}]上的PCI设备已经SRIOV虚拟化，无法再次切分

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:441
# args: pci.getHostUuid()
cannot\ sr-iov\ virtualize\ pci\ devices\ in\ host[uuid\:%s]\ that\ are\ attached\ to\ vm = 物理机[uuid:{0}]上的PCI设备已经挂载到云主机，无法SRIOV虚拟化

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:460
# args: minIns,pci.getType(),pci.getHostUuid()
only\ %d\ virtual\ pci\ devices\ can\ be\ generated\ by\ %ss\ in\ host[uuid\:%s] = 物理机[uuid:{2}]上的{1}类型PCI设备最多被切分出{0}个虚拟PCI设备

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:574
# args: pci.getHostUuid(),pci.getUuid()
the\ host[uuid\:%s]\ that\ pci\ device[uuid\:%s]\ in\ is\ not\ Connected = PCI设备[uuid:{1}]所在物理机[uuid:{0}]已失联

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:482
# args: msg.getPciDeviceUuid()
pci\ device[uuid\:%s]\ doesn't\ exist\ or\ is\ not\ sriov\ virtualized = PCI设备[uuid:{0}]不存在，或者未处于SRIOV虚拟化状态

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:493
# args: pci.getHostUuid()
virtual\ pci\ devices\ generated\ from\ pci\ devices\ in\ host[uuid\:%s]\ still\ attached\ to\ vm = 物理机[uuid:{0}]上存在仍处于已挂载状态的虚拟PCI设备，无法执行虚拟化还原操作

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:515
# args: msg.getPciDeviceUuid()
pci\ device[uuid\:%s]\ cannot\ be\ virtualized\ into\ mdevs,\ make\ sure\ it's\ enabled\ and\ un-attached = PCI设备[uuid:{0}]无法被切分为MDEV设备，请确保它处于启用状态，并且没有挂载到云主机

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:526
# args: msg.getPciDeviceUuid(),msg.getMdevSpecUuid()
pci\ device[uuid\:%s]\ cannot\ be\ virtualized\ by\ mdev\ spec[uuid\:%s] = PCI设备[uuid:{0}]无法使用MDEV设备规格[uuid:{1}]进行虚拟化切分

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:548
# args: msg.getPciDeviceUuid()
pci\ device[uuid\:%s]\ is\ not\ virtualized\ into\ mdevs = PCI设备[uuid:{0}]未处于VFIO_MDEV虚拟化状态

# at: src/main/java/org/zstack/pciDevice/PciDeviceApiInterceptor.java:565
# args: msg.getPciDeviceUuid()
mdev\ devices\ generated\ from\ pci\ device[uuid\:%s]\ still\ attached\ to\ vm = PCI设备[uuid:{0}]切分出的MDEV设备仍处于已挂载状态，无法执行虚拟化还原操作

# at: src/main/java/org/zstack/pciDevice/PciDeviceManager.java:525
# args: msg.getPciDeviceUuid(),msg.getVmInstanceUuid()
can\ not\ attach\ this\ pci\ device[uuid\:%s]\ to\ vm[uuid\:%s]\ due\ to\ host\ allocation = 由于物理机分配问题导致不能将PCI设备[uuid:{0}]绑定虚拟机[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/PciDeviceManager.java:790
# args: msg.getVmInstanceUuid()
can\ not\ migrate\ vm[uuid\:%s]\ since\ pci\ device\ attached = 当PCI设备绑定后不能迁移虚拟机[uuid:{0}]

# at: src/main/java/org/zstack/pciDevice/PciDeviceManager.java:821
# args: msg.getVolumeUuid()
cannot\ migrate\ root\ volume[uuid\:%s]\ because\ there\ are\ pci\ devices\ attached = 不能迁移根云盘[uuid:{0}]，因为它所在的云主机挂载了PCI设备

# at: src/main/java/org/zstack/pciDevice/PciDeviceManager.java:1033
# args: specUuid,replyHostUuid,vmUuid
failed\ to\ find\ enough\ pci\ device\ of\ spec[uuid\:%s]\ in\ dest\ host[uuid\:%s]\ for\ vm[uuid\:%s] = 无法在物理机[uuid:{1}]上为云主机[uuid:{2}]找到足够多满足规格[uuid:{0}]的PCI设备

# at: src/main/java/org/zstack/pciDevice/PciDeviceManager.java:1119
# args: tokens.get(PciDeviceSystemTags.PCI_DEVICE_TOKEN),vmUuid
pci\ device[uuid\:%s]\ are\ invalid(non-exists,\ disabled\ or\ already\ attached)\ for\ vm\ instance[uuid\:%s] = PCI设备[uuid:{0}]无法挂载到云主机[uuid:{1}]，因为它不存在或已禁用或已挂载

# at: src/main/java/org/zstack/pciDevice/PciHostChangeStateExtension.java:66
# args: inventory.getUuid(),hasPciVmUuids.toString()
The\ host\ [%s]\ has\ failed\ to\ enter\ the\ maintenance,\ The\ vm\ [%s]\ cannot\ migrate\ automatically\ because\ it\ contains\ the\ PCI\ device = 物理机[{0}]进入维护状态失败，这个虚拟机[{1}]不能自动迁移，因为虚拟机包含了PCI设备

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:190
# args: 
cluster\ uuids\ or\ host\ uuid\ or\ vm\ uuid\ can\ not\ be\ set\ at\ same\ time = 获取候选规格列表时不要同时指定集群UUIDs、物理机UUID或云主机UUID

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:197
# args: 
clusters\ not\ exist\ or\ disabled = 集群不存在或已禁用

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:231
# args: type,legalTypes
illegal\ mdev\ device\ type\ [%s],\ only\ %s\ are\ legal = 非法的MDEV设备类型[{0}]，只有{1}才是合法的

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:217
# args: vm.getUuid(),vm.getState()
vm\ instance[uuid\:%s,\ state\:%s]\ needs\ to\ be\ stopped\ to\ set\ pci\ device\ spec = 云主机[uuid:{0}, state:{1}]需要处于关机状态下才可以设置PCI设备规格

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:138
# args: type,legalTypes
illegal\ pci\ device\ type\ [%s],\ only\ %s\ are\ legal = 非法的PCI设备类型[{0}]，只有{1}才是合法的

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:150
# args: msg.getVmInstanceUuid(),msg.getPciSpecUuid()
vm[uuid\:%s]\ already\ has\ pci\ device\ spec[uuid\:%s] = 云主机[uuid:{0}]已经设置过了PCI设备规格[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:171
# args: msg.getVmInstanceUuid(),msg.getPciSpecUuid()
vm[uuid\:%s]\ doesn't\ have\ pci\ device\ spec[uuid\:%s] = 云主机[uuid:{0}]未设置PCI设备规格[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:178
# args: vm.getUuid(),vm.getState(),msg.getPciSpecUuid()
vm\ instance[uuid\:%s,\ state\:%s]\ needs\ to\ be\ stopped\ to\ remove\ pci\ device\ spec[uuid\:%s] = 云主机[uuid:{0}], state:{1}需要处于关机状态下才可以取消PCI设备规格[uuid:{2}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:243
# args: msg.getVmInstanceUuid(),msg.getMdevSpecUuid()
vm[uuid\:%s]\ already\ has\ mdev\ device\ spec[uuid\:%s] = 云主机[uuid:{0}]已经设置过了MDEV设备规格[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:251
# args: vm.getUuid(),vm.getState()
vm\ instance[uuid\:%s,\ state\:%s]\ needs\ to\ be\ stopped\ to\ set\ mdev\ device\ spec = 云主机[uuid:{0}, state:{1}]需要处于关机状态下才可以设置MDEV设备规格

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:264
# args: msg.getVmInstanceUuid(),msg.getMdevSpecUuid()
vm[uuid\:%s]\ doesn't\ have\ mdev\ device\ spec[uuid\:%s] = 云主机[uuid:{0}]未设置过MDEV设备规格[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationApiInterceptor.java:271
# args: vm.getUuid(),vm.getState(),msg.getMdevSpecUuid()
vm\ instance[uuid\:%s,\ state\:%s]\ needs\ to\ be\ stopped\ to\ remove\ mdev\ device\ spec[uuid\:%s] = 云主机[uuid:{0}, state:{1}]需要处于关机状态下才可以取消MDEV设备规格[uuid:{2}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationManagerImpl.java:161
# args: msg.getVmInstanceUuid(),rly.getError()
failed\ to\ get\ candidate\ hosts\ to\ start\ vm[uuid\:%s],\ %s = 无法为云主机[uuid:{0}]寻找到可启动的物理机：{1}

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationManagerImpl.java:315
# args: msg.getPciSpecUuid(),msg.getVmInstanceUuid()
pci\ device\ spec[uuid\:%s]\ is\ not\ available\ for\ vm[uuid\:%s] = 云主机[uuid:{1}]无法设置PCI设备规格[uuid:{0}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationManagerImpl.java:308
# args: msg.getVmInstanceUuid()
no\ pci\ device\ spec\ available\ for\ vm[uuid\:%s] = 云主机[uuid:{0}]无可用的PCI设备规格

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationManagerImpl.java:423
# args: msg.getMdevSpecUuid(),msg.getVmInstanceUuid()
mdev\ device\ spec[uuid\:%s]\ is\ not\ available\ for\ vm[uuid\:%s] = 云主机[uuid:{1}]无法设置MDEV设备规格[uuid:{0}]

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationManagerImpl.java:416
# args: msg.getVmInstanceUuid()
no\ mdev\ device\ spec\ available\ for\ vm[uuid\:%s] = 云主机[uuid:{0}]无可用的MDEV设备规格

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationManagerImpl.java:649
# args: specUuid,systemTag
pci\ device\ spec[uuid\:%s]\ doesn't\ exist = PCI设备规格[uuid:{0}]不存在

# at: src/main/java/org/zstack/pciDevice/specification/PciSpecificationManagerImpl.java:662
# args: specUuid,systemTag
mdev\ device\ spec[uuid\:%s]\ doesn't\ exist = MDEV设备规格[uuid:{0}]不存在

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceAllocatorFactory.java:81
# args: mdev.getUuid(),mdev.getHostUuid(),attachedMdevUuid,dstHostUuid
specified\ mdev\ devices\ not\ on\ same\ host\:\ mdev\ device[uuid\:\ %s]\ on\ host[uuid\:\ %s]\ while\ mdev\ device[uuid\:\ %s]\ on\ host[uuid\:\ %s] = 云主机试图挂载来自不同物理机的MDEV设备：设备[uuid: {0}]来自物理机[uuid: {1}]，而设备[uuid: {2}]来自物理机[uuid: {3}]

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceAllocatorFactory.java:112
# args: vmUuid,specMap.keySet()
failed\ to\ start\ vm[uuid\:%s]\ because\ not\ all\ mdev\ specs[uuids\:%s]\ exist = 云主机[uuid:{0}]启动失败，由于所设置的MDEV设备规格[uuids:{1}]中有部分不存在

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceAllocatorFactory.java:215
# args: 
no\ candidate\ host\ with\ enough\ mdev\ devices = 没有物理机满足mdev device设备的条件

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:67
# args: 
cannot\ change\ the\ state\ of\ mdev\ device\ that's\ in\ attached\ status = MDEV设备处于已挂载状态，无法修改其状态

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:75
# args: msg.getMdevDeviceUuid()
cannot\ attach\ mdev\ device[uuid\:%s]\ to\ vm,\ make\ sure\ it's\ enabled\ and\ un-attached = 无法为云主机挂载MDEV设备[uuid:{0}]，因为该设备处于禁用状态或已被挂载

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:182
# args: 
cannot\ attach\ mdev\ device\ to\ vm\ instance\ that's\ not\ stopped = 云主机需要处于关机状态下才可以挂载MDEV设备

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:95
# args: msg.getVmInstanceUuid(),msg.getMdevDeviceUuid()
vm[uuid\:%s]\ has\ pci\ devices\ attached\ that\ are\ in\ different\ host\ with\ mdev\ device[uuid\:%s] = 云主机[uuid:{0}]已经挂载了PCI设备，并且它们和MDEV设备[uuid:{1}]不在同一台物理机上

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:105
# args: msg.getVmInstanceUuid(),msg.getMdevDeviceUuid()
vm[uuid\:%s]\ has\ mdev\ devices\ attached\ that\ are\ in\ different\ host\ with\ mdev\ device[uuid\:%s] = 云主机[uuid:{0}]已经挂载了MDEV设备，并且它们和MDEV设备[uuid:{1}]不在同一台物理机上

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:112
# args: mdev.getHostUuid(),mdev.getUuid(),HostState.Enabled,HostStatus.Connected
the\ host[uuid\:%s]\ that\ holds\ mdev\ device[uuid\:%s]\ is\ not\ [%s]\ and\ [%s] = 

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:121
# args: mdev.getHostUuid(),mdev.getUuid(),HostState.Enabled,HostStatus.Connected
IOMMU\ of\ the\ host[uuid\:%s]\ that\ hosts\ pci\ device[uuid\:%s]\ is\ not\ [%s]\ and\ [%s] = 

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:134
# args: msg.getMdevDeviceUuid(),msg.getVmInstanceUuid()
mdev\ device\ [uuid\:%s]\ is\ not\ attached\ to\ vm[uuid\:%s] = MDEV设备[uuid:{0}]没有挂载到云主机[uuid:{1}]

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceApiInterceptor.java:143
# args: 
cannot\ detach\ mdev\ device\ from\ vm\ instance\ when\ it's\ not\ stopped = 云主机需要处于关机状态下才可以卸载MDEV设备

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceBase.java:116
# args: msg.getVmInstanceUuid(),msg.getMdevDeviceUuid()
vm[uuid\:%s]\ cannot\ start\ in\ host\ that\ hold\ mdev\ device[uuid\:%s] = 云主机[uuid:{0}]无法在MDEV设备[uuid:{1}]所在的物理机上启动

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceFactory.java:68
# args: pciDevice.getUuid(),PciDeviceVirtStatus.VFIO_MDEV_VIRTUALIZED
pci\ device[uuid\:%s]\ is\ known\ as\ %s,\ but\ cannot\ find\ it's\ mdev\ spec,\ so\ abort. = PCI设备[uuid:{0}]是{1}，但无法找到可用的MDEV设备规格

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceHostChangeStateExtension.java:63
# args: inventory.getUuid(),hasMdevVmUuids.toString()
The\ host\ [%s]\ has\ failed\ to\ enter\ the\ maintenance,\ because\ vm[%s]\ has\ mdev\ devices\ attached\ and\ cannot\ migrate\ automatically = 物理机[{0}]无法进入维护模式，因为云主机[{1}]挂载了MDEV设备导致无法迁移

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceManagerImpl.java:226
# args: msg.getMdevDeviceUuid()
cannot\ find\ mdev\ device[uuid\:%s],\ it\ may\ have\ been\ deleted = 找不到MDEV设备[uuid:{0}]

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceManagerImpl.java:392
# args: tokens.get(MdevDeviceSystemTags.MDEV_DEVICE_TOKEN),vmUuid
mdev\ device[uuid\:%s]\ are\ invalid(non-exists,\ disabled\ or\ already\ attached)\ for\ vm\ instance[uuid\:%s] = MDEV设备[uuid:{0}]无法挂载到云主机[uuid:{1}]，因为它不存在或已禁用或已挂载

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceManagerImpl.java:492
# args: specUuid,replyHostUuid,vmUuid
failed\ to\ find\ enough\ mdev\ device\ of\ spec[uuid\:%s]\ in\ dest\ host[uuid\:%s]\ for\ vm[uuid\:%s] = 无法在物理机[uuid:{1}]上为云主机[uuid:{2}]找到足够多满足规格[uuid:{0}]的MDEV设备

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceManagerImpl.java:560
# args: msg.getVmInstanceUuid()
can\ not\ migrate\ vm[uuid\:%s]\ since\ mdev\ device\ attached = 无法迁移云主机[uuid:{0}]，因为它挂载了MDEV设备

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceManagerImpl.java:589
# args: msg.getVolumeUuid()
cannot\ migrate\ root\ volume[uuid\:%s]\ because\ there\ are\ mdev\ devices\ attached = 无法迁移跟云盘[uuid:{0}]，因为它所在云主机挂载了MDEV设备

# at: src/main/java/org/zstack/pciDevice/virtual/vfio_mdev/MdevDeviceManagerImpl.java:604
# args: msg.getVmInstanceUuid()
cannot\ migrate\ vm[uuid\:%s]\ because\ there\ are\ mdev\ devices\ attached = 无法迁移云主机[uuid:{0}]，因为它挂载了MDEV设备

# at: src/main/java/org/zstack/pluginpremium/compute/allocator/MaxInstancePerHostAllocatorFlow.java:70
# args: maxInstancePerHost
No\ host\ with\ fewer\ than\ %s\ vms\ found = 

# at: src/main/java/org/zstack/pluginpremium/compute/allocator/MaxInstancePerHostHostAllocatorStrategyFactory.java:58
# args: HostAllocatorConstant.MAX_INSTANCE_PER_HOST_HOST_ALLOCATOR_STRATEGY_TYPE,HostAllocatorSystemTags.MAX_INSTANCE_PER_HOST_TOKEN
Select\ %s\ strategy,\ you\ must\ set\ %s = 选择策略{0}，你必须设置{1}

# at: src/main/java/org/zstack/pluginpremium/compute/allocator/MaxInstancePerHostHostAllocatorStrategyFactory.java:76
# args: HostAllocatorSystemTags.MAX_INSTANCE_PER_HOST_TOKEN
%s\ must\ be\ a\ number = {0}必须是一个数字

# at: src/main/java/org/zstack/pluginpremium/compute/allocator/MinimumMemoryUsageHostAllocatorStrategyFactory.java:58
# args: HostAllocatorSystemTags.MINIMUM_MEMORY_USAGE_HOST_ALLOCATOR_STRATEGY_MODE_TOKEN,modes
Incorrect\ %s\ settings,\ valid\ value\ is\ %s = 不正确的设置{0}，有效的值是{1}

# at: src/main/java/org/zstack/portal/apimediator/ApiMediatorImpl.java:243
# args: cmsg.getResourceUuid()
resourceUuid[%s]\ is\ not\ a\ valid\ uuid.\ A\ valid\ uuid\ is\ a\ UUID(v4\ recommended)\ with\ '-'\ stripped.\ see\ http\://en.wikipedia.org/wiki/Universally_unique_identifier\ for\ format\ of\ UUID,\ the\ regular\ expression\ ZStack\ uses\ to\ validate\ a\ UUID\ is\ '[0-9a-f]{8}[0-9a-f]{4}[1-5][0-9a-f]{3}[89ab][0-9a-f]{3}[0-9a-f]{12}' = 资源UUID（）不是一个有效的uuid。一个有效的UUID是一个没有-的UUID（建议为UUIDv4）.格式参见http://en.wikipedia.org/wiki/Universally_unique_identifier，ZStack中验证一个UUID的正则表达式为: [0-9a-f]{8}[0-9a-f]{4}[1-5][0-9a-f]{3}[89ab][0-9a-f]{3}[0-9a-f]{12}

# at: src/main/java/org/zstack/premium/externalservice/prometheus/MultiNodePrometheus.java:106
# args: v.getClass().getSimpleName(),k
unknown\ value\ type\ %s,\ key\ \=\ %s = 

# at: src/main/java/org/zstack/premium/externalservice/prometheus/MultiNodePrometheus.java:132
# args: 
failed\ to\ HTTP\ call\ all\ prometheus\ instances = 

# at: src/main/java/org/zstack/query/MysqlQueryBuilderImpl3.java:432
# args: attr,inventoryClass.getName()
condition\ name[%s]\ is\ invalid,\ no\ such\ field\ on\ inventory\ class[%s] = 条件名[{0}]非法，在清单类里面没有这个阈

# at: src/main/java/org/zstack/query/MysqlQueryBuilderImpl3.java:437
# args: attr,attr,inventoryClass.getName()
condition\ name[%s]\ is\ invalid,\ field[%s]\ of\ inventory[%s]\ is\ annotated\ as\ @Unqueryable\ field = 条件名[{0}]非法，清单[{2}]的值[{1}]不是被标记为@Unqueryable的值

# at: src/main/java/org/zstack/query/MysqlQueryBuilderImpl3.java:448
# args: info.jpaMetaClass.getName(),attr
entity\ meta\ class[%s]\ has\ no\ field[%s] = 实体元类[{0}]中没有值[{1}]

# at: src/main/java/org/zstack/query/MysqlQueryBuilderImpl3.java:1000
# args: f,info.inventoryClass.getSimpleName(),info.premitiveFieldNames
field[%s]\ is\ not\ a\ primitive\ of\ the\ inventory\ %s;\ you\ cannot\ specify\ it\ in\ the\ parameter\ 'fields';valid\ fields\ are\ %s = 值[{0}]不是清单{1}的原语；你不能在参数'域'中指定该参数；非法的域{2}

# at: src/main/java/org/zstack/query/QueryFacadeImpl.java:496
# args: JSONObjectUtil.toJsonString(cond)
'value'\ of\ query\ condition\ %s\ cannot\ be\ null = 查询条件中{0}的'值'不能为空

# at: src/main/java/org/zstack/resourceconfig/ResourceConfig.java:326
# args: resourceUuid
cannot\ find\ resource[uuid\:\ %s] = 

# at: src/main/java/org/zstack/resourceconfig/ResourceConfig.java:330
# args: globalConfig.getCategory(),globalConfig.getName(),resourceType
ResourceConfig\ [category\:%s,\ name\:%s]\ cannot\ bind\ to\ resourceType\:\ %s = 

# at: src/main/java/org/zstack/resourceconfig/ResourceConfigApiInterceptor.java:60
# args: msg.getResourceUuid()
account\ has\ no\ access\ to\ the\ resource[uuid\:\ %s] = 账号没有访问资源[uuid:{0}]的权限

# at: src/main/java/org/zstack/resourceconfig/ResourceConfigApiInterceptor.java:43
# args: msg.getCategory(),msg.getName()
no\ global\ config[category\:%s,\ name\:%s]\ found = 

# at: src/main/java/org/zstack/resourceconfig/ResourceConfigApiInterceptor.java:49
# args: msg.getCategory(),msg.getName()
global\ config[category\:%s,\ name\:%s]\ cannot\ bind\ resource = 

# at: src/main/java/org/zstack/rest/TypeVerifier.java:22
# args: f.getName(),source
[%s]\ field\ is\ excepted\ an\ int\ or\ long,\ but\ was\ [%s]. = [{0}] 属性期望是一个整数，但是得到的是 [{1}]

# at: src/main/java/org/zstack/rest/TypeVerifier.java:31
# args: f.getName(),source
Invalid\ value\ for\ boolean\ field\ [%s],\ [%s]\ is\ not\ a\ valid\ boolean\ string[true,\ false]. = boolean属性字段[{0}]无效，[{1}]不是一个有效的boolean字符串[true, false]

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:49
# args: msg.getAreaId()
[%s]\ is\ not\ formatted\ as\ IPv4\ address = 

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:88
# args: msg.getAreaAuth()
KeyID\ &\ password\ must\ be\ not\ null\ when\ authentication\ type\ is\ %s = 

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:94
# args: msg.getAreaAuth()
password\ must\ be\ not\ null\ when\ authentication\ type\ is\ %s = 

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:98
# args: msg.getAreaAuth()
the\ length\ of\ password\ is\ at\ most\ than\ 8Bytes\ when\ authentication\ type\ is\ %s = 

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:107
# args: vo.getAreaId(),RouterAreaType.Standard.toString()
AreaId[%s]\ type\ must\ be\ %s = 

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:77
# args: msg.getAreaId()
AreaId[%s]\ has\ been\ created = 

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:121
# args: msg.getvRouterUuid()
All\ the\ networks\ should\ be\ in\ the\ virtual\ router[%s] = 

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:128
# args: vo.getL3NetworkUuid(),vo.getRouterAreaUuid()
The\ network[%s]\ have\ been\ added\ into\ the\ virtual\ routerArea[%s] = 

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:150
# args: msg.getRouterId()
Router\ ID[%s]\ is\ not\ formatted\ as\ IPv4\ address = 

# at: src/main/java/org/zstack/routeProtocol/RouteProtocolApiInterceptor.java:160
# args: msg.getRouterId()
Router\ ID[%s]\ is\ not\ unique\ in\ this\ system = 

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:183
# args: 
cron\ must\ be\ set\ when\ use\ cron\ scheduler = 当使用定时器任务时，必须设置cron

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:189
# args: 
cron\ task\ must\ follow\ format\ like\ this\ \:\ \"0\ 0/3\ 17-23\ *\ *\ ?\"\  = 定时器任务必须符合以下格式: \"0 0/3 17-23 * * ?\" 

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:192
# args: 
cron\ scheduler\ only\ need\ to\ specify\ cron\ task = 定时调度器（Cron Scheduler）仅需要指定定时任务（Cron Task）

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:201
# args: 
startTime\ out\ of\ range = 开始时间超出范围

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:197
# args: 
startTime\ must\ be\ positive\ integer\ or\ 0 = 开始时间必须是正整数或者0

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:178
# args: 
stopTime\ has\ been\ passed = 截止时间已经过去了

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:176
# args: 
stopTime\ out\ of\ mysql\ timestamp\ range = 定时任务停止时间超出mysql的timestamp的范围

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:174
# args: 
duration\ time\ out\ of\ range = 任务需要的时间超出范围

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:93
# args: 
interval\ must\ be\ set\ when\ use\ simple\ scheduler\ when\ repeat\ more\ than\ once = 当简单定时任务执行超过一次时，必须设置间隔时间

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:128
# args: msg.getSchedulerJobUuid(),msg.getSchedulerTriggerUuid()
Can\ not\ add\ job[uuid\:%s]\ twice\ to\ the\ same\ trigger[uuid\:%s] = 不能两次添加任务[uuid:{0}]到相同的触发器[uuid:{1}]

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:133
# args: msg.getSchedulerJobUuid(),msg.getSchedulerTriggerUuid()
Can\ not\ add\ job[uuid\:%s]\ to\ a\ out\ of\ time\ trigger[uuid\:%s] = 不能添加任务[uuid:{0}]到一个已经过时的触发器[uuid:{1}]

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:141
# args: count,msg.getSchedulerJobUuid()
There\ are\ [%d]\ triggers\ added\ to\ job[uuid\:%s],\ cannot\ add\ any\ more. = 

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:156
# args: count,msg.getSchedulerJobGroupUuid()
There\ are\ [%d]\ triggers\ added\ to\ job\ group[uuid\:%s],\ cannot\ add\ any\ more. = 

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:186
# args: 
invalid\ cron\ expression = 无效的cron表达式

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:166
# args: 
startTime\ must\ be\ set\ for\ simple\ scheduler = simple类型的定时任务必须设置开始时间[startTime]

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:170
# args: 
schedulerInterval\ must\ be\ set\ for\ simple\ scheduler = simple类型的定时任务必须设置执行间隔[schedulerInterval]

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:234
# args: msg.getParameters().get(SchedulerJobParameters.snapshotMax),e.getMessage()
snapshotMaxNumber\ \:\ %s\ format\ error\ because\ %s = snapshotMaxNumber : {0} 转换类型失败，因为{1}

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:260
# args: n
%d\ jobs\ have\ different\ job\ type\ with\ job\ group = 

# at: src/main/java/org/zstack/scheduler/SchedulerApiInterceptor.java:269
# args: count,limit - count
job\ group\ has\ contained\ %d\ job,\ only\ %d\ seats\ left = 

# at: src/main/java/org/zstack/scheduler/SchedulerFacadeImpl.java:511
# args: jobUuid,e.getMessage()
trigger\ job[uuid\:\ %s]\ failed,\ because\ %s = 

# at: src/main/java/org/zstack/scheduler/SchedulerFacadeImpl.java:641
# args: jobUuid,jobGroupUuid
Scheduler\ job[uuid\:%s]\ already\ in\ group[uuid\:\ %s] = 

# at: src/main/java/org/zstack/scheduler/SchedulerJobParamCascadeUpdater.java:86
# args: field.getName()
field[%s]\ cannot\ be\ empty = 

# at: src/main/java/org/zstack/scheduler/vm/StopVmInstanceJob.java:78
# args: getTargetResourceUuid()
vm[uuid\:%s]\ is\ destroyed,\ state\ change\ is\ not\ allowed = 

# at: src/main/java/org/zstack/simulator/SimulatorHost.java:92
# args: 
set\ to\ disconnected = 

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:50
# args: 
password\ is\ not\ set\ while\ username\ is\ set = 设置了用户名但未设置密码

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:54
# args: 
username\ is\ not\ set\ while\ password\ is\ set = 设置了密码但未设置用户名

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:63
# args: msg.getPhoneNumber()
phone\ number[%s]\ already\ exists = 手机号码[{0}]已存在

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:72
# args: url
invalid\ url[%s] = 无效的url[{0}]

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:78
# args: host
[%s]\ is\ not\ a\ legal\ ip = 

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:84
# args: n
invalid\ phone\ number[%s],\ the\ DingDing\ phone\ number\ is\ like\ +86-12388889999 = 无效的手机号码[{0}], 钉钉手机号码格式应当为 +86-12388889999

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:101
# args: 
username\ and\ password\ must\ either\ absent\ at\ all\ or\ present\ with\ each\ other = 用户名和密码要么同时为空要么同时不为空

# at: src/main/java/org/zstack/sns/SNSApiInterceptor.java:108
# args: msg.getEmail()
invalid\ email\ address[%s] = 无效的email地址['{}']

# at: src/main/java/org/zstack/sns/SNSApplicationPlatformBase.java:107
# args: 
the\ operation\ is\ not\ permitted\ for\ the\ system\ application\ platform = 禁止对该应用平台进行当前操作

# at: src/main/java/org/zstack/sns/SNSManagerImpl.java:75
# args: msg.getTopicUuid()
cannot\ find\ the\ SNSTopic[uuid\:%s],\ it\ may\ have\ been\ deleted = 找不到SNS主题[uuid:{0}], 它可能已经被删除

# at: src/main/java/org/zstack/sns/SNSManagerImpl.java:93
# args: msg.getApplicationPlatformUuid()
cannot\ find\ SNSApplicationPlatform[uuid\:%s],\ it\ may\ have\ been\ deleted = 找不到SNS应用平台[uuid:{0}], 它可能已经被删除

# at: src/main/java/org/zstack/sns/SNSManagerImpl.java:103
# args: msg.getApplicationEndpointUuid()
cannot\ find\ SNSApplicationEndpoint[uuid\:%s],\ it\ may\ have\ been\ deleted = 找不到SNS应用接收终端[uuid:{0}], 它可能已经被删除

# at: src/main/java/org/zstack/sns/SNSTopicBase.java:125
# args: 
the\ topic\ is\ not\ subscribed\ by\ any\ endpoints = 当前主题并未被任何应用终端订阅

# at: src/main/java/org/zstack/sns/SNSTopicBase.java:149
# args: 
application\ platform\ is\ disabled = 应用平台被不可用

# at: src/main/java/org/zstack/sns/SNSTopicBase.java:201
# args: 
application\ endpoint\ is\ disabled = 应用接收端被禁用

# at: src/main/java/org/zstack/sns/platform/dingtalk/SNSDingTalkEndpoint.java:118
# args: rsp.getStatusCode(),rsp.getBody()
Sending\ message\ to\ DingTalk\ failure.\ status\:\ %s,\ body\:\ %s = 发送消息到DingTalk失败. status: {0}, body: {1}

# at: src/main/java/org/zstack/sns/platform/email/SNSEmailApplicationPlatform.java:74
# args: getSelf().getSmtpServer(),getSelf().getSmtpPort()
cannot\ connect\ SMTP\ server[server\:\ %s,\ port\:\ %s]\ in\ 15\ seconds = 在15秒内无法连接到SMTP服务器[server: {0}, port: {1}]

# at: src/main/java/org/zstack/sns/platform/email/SNSEmailApplicationPlatform.java:94
# args: e.getMessage()
SMTP\ server\ validation\ error\:\ %s = SMTP服务器验证错误: {0}

# at: src/main/java/org/zstack/sns/platform/email/SNSEmailApplicationPlatform.java:136
# args: 
the\ endpoint\ is\ disabled = 通知终端不可用

# at: src/main/java/org/zstack/sns/platform/email/SNSEmailApplicationPlatform.java:154
# args: 
no\ subject = 没有主题

# at: src/main/java/org/zstack/sns/platform/email/SNSEmailPlatformFactory.java:57
# args: 
The\ problem\ may\ be\ caused\ by\ an\ incorrect\ user\ name\ or\ password\ or\ email\ permission\ denied = 导致操作失败的原因可能是不正确的用户名、密码或邮件访问权限不足

# at: src/main/java/org/zstack/sns/platform/email/SNSEmailPlatformFactory.java:59
# args: smtpServer,smtpPort
Couldn't\ connect\ to\ host,\ port\:\ %s,\ %d.\ The\ problem\ may\ be\ caused\ by\ an\ incorrect\ smtpServer\ or\ smtpPort = 连接{0}:{1}超时，导致原因可能是不正确的邮件服务器和邮件服务器端口

# at: src/main/java/org/zstack/sns/platform/http/SNSHttpEndpoint.java:67
# args: rsp.getStatusCode(),rsp.getBody()
HTTP\ POST\ failure.\ status\:\ %s,\ body\:\ %s = HTTP POST失败，状态码: {0}, body: {1}

# at: src/main/java/org/zstack/sns/system/SNSApiTopicManagerImpl.java:172
# args: endpoint.getType()
only\ HTTP\ endpoint\ can\ subscribe\ API\ topic,\ the\ endpoint[type\:%s]\ is\ not\ a\ HTTP\ endpoint = 仅HTTP通知终端可以订阅API通知主题，当前通知终端[type:{0}]不是一个HTTP通知终端

# at: src/main/java/org/zstack/sns/system/SNSApiTopicManagerImpl.java:191
# args: 
API\ topic\ cannot\ be\ deleted = API通知主题无法被删除

# at: src/main/java/org/zstack/sns/system/SNSSystemAlarmTopicManagerImpl.java:67
# args: 
system\ alarm\ topic\ cannot\ be\ deleted = 系统警报通知主题不能被删除

# at: src/main/java/org/zstack/storage/backup/BackupStorageApiInterceptor.java:65
# args: name
%s\ should\ not\ be\ null = {0} 不能为空

# at: src/main/java/org/zstack/storage/backup/BackupStorageApiInterceptor.java:88
# args: 
zoneUuids,\ backupStorageUuids\ must\ have\ at\ least\ one\ be\ none-empty\ list,\ or\ all\ is\ set\ to\ true = zoneUuids, backupStorageUuids 至少有一个不为空，或者all被设置为真 

# at: src/main/java/org/zstack/storage/backup/BackupStorageApiInterceptor.java:118
# args: msg.getBackupStorageUuid(),msg.getZoneUuid()
backup\ storage[uuid\:%s]\ has\ not\ been\ attached\ to\ zone[uuid\:%s] = 镜像服务器[uuid:{0}]没有被加载到zone[uuid:{1}]

# at: src/main/java/org/zstack/storage/backup/BackupStorageApiInterceptor.java:127
# args: msg.getBackupStorageUuid(),msg.getZoneUuid()
backup\ storage[uuid\:%s]\ has\ been\ attached\ to\ zone[uuid\:%s] = 镜像服务器[uuid:{0}]已经被加载到zone[uuid:{1}]

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:149
# args: url,e.toString()
cannot\ get\ image.\ The\ image\ url\ is\ %s.\ Exception\ is\ %s = 无法取得镜像。镜像的url是{0}，抛出的错误为{1}

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:157
# args: self.getUuid(),self.getName(),url,size,self.getAvailableCapacity()
the\ backup\ storage[uuid\:%s,\ name\:%s]\ has\ not\ enough\ capacity\ to\ download\ the\ image[%s].Required\ size\:%s,\ available\ size\:%s = 镜像服务器[uuid:{0}, name:{1}]没有足够的容量可供下载镜像[{2}]。需要的大小: {3}，可用的大小: {4}

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:172
# args: msg.getClass().getName(),self.getStatus()
backup\ storage\ cannot\ proceed\ message[%s]\ because\ its\ status\ is\ %s = 镜像服务器无法处理消息[{0}]因为它的状态为{1}

# at: src/main/java/org/zstack/storage/backup/BackupStorageBase.java:178
# args: msg.getClass().getName(),self.getState()
backup\ storage\ cannot\ proceed\ message[%s]\ because\ its\ state\ is\ %s = 镜像服务器无法处理消息[{0}]因为它的状态为{1}

# at: src/main/java/org/zstack/storage/backup/BackupStorageCapacityUpdater.java:139
# args: size,backupStorageUuid,capacityVO.getAvailableCapacity()
cannot\ reserve\ %s\ on\ the\ backup\ storage[uuid\:%s],\ it\ only\ has\ %s\ available = 无法在镜像服务器{1}保留{0}，它仅有{2}可用容量

# at: src/main/java/org/zstack/storage/backup/BackupStorageManagerImpl.java:313
# args: cidr,fmtCidr
[%s]\ is\ not\ a\ standard\ cidr,\ do\ you\ mean\ [%s]? = [{0}]不是一个标准的cidr, 是否指定的是[{1}]

# at: src/main/java/org/zstack/storage/backup/BackupStorageManagerImpl.java:281
# args: 
capacity\ reservation\ on\ all\ backup\ storage\ failed = 在所有镜像服务器上保留容量失败

# at: src/main/java/org/zstack/storage/backup/BackupStorageReservedCapacityAllocatorFlow.java:46
# args: BackupStorageGlobalConfig.RESERVED_CAPACITY.value(),spec.getSize()
after\ subtracting\ reserved\ capacity[%s],\ no\ backup\ storage\ has\ required\ capacity[%s\ bytes] = 在减去保留容量[{0}]，没有镜像服务器有容量[{1}] bytes

# at: src/main/java/org/zstack/storage/backup/CreateVolumeBackupJob.java:460
# args: getTargetResourceUuid()
volume[uuid\:%s]\ is\ deleted,\ state\ change\ is\ not\ allowed = 

# at: src/main/java/org/zstack/storage/backup/CreateVolumeBackupJob.java:146
# args: 
missing\ 'retentionType'\ in\ job\ parameters = parameters中缺少retentionType参数

# at: src/main/java/org/zstack/storage/backup/CreateVolumeBackupJob.java:150
# args: 
missing\ 'retentionValue'\ in\ job\ parameters = parameter中缺少retentionValue参数

# at: src/main/java/org/zstack/storage/backup/CreateVolumeBackupJob.java:154
# args: 
missing\ 'backupStorageUuids'\ in\ job\ parameters = parameter中缺少backupStorageUuids参数

# at: src/main/java/org/zstack/storage/backup/CreateVolumeBackupJob.java:158
# args: 
job\ parameter\ 'backupStorageUuids'\ is\ empty = parameter中backupStorageUuids为空

# at: src/main/java/org/zstack/storage/backup/CreateVolumeBackupJob.java:163
# args: bsUuid
unexpected\ backup\ storage\ uuid\:\ %s = 错误的镜像服务器uuid: {0}

# at: src/main/java/org/zstack/storage/backup/CreateVolumeBackupJob.java:114
# args: 
bandWidth\ must\ be\ a\ positive\ number = 

# at: src/main/java/org/zstack/storage/backup/CreateVolumeBackupJob.java:170
# args: 
missing\ job\ parameters = 缺少parameters参数

# at: src/main/java/org/zstack/storage/backup/CreateVolumeBackupJob.java:409
# args: 
No\ available\ backup\ storage\ found,\ skip\ this\ job = 

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupApiInterceptor.java:92
# args: msg.getDatabaseBackupUuid(),msg.getBackupStorageUuid()
database\ backup[uuid%s]\ has\ not\ been\ exported\ from\ backupStorage[uuid\:%s] = 

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupApiInterceptor.java:106
# args: msg.getDatabaseBackupUuid(),msg.getBackupStorageUuid()
database\ backup[uuid%s]\ has\ been\ exported\ from\ backupStorage[uuid\:%s] = 

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupApiInterceptor.java:119
# args: 
do\ not\ allow\ cover\ database\ from\ backup = 

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupApiInterceptor.java:123
# args: 
installPath\ and\ bsUrl\ are\ both\ need = 

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupApiInterceptor.java:132
# args: 
databaseBackup[uuid\:%s]\ is\ not\ Enabled\ and\ Ready = 

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupApiInterceptor.java:141
# args: url
illegal\ url[%s],\ correct\ example\ is\ ssh\://username\:password@hostname[\:sshPort]/path = 

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupBase.java:72
# args: self.getUuid()
database\ backup[uuid\:%s]\ is\ not\ Enabled\ and\ Ready = 

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupBase.java:317
# args: msg.getDatabaseBackupUuid(),msg.getSrcBackupStorageUuid()
database\ backup[uuid\:%s]\ not\ found\ in\ backup\ storage[uuid\:%s] = 

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupManagerImpl.java:86
# args: msg.getDatabaseBackupUuid()
database\ backup\ [uuid\:%s]\ is\ not\ existed\ yet = 

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupManagerImpl.java:102
# args: 
backup\ storage[uuid\:%s]\ is\ not\ enabled\ and\ connected = 

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupManagerImpl.java:558
# args: 
cannot\ get\ free\ port\ to\ listen = 

# at: src/main/java/org/zstack/storage/backup/DatabaseBackupManagerImpl.java:586
# args: version,dbf.getDbVersion()
database\ backup\ version[%s]\ is\ not\ match\ currently\ version[%s] = 

# at: src/main/java/org/zstack/storage/backup/MultiDatabaseRecoverChecker.java:25
# args: 
cannot\ ssh\ peer\ node\ via\ sshkey,\ please\ check\ connection = 

# at: src/main/java/org/zstack/storage/backup/MultiDatabaseRecoverChecker.java:40
# args: result.getStderr()
cannot\ get\ zsha2\ status,\ because\ %s = 

# at: src/main/java/org/zstack/storage/backup/MultiDatabaseRecoverChecker.java:45
# args: result.getStderr()
cannot\ get\ zsha2\ config,\ because\ %s,\ maybe\ you\ need\ upgrade\ zsha2 = 

# at: src/main/java/org/zstack/storage/backup/SingleDatabaseRecoverChecker.java:19
# args: 
please\ stop\ other\ node\ first! = 

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:77
# args: currentState,msgName,checker.getStatesForOperation(msgName)
current\ backup\ storage\ state[%s]\ doesn't\ allow\ to\ proceed\ message[%s],\ allowed\ states\ are\ %s = 当前镜像服务器状态[{0}]不能处理消息[{1}]，仅当镜像服务器处于{2}时才能处理该消息

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:206
# args: bsType,bsUuid
Unexpected\ backup\ storage[type\:%s,uuid\:%s] = 错误的镜像服务器[type:{0}, uuid:{1}]

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:227
# args: msg.getVolumeUuid()
Can\ not\ create\ volume\ backup\ for\ shareable\ volume[uuid\:%s] = 无法给共享云盘[uuid:{0}]创建云盘备份

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:231
# args: msg.getVolumeUuid()
Failed\ to\ create\ volume\ backup\ for\ volume[uuid\:%s],\ because\ it\ is\ not\ attached\ to\ any\ vm = 无法给云盘[uuid:{0}]创建云盘备份，因为它未加载到虚拟机上

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:240
# args: msg.getVolumeUuid(),VmInstanceState.Running.toString(),VmInstanceState.Paused.toString()
Failed\ to\ create\ volume\ backup\ for\ volume[uuid\:%s],\ because\ its\ attached\ volume\ is\ not\ in\ state[%s,\ %s] = 无法给云盘[uuid:{0}]创建云盘备份，因为加载到的虚拟机并不处于以下状态[{1}, {2}]

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:237
# args: msg.getVolumeUuid(),VmInstanceState.Running.toString(),VmInstanceState.Paused.toString()
Failed\ to\ create\ volume\ backup\ for\ volume[uuid\:%s],\ because\ the\ vm\ is\ not\ in\ state[%s,\ %s] = 无法给云盘[uuid:{0}]创建云盘备份，因为加载到的虚拟机并不处于以下状态[{1}, {2}]

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:249
# args: msg.getVolumeUuid()
Volume[uuid\:%s]\ is\ not\ root\ volume = 

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:256
# args: t.get(0),VmInstanceState.Running.toString(),VmInstanceState.Paused.toString()
Failed\ to\ create\ backups\ for\ VM[uuid\:%s],\ because\ it\ is\ not\ in\ state[%s,\ %s] = 

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:270
# args: groupUuid
No\ volume\ backup\ found\ for\ group\ uuid\:\ %s = 

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:276
# args: groupUuid
root\ volume\ backup\ of\ group[uuid\:%s]\ not\ found = 

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:300
# args: backupUuid,state
volume\ backup[uuid\:%s]\ is\ in\ state\ %s,\ cannot\ revert\ volume\ to\ it = 云盘备份[uuid:{0}]处于{1}状态，无法用于恢复云盘

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:311
# args: backupUuid
original\ volume\ for\ backup[uuid\:%s]\ has\ been\ deleted,\ cannot\ revert\ volume\ to\ it = 云盘备份[uuid:{0}]已经被删除，无法用于恢复云盘

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:315
# args: volUuid,backupUuid,expectVmUuid
original\ volume[uuid\:%s]\ for\ backup[uuid\:%s]\ is\ no\ longer\ attached\ to\ vm[uuid\:%s] = 

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:324
# args: backupUuid
VM\ not\ found\ with\ volume\ backup[uuid\:%s] = 找不到和云盘备份[uuid:{0}]对应的虚拟机

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:328
# args: vmState
VM\ is\ not\ in\ stopped\ state\:\ %s = 当前虚拟机状态并不是停止状态：{0}

# at: src/main/java/org/zstack/storage/backup/VolumeBackupApiInterceptor.java:342
# args: 
No\ available\ backup\ storage\ found = 没有可用的镜像服务器

# at: src/main/java/org/zstack/storage/backup/VolumeBackupKvmBackend.java:182
# args: 
Operation\ not\ supported\ on\ shared\ volume = 共享云盘不支持该操作

# at: src/main/java/org/zstack/storage/backup/VolumeBackupKvmBackend.java:187
# args: volumeVO.getUuid()
No\ VM\ found\ for\ volume[uuid\:%s] = 找不到和云盘[uuid:{0}]对应的虚拟机

# at: src/main/java/org/zstack/storage/backup/VolumeBackupKvmBackend.java:446
# args: msg.getRootVolumeUuid()
No\ VM\ found\ with\ root\ volume\ uuid\:\ %s = 

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:1422
# args: msg.getDstBackupStorageUuid(),msg.getSrcBackupStorageUuid(),BackupStorageState.Disabled.toString()
One\ of\ the\ backup\ storage[uuids\:\ %s,\ %s]\ is\ in\ the\ state\ of\ %s,\ can\ not\ do\ sync\ operation = 镜像服务器[uuid: {0}]处于状态{1}, 无法执行同步操作

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:1098
# args: 
sync\ task\ failed. = 同步失败

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:1105
# args: reply.getStatus()
unexpected\ task\ status\:\ %s = 错误的任务状态{0}

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:307
# args: vos.stream().filter( vo -> !succeedUuids.contains(vo.getUuid())).map(VolumeBackupVO::getUuid).collect(Collectors.toList())
failed\ to\ create\ image\ from\ backup\ %s = 

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:657
# args: msg.getImageStoreUuid(),e.getMessage()
sync\ volume\ backup\ metadata\ file\ in\ image\ store[uuid\:%s]\ meet\ I/O\ error\:\ %s = 

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:692
# args: hypervisorType
No\ VolumeBackupFactory\ of\ type[%s]\ found = 

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:709
# args: msg.getBackupStorageUuid(),BackupStorageState.Disabled.toString()
One\ of\ the\ backup\ storage[uuid\:\ %s]\ is\ in\ the\ state\ of\ %s,\ can\ not\ do\ sync\ operation = 镜像服务器[uuid: {0}]处于状态{1}, 无法执行同步操作

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:849
# args: struct.getBackupUuid(),struct.getBackupStorageUuid()
Volume\ backup[uuid\:%s]\ not\ found\ on\ backup\ storage[uuid\:%s] = 在镜像服务器[uuid:{1}]上找不到云盘备份[uuid:{0}]

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:1293
# args: backupUuid,srcBackupStorageUuid
volume\ backup[uuid\:%s]\ not\ found\ in\ backup\ storage[uuid\:%s] = 在镜像服务器[uuid:{1}]上找不到云盘备份[uuid:{0}]

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:1501
# args: groupUuid
No\ volume\ backups\ found\ with\ group\ uuid\:\ %s = 

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:1508
# args: groupUuid
Root\ volume\ missing\ within\ group\ uuid\:\ %s = 

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:1514
# args: groupUuid
Multiple\ root\ volumes\ found\ within\ group\ uuid\:\ %s = 

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:1526
# args: groupUuid
No\ permission\ to\ volume\ backups\ within\ group\ uuid\:\ %s = 

# at: src/main/java/org/zstack/storage/backup/VolumeBackupManagerImpl.java:1664
# args: vo.getUuid()
Volume\ backup[uuid\:%s]\ not\ found\ on\ any\ backup\ storage = 

# at: src/main/java/org/zstack/storage/backup/VolumeBackupMetadataMaker.java:180
# args: inv.getUuid(),e.getMessage()
generate\ volume\ backup\ metadata\ file\ on\ image\ store[uuid\:%s]\ failure,\ because\ IO\ error\:\ %s = 

# at: src/main/java/org/zstack/storage/backup/VolumeBackupMetadataMaker.java:502
# args: rsp.getError()
volume\ backup\ metadata\ operation\ failure,\ because\ %s = 

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:261
# args: url,rsp.getError()
unable\ to\ connect\ to\ SimpleHttpBackupStorage[url\:%s],\ because\ %s = 无法连接到SimpleHttpBackupStorage[url:{0}]，因为{1}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:391
# args: iinv.getName()
Missing\ cert\ file\ for\ downloading\ image\:\ %s = 下载镜像时证书文件丢失

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:507
# args: 
image\ store\ service\ is\ temporary\ not\ available,\ because\ it\ is\ reclaiming\ space\ now = 

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:679
# args: 
No\ response = 无响应

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:752
# args: ret.getError()
reclaim\ imagestore\ error,\ because\:%s = 收回imagestore错误，因为{0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:901
# args: msg.getImageUuid(),self.getUuid()
image[%s]\ not\ found\ on\ backup\ storage[%s] = 

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:1046
# args: 
image\ store\ [%s]\ cannot\ add\ image,\ because\ it\ is\ used\ for\ backup\ remote = ImageStore[{0}]不能添加镜像，因为它已经被远程镜像使用

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:1220
# args: 
commercial\ license\ is\ required\ to\ use\ ImageStore = 使用ImageStore需要商业许可证

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorage.java:1253
# args: self.getUuid(),ret.getUuid()
the\ uuid\ of\ imagestoreBackupStorage\ agent\ changed[expected\:%s,\ actual\:%s],\ it's\ most\ likely\ the\ agent\ was\ manually\ restarted.\ Issue\ a\ reconnect\ to\ sync\ the\ status = 镜像镜像服务器的代理的uuid发生了改变[期望: {0}，实际: {1}]，很有可能代理被手动重启了，需要重连同步状态

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:115
# args: msg.getHostname()
hostname[%s]\ is\ neither\ an\ IPv4\ address\ nor\ a\ valid\ hostname = 主机名[{0}]不是一个IPv4的地址，而是一个非法的主机名

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:50
# args: bsUuid,imageUuid
target\ backup\ storage[uuid\:%s]\ already\ contains\ the\ image\ [uuid\:%s] = 

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:69
# args: msg.getSrcBackupStorageUuid(),msg.getUuid()
source\ backup\ storage[%s]\ doesn't\ contain\ image[%s] = 源镜像服务器[{0}]不包含该镜像[{1}]

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:84
# args: msg.getSrcBackupStorageUuid(),msg.getUuid()
src\ backupstorage[%s]\ doesn't\ contain\ image[%s] = 

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:121
# args: msg.getHostname()
duplicate\ backup\ storage.\ There\ has\ been\ an\ image\ store\ backup\ storage[hostname\:%s] = 重复的镜像服务器。已经存在一个镜像服务器[主机名: {0}]

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:126
# args: 
file\ path\ needed = 需要文件路径

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:130
# args: dir
absolute\ file\ path\ required\:\ %s = 需要文件的绝对路径；{0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:133
# args: 
the\ url\ contains\ an\ invalid\ folder[/dev\ or\ /proc\ or\ /sys] = URL包含了一个无效的目录[/dev or /proc or /sys]

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageApiInterceptor.java:141
# args: dir
file\ path\ contains\ invalid\ character\:\ %s = 文件路径包含非法字符: {0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageExtension.java:188
# args: ps.getUuid()
cannot\ find\ a\ connected\ host\ in\ cluster\ to\ which\ PS\ [uuid\:\ %s]\ attached = 

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageFactory.java:142
# args: amsg.getUrl()
invalid\ url[%s],\ the\ url\ must\ be\ an\ absolute\ path\ starting\ with\ '/' = 无效的url[{0}]，url必须是以'/'开头的绝对路径

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageFactory.java:151
# args: hostname
existing\ SimpleHttpBackupStorage\ with\ hostname[%s]\ found = 存在主机名为[{0}]的简单http镜像服务器

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageFactory.java:93
# args: tmpHostFile,result.getStderr()
create\ tmp\ file\ [%s]\ failed,\ due\ to\:\ %s = 创建tmp文件[{0}]失败，因为{1}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageFactory.java:100
# args: result.getStderr()
ansible\ mkdir\ failed,\ due\ to\:\ %s = Ansible创建目录失败，因为{0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageFactory.java:112
# args: result.getStderr()
ansible\ failed,\ due\ to\:\ %s = Ansible失败，因为{0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageFactory.java:110
# args: result.getStdout()
ansible\ attach\ nas\ failed,\ due\ to\:\ %s = Ansible绑定失败，因为{0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageManagerImpl.java:212
# args: 
sync\ status\ failed. = 同步失败

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageMetaDataMaker.java:765
# args: rsp.getError()
delete\ image\ metadata\ file\ failed\:\ %s = 删除镜像元数据文件失败: {0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageMetaDataMaker.java:362
# args: bsUuid
AddImage\ is\ forbidden\ in\ Disaster\ BS\:\ [%s] = 在Disaster镜像服务器中添加镜像是被禁止的

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageMetaDataMaker.java:694
# args: rsp.getBackupStorageMetaFileName()
Check\ image\ metadata\ file\:\ %s\ failed = 检查镜像元数据文件: {0}失败

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageMetaDataMaker.java:536
# args: rsp.getBackupStorageMetaFileName()
Create\ image\ metadata\ file\ \:\ %s\ failed = 创建镜像元数据文件: {0}失败

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreBackupStorageMetaDataMaker.java:511
# args: rsp.getBackupStorageMetaFileName()
Create\ image\ metadata\ file\ sync\ \:\ %s\ failed = 同步创建镜像元数据文件{0}失败了

# at: src/main/java/org/zstack/storage/backup/imagestore/ImageStoreImageStruct.java:79
# args: e.getMessage()
parse\ create\ time\ error\:\ %s = 解析创建时间出错: {0}

# at: src/main/java/org/zstack/storage/backup/imagestore/ReclaimSpaceFromImageStoreLongJob.java:62
# args: 
Cancel\ operation\ is\ not\ supported = 

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorage.java:104
# args: scheme,url
SftpBackupStorage\ doesn't\ support\ scheme[%s]\ in\ url[%s] = Sftp镜像服务器不支持在url[{1}]里包含scheme[{0}]

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorage.java:132
# args: ret.getError()
fail\ to\ download\ image,\ because\ %s = 下载镜像失败，因为{0}

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorage.java:277
# args: self.getUuid(),ret.getUuid()
the\ uuid\ of\ sftpBackupStorage\ agent\ changed[expected\:%s,\ actual\:%s],\ it's\ most\ likely\ the\ agent\ was\ manually\ restarted.\ Issue\ a\ reconnect\ to\ sync\ the\ status = Sftp镜像镜像服务器的代理的uuid发生了改变[期望: {0}，实际: {1}]，很有可能代理被手动重启了，需要重连同步状态

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorageApiInterceptor.java:70
# args: bsUuid
Please\ stop\ the\ vm\ before\ create\ volume\ template\ to\ sftp\ backup\ storage\ %s = 

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorageApiInterceptor.java:106
# args: msg.getHostname()
duplicate\ backup\ storage.\ There\ has\ been\ a\ sftp\ backup\ storage[hostname\:%s]\ existing = 重复的镜像服务器。已经存在一个镜像服务器[主机名: {0}]

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorageMetaDataMaker.java:540
# args: rsp.getBackupStorageMetaFileName()
check\ image\ metadata\ file\:\ %s\ failed = 检查镜像元数据文件: {0}失败

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorageMetaDataMaker.java:392
# args: rsp.getBackupStorageMetaFileName()
create\ image\ metadata\ file\ \:\ %s\ failed = 创建镜像元数据文件: {0}失败

# at: src/main/java/org/zstack/storage/backup/sftp/SftpBackupStorageMetaDataMaker.java:545
# args: rsp.getBackupStorageMetaFileName()
image\ metadata\ file\:\ %s\ is\ not\ exist = 镜像元数据文件: {0}不存在

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:77
# args: msg.getPoolName()
operation\ failure,\ because\ the\ poolName[poolName\:%s]\ can\ not\ include\ unprintable\ ascii\ characters. = 操作失败，因为pool名称[poolName:{0}]不能包含中文和特殊字符

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:91
# args: duplicatePoolUuid
Ceph\ pool[uuid\:%s]\ with\ this\ name\ is\ already\ added\ into\ ZStack\ and\ used\ elsewhere,\ cannot\ reuse\ the\ ceph\ pool. = 池名称为此的扩展池[uuid:{0}]已经被添加进 ZStack 了，已做它用，不能复用该扩展池

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:86
# args: msg.getPoolName(),duplicatePoolUuid
creation\ failure,\ duplicate\ poolName[%s].\ There\ has\ been\ a\ pool[uuid\:%s]\ with\ the\ same\ name\ existing. = 创建失败，重复的池名称[{0}]。已经有一个相同名称的扩展池[uuid:{1}]存在

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:119
# args: existing
cannot\ add\ ceph\ primary\ storage,\ there\ has\ been\ some\ ceph\ primary\ storage\ using\ mon[hostnames\:%s] = 无法添加ceph主存储，一定有某些ceph主存储使用了mon[主机名: {0}]

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:130
# args: uri.getHostname()
Cannot\ add\ same\ host[%s]\ in\ mons = 在mon中无法添加相同的物理机[{0}]

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:156
# args: 
Adding\ the\ same\ Mon\ node\ is\ not\ allowed = 添加相同的Mon节点不被允许

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:235
# args: existing
cannot\ add\ ceph\ backup\ storage,\ there\ has\ been\ some\ ceph\ backup\ storage\ using\ mon[hostnames\:%s] = 无法添加ceph镜像服务器，已经有某个ceph镜像服务器使用mon[主机名: {0}]

# at: src/main/java/org/zstack/storage/ceph/CephApiInterceptor.java:243
# args: 
poolName\ is\ required\ when\ importImages\ is\ true = 当importImages为真的时候必须填写池名

# at: src/main/java/org/zstack/storage/ceph/CephMonBase.java:66
# args: 
The\ problem\ may\ be\ caused\ by\ an\ incorrect\ user\ name\ or\ password\ or\ SSH\ port\ or\ unstable\ network\ environment = 该问题可能是由不正确的用户名、密码、SSH端口或者不稳定的网络环境引起的

# at: src/main/java/org/zstack/storage/ceph/backup/CephBackupStorageBase.java:808
# args: msg.getHostname(),msg.getBackupStorageUuid()
CephMon[hostname\:%s]\ not\ found\ on\ backup\ storage[uuid\:%s] = 

# at: src/main/java/org/zstack/storage/ceph/backup/CephBackupStorageBase.java:1170
# args: self.getUuid(),JSONObjectUtil.toJsonString(errorCodes)
unable\ to\ connect\ to\ the\ ceph\ backup\ storage[uuid\:%s].\ Failed\ to\ connect\ all\ ceph\ mons.\ Errors\ are\ %s = 无法连接到ceph镜像服务器[uuid:{0}]。所有监控节点均无法连接。错误是{1}

# at: src/main/java/org/zstack/storage/ceph/backup/CephBackupStorageBase.java:1291
# args: otherCeph.getName(),otherCeph.getUuid(),fsId
there\ is\ another\ CEPH\ backup\ storage[name\:%s,\ uuid\:%s]\ with\ the\ same\ FSID[%s],\ you\ cannot\ add\ the\ same\ CEPH\ setup\ as\ two\ different\ backup\ storage = 有另外一个CEPH镜像服务器[name:{0}, uuid:{1}]有相同的FSID[{2}]，你不能添加同样的CEPH为两个不同的镜像服务器

# at: src/main/java/org/zstack/storage/ceph/backup/CephBackupStorageMonBase.java:85
# args: uuid
cannot\ update\ status\ of\ the\ ceph\ backup\ storage\ mon[uuid\:%s],\ it\ has\ been\ deleted.This\ error\ can\ be\ ignored = 无法更新ceph镜像服务器监控节点[uuid:{0}]，他已经被删除。这个错误可以被忽略

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:1261
# args: backupStorage.getUuid(),backupStorage.getName(),bsFsid,self.getUuid(),self.getName(),getSelf().getFsid()
the\ backup\ storage[uuid\:%s,\ name\:%s,\ fsid\:%s]\ is\ not\ in\ the\ same\ ceph\ cluster\ with\ the\ primary\ storage[uuid\:%s,\ name\:%s,\ fsid\:%s] = 镜像服务器[uuid:{0}, name:{1}, fsid:{2}]和主存储[uuid:{3}, name:{4}, fsid:{5}]不在同一个ceph集群中

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:1455
# args: poolName
cannot\ find\ cephPrimaryStorage\ pool[poolName\=%s] = 

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:1461
# args: poolName
cephPrimaryStorage\ pool[poolName\=%s]\ available\ capacity\ not\ enough = 

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2235
# args: psUuid,bsUuid
fsid\ is\ not\ same\ between\ ps[%s]\ and\ bs[%s],\ create\ template\ is\ forbidden. = 在主存储和镜像服务器中fsid不是一样的，禁止创建模版。

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2665
# args: self.getUuid()
ceph\ primary\ storage[uuid\:%s]\ may\ have\ been\ deleted. = Ceph主存储[uuid:{0}]可能已经被删除

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2652
# args: self.getUuid(),JSONObjectUtil.toJsonString(errorCodes)
unable\ to\ connect\ to\ the\ ceph\ primary\ storage[uuid\:%s].\ Failed\ to\ connect\ all\ ceph\ mons.\ Errors\ are\ %s = 无法连接到ceph主存储[uuid:{0}]。所有监控节点均连接失败。错误是{1}

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2649
# args: self.getUuid()
unable\ to\ connect\ to\ the\ ceph\ primary\ storage[uuid\:%s].\ Failed\ to\ connect\ all\ ceph\ mons. = 未能连接ceph主存储[uuid:{0}]，连接所有的ceph mons失败

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2769
# args: 
the\ fsid\ returned\ by\ mons\ are\ mismatching,\ it\ seems\ the\ mons\ belong\ to\ different\ ceph\ clusters\:\n = 监控节点返回的fsid不匹配，似乎监控节点属于不同的ceph集群

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:2787
# args: otherCeph.getName(),otherCeph.getUuid(),fsId
there\ is\ another\ CEPH\ primary\ storage[name\:%s,\ uuid\:%s]\ with\ the\ same\ FSID[%s],\ you\ cannot\ add\ the\ same\ CEPH\ setup\ as\ two\ different\ primary\ storage = 有另外一个CEPH主存储[name:{0}, uuid:{1}] 有相同的 FSID[{2}]，你不能添加相同的CEPH设置到两个不同的主存储

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:3037
# args: self.getUuid(),self.getName(),mon.getSelf().getUuid(),res.error
the\ ceph\ primary\ storage[uuid\:%s,\ name\:%s]\ is\ down,\ as\ one\ mon[uuid\:%s]\ reports\ an\ operation\ failure[%s] = ceph主存储[uuid:{0}, name:{1}]关闭，因为一个mon[uuid:{2}]报告了一个操作失败[{3}]

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:3648
# args: bsType
unable\ to\ upload\ bits\ to\ the\ backup\ storage[type\:%s],\ we\ only\ support\ CEPH = 不能上传bits到镜像服务器[type:{0}]，目前只支持CEPH

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:3822
# args: volume.getUuid(),volume.getRootImageUuid()
cannot\ reinit\ rootvolume\ [%s]\ because\ image\ [%s]\ has\ been\ deleted\ and\ imagecache\ cannot\ be\ found = 

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageBase.java:3841
# args: volume.getRootImageUuid(),getSelf().getUuid()
cannot\ find\ backupstorage\ to\ download\ image\ [%s]\ to\ primarystorage\ [%s] = 

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageFactory.java:448
# args: vol.getPrimaryStorageUuid()
cannot\ find\ any\ Connected\ ceph\ mon\ for\ the\ primary\ storage[uuid\:%s] = 无法为Ceph主存储[uuid:{0}]找到一台处于Connected状态的的监控节点

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageFactory.java:745
# args: 
not\ support\ take\ volumes\ snapshots\ on\ multiple\ ps\ when\ including\ ceph = 

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageFactory.java:842
# args: targetCephPoolName,cephPoolName
ceph\ pool\ conflict,\ the\ ceph\ pool\ specified\ by\ the\ instance\ offering\ is\ %s,\ and\ the\ ceph\ pool\ specified\ in\ the\ creation\ parameter\ is\ %s = 

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageFactory.java:973
# args: targetCephPoolName,cephPoolName
ceph\ pool\ conflict,\ the\ ceph\ pool\ specified\ by\ the\ disk\ offering\ is\ %s,\ and\ the\ ceph\ pool\ specified\ in\ the\ creation\ parameter\ is\ %s = 

# at: src/main/java/org/zstack/storage/ceph/primary/CephPrimaryStorageMonBase.java:91
# args: uuid
cannot\ update\ status\ of\ the\ ceph\ primary\ storage\ mon[uuid\:%s],\ it\ has\ been\ deleted.This\ error\ can\ be\ ignored = 不能更新一台已经被删除的Ceph主存储监控节点[uuid:{0}]，这个错误可被忽略

# at: src/main/java/org/zstack/storage/device/ScsiLunAllocatorFactory.java:54
# args: firstScsiLunVO.getUuid(),scsiLunVO.getUuid()
scsi\ lun[uuid\:\ %s]\ and\ [uuid\:\ %s]\ does\ not\ has\ a\ common\ host = 

# at: src/main/java/org/zstack/storage/device/ScsiLunAllocatorFactory.java:59
# args: scsiLunVO.getUuid()
scsi\ lun[uuid\:\ %s]\ is\ in\ disabled\ state = 

# at: src/main/java/org/zstack/storage/device/ScsiLunAllocatorFactory.java:95
# args: 
no\ candidate\ host\ with\ the\ scsi\ lun\ with\ enough\ cpu\ /\ memory\ or\ Enabled/Connected\ status = 需要的lun所在的物理机都不满足cpu / memory 以及物理机状态的条件

# at: src/main/java/org/zstack/storage/device/StorageDeviceApiInterceptor.java:62
# args: msg.getIp(),msg.getPort()
iSCSI\ server[ip\:\ %s,\ port\:\ %s]\ already\ exists = 

# at: src/main/java/org/zstack/storage/device/StorageDeviceApiInterceptor.java:67
# args: msg.getIp()
iSCSI\ server\ ip\:\ %s\ is\ not\ valid = 

# at: src/main/java/org/zstack/storage/device/StorageDeviceApiInterceptor.java:76
# args: msg.getUuid(),msg.getClusterUuid()
iSCSI\ server[uuid\:\ %s]\ already\ attached\ to\ cluster[uuid\:\ %s] = 

# at: src/main/java/org/zstack/storage/device/StorageDeviceApiInterceptor.java:86
# args: msg.getUuid(),msg.getClusterUuid()
iSCSI\ server[uuid\:\ %s]\ not\ attached\ to\ cluster[uuid\:\ %s] = 

# at: src/main/java/org/zstack/storage/device/StorageDeviceApiInterceptor.java:97
# args: msg.getUuid(),clusterUuid
iSCSI\ server[uuid\:\ %s]\ still\ attached\ to\ cluster[uuid\:\ %s] = 

# at: src/main/java/org/zstack/storage/device/StorageDeviceApiInterceptor.java:126
# args: scsiLunVO.getWwid(),refVO.getVmInstanceUuid()
scsi\ lun[wwid\:\ %s]\ has\ been\ attached\ to\ vm\ instance\ %s = 

# at: src/main/java/org/zstack/storage/device/StorageDeviceManagerImpl.java:801
# args: msg.getUuid(),vmInstanceVO.getState(),allowedVmOperationStates
vm\ instance[%s]\ state\ [%s]\ not\ in\ allowed\ state[%s]\ for\ operation = 

# at: src/main/java/org/zstack/storage/device/StorageDeviceManagerImpl.java:810
# args: msg.getUuid(),vmInstanceVO.getHostUuid(),msg.getUuid()
vm\ instance[uuid\:\ %s]\ host[uuid\:\ %s]\ not\ attached\ scsi\ lun[uuid\:\ %s] = 

# at: src/main/java/org/zstack/storage/device/StorageDeviceManagerImpl.java:869
# args: msg.getVmInstanceUuid(),vmInstanceVO.getState(),allowedVmOperationStates
vm\ instance[%s]\ state[%s]\ not\ in\ allowed\ state[%s]\ for\ operation = 

# at: src/main/java/org/zstack/storage/device/StorageDeviceManagerImpl.java:878
# args: msg.getVmInstanceUuid(),hostVO.getUuid(),msg.getUuid()
vm\ instance[%s]\ host[uuid\:\ %s]\ not\ attached\ scsi\ lun[uuid\:\ %s] = 

# at: src/main/java/org/zstack/storage/device/StorageDeviceManagerImpl.java:1639
# args: refVO.getScsiLunUuid()
specified\ scsi\ lun[wwid\:\ %s]\ not\ exists\ or\ disabled = 

# at: src/main/java/org/zstack/storage/fusionstor/FusionstorApiInterceptor.java:103
# args: monUrl,MON_URL_FORMAT
invalid\ monUrl[%s].\ A\ valid\ url\ is\ in\ format\ of\ %s = 非法的monUrl[{0}]. 格式为{1}的非法url

# at: src/main/java/org/zstack/storage/fusionstor/FusionstorApiInterceptor.java:112
# args: 
dataVolumePoolName\ can\ be\ null\ but\ cannot\ be\ an\ empty\ string = 数据盘池名可以为空但是不能为一个空字符串

# at: src/main/java/org/zstack/storage/fusionstor/FusionstorApiInterceptor.java:117
# args: 
rootVolumePoolName\ can\ be\ null\ but\ cannot\ be\ an\ empty\ string = 根数据盘池名可以为空但是不能为一个空字符串

# at: src/main/java/org/zstack/storage/fusionstor/FusionstorApiInterceptor.java:122
# args: 
imageCachePoolName\ can\ be\ null\ but\ cannot\ be\ an\ empty\ string = 镜像缓存池名可以为空但是不能为空字符串

# at: src/main/java/org/zstack/storage/fusionstor/FusionstorApiInterceptor.java:153
# args: 
poolName\ can\ be\ null\ but\ cannot\ be\ an\ empty\ string = 池名可以为空但是不能是空的字符串

# at: src/main/java/org/zstack/storage/fusionstor/FusionstorApiInterceptor.java:79
# args: existing
cannot\ add\ fusionstor\ primary\ storage,\ there\ has\ been\ some\ fusionstor\ primary\ storage\ using\ mon[hostnames\:%s] = 

# at: src/main/java/org/zstack/storage/fusionstor/FusionstorApiInterceptor.java:145
# args: existing
cannot\ add\ fusionstor\ backup\ storage,\ there\ has\ been\ some\ fusionstor\ backup\ storage\ using\ mon[hostnames\:%s] = 

# at: src/main/java/org/zstack/storage/fusionstor/backup/FusionstorBackupStorageBase.java:275
# args: self.getUuid()
all\ fusionstor\ mons\ are\ Disconnected\ in\ fusionstor\ backup\ storage[uuid\:%s] = 

# at: src/main/java/org/zstack/storage/fusionstor/backup/FusionstorBackupStorageBase.java:301
# args: base.getSelf().getHostname(),ret.error
[mon\:%s],\ %s = 

# at: src/main/java/org/zstack/storage/fusionstor/backup/FusionstorBackupStorageBase.java:533
# args: self.getUuid(),JSONObjectUtil.toJsonString(errorCodes)
unable\ to\ connect\ to\ the\ fusionstor\ backup\ storage[uuid\:%s].\ Failed\ to\ connect\ all\ fusionstor\ mons.\ Errors\ are\ %s = 

# at: src/main/java/org/zstack/storage/fusionstor/backup/FusionstorBackupStorageBase.java:621
# args: otherfusion.getName(),otherfusion.getUuid(),fsId
there\ is\ another\ Fusionstor\ backup\ storage[name\:%s,\ uuid\:%s]\ with\ the\ same\ FSID[%s],\ you\ cannot\ add\ the\ same\ Fusionstor\ setup\ as\ two\ different\ backup\ storage = 

# at: src/main/java/org/zstack/storage/fusionstor/primary/FusionstorPrimaryStorageBase.java:2289
# args: base.getSelf().getHostname(),fsid,getSelf().getFsid()
the\ mon[ip\:%s]\ returns\ a\ fsid[%s]\ different\ from\ the\ current\ fsid[%s]\ of\ the\ cep\ cluster,are\ you\ adding\ a\ mon\ not\ belonging\ to\ current\ cluster\ mistakenly? = mon[ip:{0}]返回了一个fsid[{1}]和当前ceph集群的fsid[{2}]不同，你是否错误地添加了一个不属于当前集群的mon？

# at: src/main/java/org/zstack/storage/fusionstor/primary/FusionstorPrimaryStorageBase.java:2437
# args: 
backing\ up\ snapshots\ to\ backup\ storage\ is\ a\ depreciated\ feature,\ which\ will\ be\ removed\ in\ future\ version = 备份快照到镜像服务器是一个弃用的功能，将会在未来版本中被移除

# at: src/main/java/org/zstack/storage/fusionstor/primary/FusionstorPrimaryStorageBase.java:885
# args: backupStorage.getUuid(),backupStorage.getName(),bsFsid,self.getUuid(),self.getName(),getSelf().getFsid()
the\ backup\ storage[uuid\:%s,\ name\:%s,\ fsid\:%s]\ is\ not\ in\ the\ same\ fusionstor\ cluster\ with\ the\ primary\ storage[uuid\:%s,\ name\:%s,\ fsid\:%s] = 

# at: src/main/java/org/zstack/storage/fusionstor/primary/FusionstorPrimaryStorageBase.java:1616
# args: self.getUuid()
all\ fusionstor\ mons\ of\ primary\ storage[uuid\:%s]\ are\ not\ in\ Connected\ state = 

# at: src/main/java/org/zstack/storage/fusionstor/primary/FusionstorPrimaryStorageBase.java:1698
# args: self.getUuid()
fusionstor\ primary\ storage[uuid\:%s]\ may\ have\ been\ deleted. = Fusionstor主存储[uuid:{0}]可能已经被删除

# at: src/main/java/org/zstack/storage/fusionstor/primary/FusionstorPrimaryStorageBase.java:1685
# args: self.getUuid(),JSONObjectUtil.toJsonString(errorCodes)
unable\ to\ connect\ to\ the\ fusionstor\ primary\ storage[uuid\:%s].\ Failed\ to\ connect\ all\ fusionstor\ mons.\ Errors\ are\ %s = 

# at: src/main/java/org/zstack/storage/fusionstor/primary/FusionstorPrimaryStorageBase.java:1784
# args: otherFusion.getName(),otherFusion.getUuid(),fsId
there\ is\ another\ Fusionstor\ primary\ storage[name\:%s,\ uuid\:%s]\ with\ the\ same\ FSID[%s],\ you\ cannot\ add\ the\ same\ Fusionstor\ setup\ as\ two\ different\ primary\ storage = 

# at: src/main/java/org/zstack/storage/fusionstor/primary/FusionstorPrimaryStorageBase.java:2394
# args: bsType
unable\ to\ upload\ bits\ to\ the\ backup\ storage[type\:%s],\ we\ only\ support\ FUSIONSTOR = 

# at: src/main/java/org/zstack/storage/fusionstor/primary/FusionstorPrimaryStorageFactory.java:293
# args: vol.getPrimaryStorageUuid()
cannot\ find\ any\ Connected\ fusionstor\ mon\ for\ the\ primary\ storage[uuid\:%s] = 

# at: src/main/java/org/zstack/storage/fusionstor/primary/FusionstorPrimaryStorageFactory.java:613
# args: 
this\ has\ not\ been\ supported\ by\ fusionstor = 

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:123
# args: 
do\ not\ support\ storage\ migration\ with\ iso\ in\ ceph\ backup\ storage\ attached = 

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:285
# args: srcVm.getUuid(),srcVm.getName()
do\ not\ support\ storage\ migration\ of\ vm[uuid\:%s,\ name\:\ %s]\ while\ shared\ volume\ attached = 

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:163
# args: metric.getSourcePrimaryStorageType(),metric.getDestinationPrimaryStorageType()
do\ not\ support\ live\ storage\ migration\ from\ [%s]\ to\ [%s] = 不支持从[{0}]到[{1}]的在线存储迁移

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:169
# args: metric.getSourcePrimaryStorageType(),metric.getDestinationPrimaryStorageType()
do\ not\ support\ offlive\ storage\ migration\ from\ [%s]\ to\ [%s] = 不支持从[{0}]到[{1}]的离线存储迁移

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:174
# args: metric.getSourcePrimaryStorageType(),metric.getDestinationPrimaryStorageType()
do\ not\ support\ storage\ migration\ from\ [%s]\ to\ [%s]\ with\ data\ volume = 不支持从[{0}]到[{1}]的带数据盘的存储迁移

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:179
# args: metric.getSourcePrimaryStorageType(),metric.getDestinationPrimaryStorageType()
do\ not\ support\ storage\ migration\ from\ [%s]\ to\ [%s]\ with\ snapshot = 不支持从[{0}]到[{1}]的存在云盘快照的存储迁移

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:187
# args: primaryStorageVO.getType(),dstPrimaryStorageVO.getType()
do\ not\ support\ storage\ migration\ from\ [%s]\ to\ [%s] = 不支持从[{0}]到[{1}]的存储迁移

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:198
# args: 
Source\ BS\ and\ Destination\ BS\ cannot\ be\ the\ same. = 源镜像服务器和目标镜像服务器不能相同

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:206
# args: 
Source\ BS\ and\ Destination\ BS\ must\ not\ be\ Disabled. = 源镜像服务器和目标镜像服务器必须不是不可用。

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:213
# args: msg.getImageUuid()
Image[uuid\:%s]\ is\ not\ in\ status\ Ready,\ cannot\ migrate\ it. = 镜像[uuid:{0}]的状态不是已准备，不能迁移它

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:224
# args: msg.getImageUuid(),msg.getSrcBackupStorageUuid()
Image[uuid\:%s]\ is\ not\ in\ source\ backup\ storage[uuid\:%s] = 镜像[uuid:{0}]没有在源镜像服务器[uuid:{1}]

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:233
# args: srcBS.getType(),dstBS.getType()
Cannot\ migrate\ image\ from\ %s\ to\ %s. = 不能从{0}迁移镜像到{1}

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:253
# args: 
Source\ PS\ and\ Destination\ PS\ must\ not\ be\ Disabled\ or\ Maintenance\ state. = 源主存储和目标主存储必须不是不可用或者维护状态。

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:260
# args: msg.getVolumeUuid(),msg.getDstPrimaryStorageUuid()
Volume[uuid\:%s]\ is\ already\ in\ PS[uuid\:%s],\ cannot\ migrate. = 云盘[uuid:{0}]已经在主存储[uuid:{1}]里，不能迁移。

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:267
# args: msg.getVolumeUuid()
Volume[uuid\:%s]\ is\ not\ in\ status\ Ready,\ cannot\ migrate\ it. = 云盘[uuid:{0}]状态不是已准备，不能进行迁移

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:323
# args: msg.getVolumeUuid(),srcVolume.getVmInstanceUuid()
the\ volume[uuid\:%s]\ is\ still\ attached\ on\ vm[uuid\:%s],\ please\ detach\ it\ before\ migration. = 云盘[uuid:{0}]一直连接在虚拟机[uuid:{1}]，在迁移之前请先断开连接

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:331
# args: srcVolume.getUuid(),srcVolume.getName()
do\ not\ support\ storage\ migration\ while\ shared\ volume[uuid\:\ %s,\ name\:\ %s]\ attached = 加载了共享云盘[uuid:{0}, name:{1}]不支持存储迁移

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:280
# args: 
Cannot\ migrate\ root\ volume\ when\ vm\ instance\ is\ not\ stopped. = 当虚拟机不是已停止，不能迁移根云盘。

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:297
# args: 
Cannot\ migrate\ root\ volume\ when\ there\ are\ data\ volumes\ attached\ to\ the\ vm\ instance. = 当数据云盘连接在虚拟机上时，不能迁移根云盘

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:316
# args: 
The\ destination\ primary\ storage\ is\ not\ attached\ to\ any\ cluster\ that\ has\ the\ same\ L2\ networks\ as\ source\ cluster. = 目标主存储不能连接任何和源集群一样的二层网络的集群

# at: src/main/java/org/zstack/storage/migration/StorageMigrationApiInterceptor.java:341
# args: srcPS.getType(),dstPS.getType()
Cannot\ migrate\ volume\ from\ %s\ to\ %s. = 不能从{0}迁移云盘到{1}

# at: src/main/java/org/zstack/storage/migration/StorageMigrationBase.java:504
# args: vmInstanceVO.getState()
not\ support\ vm\ state[%s]\ to\ do\ storage\ migration = 虚拟机状态为[{0}],无法进行存储迁移

# at: src/main/java/org/zstack/storage/migration/StorageMigrationBase.java:476
# args: liveStorageVmState
not\ support\ live\ storage\ migration\ yet,\ since\ vm\ state\ is\ [%s] = 无法进行在线存储迁移，因为虚拟机状态为[{0}]

# at: src/main/java/org/zstack/storage/migration/StorageMigrationBase.java:463
# args: msg.getVmInstanceUuid(),size,dstPrimaryStorageVO.getCapacity().getAvailablePhysicalCapacity()
there\ are\ not\ enough\ capacity\ for\ vm[uuid\:\ %s]\ storage\ migration,\ required\ capacity(include\ image\ cache)\:\ %s,\ current\ available\ physical\ capacity\:\ %s = 对虚拟机[uuid: {0}]存储迁移需要目标主存储具有至少{1}的空余容量（容量计算包含镜像cache），但现在只有{2}的空余容量

# at: src/main/java/org/zstack/storage/migration/StorageMigrationBase.java:764
# args: srcPs.getType()
unsupported\ primary\ storage\ type[%s]\ for\ storage\ migration = 当前存储[类型:{0}]，不支持存储迁移

# at: src/main/java/org/zstack/storage/migration/backup/ReserveCapacityFromDstBSFlow.java:61
# args: imageUuid,dstBsUuid
Cannot\ reserve\ enough\ space\ for\ Image[uuid\:%s]\ in\ BS[uuid\:%s] = 不能在镜像服务器[uuid:{1}]上为镜像[uuid:{0}]预留足够的空间

# at: src/main/java/org/zstack/storage/migration/backup/ceph/CephToCephMigrateImageFlow.java:113
# args: dstBsVO.getUuid()
all\ ceph\ mons\ are\ Disconnected\ in\ ceph\ backup\ storage[uuid\:%s] = 所有在ceph镜像服务器[uuid:{0}]的监控节点都处于失联状态

# at: src/main/java/org/zstack/storage/migration/backup/ceph/CephToCephMigrateImageFlow.java:187
# args: imageUuid,srcBsUuid,dstBsUuid,errCode.getDetails()
Failed\ to\ migrate\ Image\ %s\ from\ BS\ %s\ to\ BS\ %s.\ cause\:\ %s = 

# at: src/main/java/org/zstack/storage/migration/backup/ceph/CephToCephMigrateImageFlow.java:143
# args: reply1.getTrashId(),dstBsUuid,dstImageInstallPath,reply1.getResourceUuid()
found\ trashId(%s)\ in\ BackupStorage\ [%s]\ for\ the\ migrate\ installPath[%s].\ Please\ clean\ it\ first\ by\ 'APICleanUpTrashOnBackupStorageMsg'\ if\ you\ insist\ to\ migrate\ the\ image[%s] = 在备份存储[{1}]的回收数据({0})中己存在要迁移的目标路径[{2}]，如果要继续迁移镜像[{3}]，请先调用'APICleanUpTrashOnBackupStorageMsg'来手动清理该回收数据

# at: src/main/java/org/zstack/storage/migration/primary/ReserveCapacityFromDstPSFlow.java:85
# args: volumeUuid,dstPsUuid
Cannot\ reserve\ enough\ space\ for\ Volume[uuid\:%s]\ in\ PS[uuid\:%s] = 不能在主存储[uuid:{1}]为云盘[uuid:{0}]预留足够的空间

# at: src/main/java/org/zstack/storage/migration/primary/ceph/CephToCephMigrateVolumeFlow.java:101
# args: dstPsVO.getUuid()
all\ ceph\ mons\ are\ Disconnected\ in\ ceph\ primary\ storage[uuid\:%s] = 所有的ceph mons无法连接到主存储[uuid:{0}]

# at: src/main/java/org/zstack/storage/migration/primary/ceph/CephToCephMigrateVolumeFlow.java:492
# args: volume.getType()
The\ type\ [%s]\ of\ destination\ volume\ is\ invalid. = 目标云盘的类型是无效的

# at: src/main/java/org/zstack/storage/migration/primary/nfs/NfsToNfsMigrateVolumeFlow.java:93
# args: 
cannot\ find\ any\ connected\ host\ to\ perform\ the\ storage\ migration\ operation = 为了执行存储迁移操作，未找到连接的物理机

# at: src/main/java/org/zstack/storage/migration/primary/nfs/NfsToNfsMigrateVolumeFlow.java:195
# args: imageUuid
both\ image\ %s\ and\ its\ cache\ is\ missing = 

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:183
# args: 
'resourceUuid'\ and\ 'resourceType'\ must\ be\ set\ both\ or\ neither! = 

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:79
# args: 
zoneUuids,\ clusterUuids,\ primaryStorageUuids\ must\ have\ at\ least\ one\ be\ none-empty\ list,\ or\ all\ is\ set\ to\ true = 区域、集群、主存储的Uuids中必须至少有一个不为空列表，除非将字段 all 设为 true

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:101
# args: msg.getPrimaryStorageUuid(),msg.getClusterUuid()
primary\ storage[uuid\:%s]\ has\ not\ been\ attached\ to\ cluster[uuid\:%s]\ yet = 主存储[uuid:{0}]还未加载到集群[uuid:{1}]上

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:118
# args: msg.getPrimaryStorageUuid(),msg.getClusterUuid()
primary\ storage[uuid\:%s]\ has\ been\ attached\ to\ cluster[uuid\:%s] = 主存储[uuid:{0}]已被加载到集群[uuid:{1}]上

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:133
# args: msg.getPrimaryStorageUuid(),msg.getClusterUuid()
primary\ storage[uuid\:%s]\ and\ cluster[uuid\:%s]\ are\ not\ in\ the\ same\ zone = 主存储[uuid:{0}]和集群[uuid:{1}]不在同一个区域内

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:155
# args: url
url[%s]\ has\ been\ occupied,\ it\ cannot\ be\ duplicate\ in\ same\ cluster = url[{0}]已经被占用，在相同的集群里它不能再次使用

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageApiInterceptor.java:175
# args: msg.getPrimaryStorageUuid(),clusterUuidsString
primary\ storage[uuid\:%s]\ cannot\ be\ deleted\ for\ still\ being\ attached\ to\ cluster[uuid\:%s]. = 不能删除主存储[uuid:{0}]，因为它还被加载在集群[uuid:{1}]上

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageAvoidAllocatorFlow.java:50
# args: spec.getAvoidPrimaryStorageUuids()
after\ removing\ primary\ storage%s\ to\ avoid,\ there\ is\ no\ candidate\ primary\ storage\ anymore.\ please\ check\ primary\ storage\ status\ and\ state\ in\ the\ cluster. = 把主存储{0}移到排除列表后，就没有可用的主存储了，请确认集群中主存储的状态

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageBase.java:772
# args: spec.getInstallPath(),spec.getResourceType()
%s\ is\ still\ in\ using\ by\ %s,\ cannot\ remove\ it\ from\ trash... = 

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageBase.java:217
# args: self.getUuid()
cannot\ attach\ ISO\ to\ a\ primary\ storage[uuid\:%s]\ which\ is\ disabled = 

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageBase.java:632
# args: bsUuid,self.getZoneUuid(),self.getUuid()
backup\ storage[uuid\:%s]\ is\ not\ attached\ to\ zone[uuid\:%s]\ the\ primary\ storage[uuid\:%s]\ belongs\ to = 镜像服务器[uuid:{0}]没有加载到主存储[uuid:{2}]所在的区域[uuid:{1}]

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageBase.java:739
# args: 
operation\ not\ supported = 不支持的操作

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageBase.java:1486
# args: volumeUuid
cannot\ attach\ volume[uuid\:%s]\ whose\ primary\ storage\ is\ Maintenance = 无法挂载云盘[uuid:{0}]，其主存储处于维护模式

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageCapacityUpdater.java:283
# args: size,capacityVO.getUuid()
cannot\ reserve\ %s\ bytes\ on\ the\ primary\ storage[uuid\:%s],\ it's\ short\ of\ available\ capacity = 无法在主存储[uuid:{1}]上保留{0}字节，可用容量不足

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageDeleteBitGC.java:45
# args: ps.getUuid(),ps.getStatus().toString()
the\ primary\ storage[uuid\:%s]\ is\ not\ in\ status\ of\ Connected,\ current\ status\ is\ %s = 主存储[uuid:{0}]的状态不是已连接，当前的状态是{1}

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageMainAllocatorFlow.java:241
# args: ret.error
%s = {0}

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:658
# args: vmUuid
the\ VM[uuid\:%s]\ volume\ stored\ location\ primary\ storage\ is\ in\ a\ state\ of\ maintenance = 虚拟机[{0}]云盘所在主存储处于维护状态

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:100
# args: systemTag,uuid
%s\ is\ invalid.\ %s\ is\ not\ a\ valid\ zstack\ uuid = {0}是无效的，{1}不是一个有效的ZStack uuid

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:104
# args: resourceUuid
no\ primary\ storage[uuid\:%s]\ found = 找不到主存储[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:435
# args: errs
cannot\ find\ any\ qualified\ primary\ storage,\ errors\ are\ %s = 找不到可用的主存储，错误为:{0}

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:511
# args: cidr
cidr[%s]\ Input\ Format\ Error = 

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:507
# args: cidrCount
only\ one\ primaryStorage\ cidr\ system\ tag\ is\ allowed,\ but\ %d\ got = 

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:701
# args: psUuid,msg.getPrimaryStorageUuidForRootVolume()
primaryStorageUuid\ conflict,\ the\ primary\ storage\ specified\ by\ the\ instance\ offering\ is\ %s,\ and\ the\ primary\ storage\ specified\ in\ the\ creation\ parameter\ is\ %s = 

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageManagerImpl.java:783
# args: psUuid,msg.getPrimaryStorageUuid()
primaryStorageUuid\ conflict,\ the\ primary\ storage\ specified\ by\ the\ disk\ offering\ is\ %s,\ and\ the\ primary\ storage\ specified\ in\ the\ creation\ parameter\ is\ %s = 

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageReservedCapacityAllocatorFlow.java:55
# args: PrimaryStorageGlobalConfig.RESERVED_CAPACITY.value(),spec.getSize()
after\ subtracting\ reserved\ capacity[%s],\ there\ is\ no\ primary\ storage\ having\ required\ size[%s\ bytes] = 释放保留容量[{0}]后，就没有主存储拥有要求的大小: {1}字节了

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageTagAllocatorExtension.java:127
# args: uuid
cannot\ find\ primary\ storage[uuid\:%s],\ the\ uuid\ is\ specified\ in\ instance\ offering\ or\ disk\ offering = 找不到由计算规格或云盘规格指定的主存储[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageTagAllocatorExtension.java:167
# args: tag
cannot\ find\ primary\ storage\ having\ user\ tag[%s].\ The\ user\ tag\ is\ specified\ in\ instance\ offering\ or\ disk\ offering = 找不到带有指定用户标签的主存储[uuid:{0}]，该标签由计算规格或者云盘规格指定

# at: src/main/java/org/zstack/storage/primary/PrimaryStorageTagAllocatorFlow.java:85
# args: extp.getClass().getName()
PrimaryStorageTagAllocatorExtensionPoint[%s]\ returns\ zero\ primary\ storage\ candidate = 主存储标签分配插件[{0}]找不到可用的主存储

# at: src/main/java/org/zstack/storage/primary/imagestore/ceph/CephPrimaryToImageStoreBackupStorageMediatorImpl.java:132
# args: path,JSONObjectUtil.toJsonString(errorCodes)
all\ mons\ failed\ to\ execute\ http\ call[%s],\ errors\ are\ %s = 所有的监控节点都无法执行http call[{0}]，错误是{1}

# at: src/main/java/org/zstack/storage/primary/imagestore/ceph/CephPrimaryToImageStoreBackupStorageMediatorImpl.java:97
# args: vo.getUuid()
all\ ceph\ mons\ of\ primary\ storage[uuid\:%s]\ are\ not\ in\ Connected\ state = Ceph主存储[uuid:{0}]所有的监控节点都不是已连接状态

# at: src/main/java/org/zstack/storage/primary/imagestore/ceph/CephPrimaryToImageStoreBackupStorageMediatorImpl.java:120
# args: param.getPrimaryStorageUuid()
CephPrimaryStorage[%s]\ not\ existed! = Ceph镜像服务器[{0}]不存在

# at: src/main/java/org/zstack/storage/primary/imagestore/ceph/CephPrimaryToImageStoreBackupStorageMediatorImpl.java:170
# args: licMgr.getLicenseType().toString()
current\ license[%s]\ is\ not\ valid\ license\ while\ download\ from\ imagestore\ backupstorage = 当从ImageStore镜像服务器进行下载操作，当前证书[{0}]是无效的证书

# at: src/main/java/org/zstack/storage/primary/imagestore/local/LocalStorageKvmImageStoreBackupStorageMediatorImpl.java:270
# args: pinv.getUuid(),primaryStorageInstallPath,r.getHostname(),rsp.getError()
failed\ to\ upload\ bits\ from\ the\ local\ storage[uuid\:%s,\ path\:%s]\ to\ image\ store\ [hostname\:%s],\ %s = 无法从本地存储[uuid:{0}, path:{1}]上传数据到镜像仓库[主机名:{2}]，因为{3}

# at: src/main/java/org/zstack/storage/primary/imagestore/nfs/NfsPrimaryToImageStoreBackupKVMBackend.java:262
# args: greply.getHostname(),backupStorageInstallPath,pinv.getUuid(),primaryStorageInstallPath,rsp.getError()
failed\ to\ download\ bits\ from\ the\ imagestore\ backup\ storage[hostname\:%s,\ path\:\ %s]\ to\ the\ nfs\ primary\ storage[uuid\:%s,\ path\:\ %s],\ %s = 无法从ImageStore镜像服务器[hostname:{0}, path: {1}]下载数据到NFS主存储[uuid:{2}, path: {3}]，错误细节: {4}

# at: src/main/java/org/zstack/storage/primary/imagestore/nfs/NfsPrimaryToImageStoreBackupKVMBackend.java:323
# args: pinv.getUuid(),primaryStorageInstallPath,r.getHostname(),rsp.getError()
failed\ to\ upload\ bits\ from\ the\ NFS[uuid\:%s,\ path\:%s]\ to\ image\ store\ [hostname\:%s],\ %s = 无法从NFS主存储[uuid:{0}, path:{1}]上传数据到镜像仓库[主机名:{2}]，因为{3}

# at: src/main/java/org/zstack/storage/primary/local/AllocatePrimaryStorageForVmMigrationFlow.java:85
# args: volumeSize,spec.getVmInstance().getUuid()
no\ hosts\ can\ provide\ %s\ bytes\ for\ all\ volumes\ of\ the\ vm[uuid\:%s] = 

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageAllocatorFactory.java:311
# args: 
localstorage\ allocator\ failed = localstorage类型的主存储过滤失败

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:90
# args: msg.getVolumeUuid()
the\ volume[uuid\:%s]\ is\ not\ on\ any\ local\ primary\ storage = 云盘[uuid:{0}]不在任一本地主存储上

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:95
# args: msg.getVolumeUuid(),msg.getDestHostUuid()
the\ volume[uuid\:%s]\ is\ already\ on\ the\ host[uuid\:%s] = 云盘[uuid:{0}]已经在物理机[uuid:{1}]上

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:101
# args: msg.getPrimaryStorageUuid()
the\ primary\ storage[uuid\:%s]\ is\ not\ found = 主存储[uuid:{0}]未找到

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:105
# args: ref.getPrimaryStorageUuid()
the\ primary\ storage[uuid\:%s]\ is\ disabled\ or\ maintenance\ cold\ migrate\ is\ not\ allowed = 主存储[uuid:{0}]为Disabled或维护状态时不允许冷迁移

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:114
# args: msg.getDestHostUuid(),ref.getPrimaryStorageUuid(),msg.getVolumeUuid()
the\ dest\ host[uuid\:%s]\ doesn't\ belong\ to\ the\ local\ primary\ storage[uuid\:%s]\ where\ the\ volume[uuid\:%s]\ locates = 目标物理机[uuid:{0}]不在云盘[uuid:{2}]位于的本地主存储[uuid:{1}]上

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:120
# args: msg.getDestHostUuid(),msg.getPrimaryStorageUuid(),physicalThreshold,refVO.getAvailablePhysicalCapacity()
the\ dest\ host[uuid\:%s]\ doesn't\ have\ enough\ physical\ capacity\ due\ to\ the\ threshold\ of\ primary\ storage[uuid\:%s]\ is\ %f\ but\ available\ physical\ capacity\ is\ %d = 目标物理机[uuid:{0}]没有足够的物理容量，因为设置的主存储[uuid:{1}]可用阈值为{2}，但实际可用物理容量是{3}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:127
# args: msg.getVolumeUuid()
the\ volume[uuid\:%s]\ is\ not\ in\ status\ of\ Ready,\ cannot\ migrate\ it = 云盘[uuid:{0}]的状态不是Ready，不能迁移

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:139
# args: vol.getUuid(),vol.getVmInstanceUuid(),vmstate
the\ volume[uuid\:%s]\ is\ the\ root\ volume\ of\ the\ vm[uuid\:%s].\ Currently\ the\ vm\ is\ in\ state\ of\ %s,\ please\ stop\ it\ before\ migration = 云盘[uuid:{0}]是云主机[uuid:{1}]的根云盘。当前云主机的状态为{2}，请停止后再迁移

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:147
# args: vol.getUuid(),vol.getVmInstanceUuid(),count
the\ volume[uuid\:%s]\ is\ the\ root\ volume\ of\ the\ vm[uuid\:%s].\ Currently\ the\ vm\ still\ has\ %s\ data\ volumes\ attached,\ please\ detach\ them\ before\ migration = 云盘[uuid:{0}]是云主机[uuid:{1}]的根云盘。当前云主机仍有已挂载的数据云盘，请卸载后再迁移

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:152
# args: vol.getUuid(),vol.getVmInstanceUuid()
the\ volume[uuid\:%s]\ is\ the\ root\ volume\ of\ the\ vm[uuid\:%s].\ Currently\ the\ vm\ still\ has\ ISO\ attached,\ please\ detach\ it\ before\ migration = 

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:177
# args: originClusterUuid,clusterUuid,vol.getVmInstanceUuid()
The\ two\ clusters[uuid\:%s,uuid\:%s]\ cannot\ access\ each\ other\ in\ l2\ network\ \ when\ migrate\ the\ vm[uuid\:%s]\ to\ another\ cluster = 两个集群[uuid:{0},uuid:{1}]无法在L2网络中互相访问对方，当迁移云主机[uuid:{2}]从其中一个集群到另一个集群时

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:132
# args: vol.getUuid(),vol.getName(),vol.getVmInstanceUuid()
the\ data\ volume[uuid\:%s,\ name\:\ %s]\ is\ still\ attached\ to\ the\ VM[uuid\:%s].\ Please\ detach\ it\ before\ migration = 数据云盘[uuid:{0}, 名称: {1}]仍然挂载在云主机[uuid:{2}]上，请在迁移前卸载

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageApiInterceptor.java:191
# args: msg.getUrl()
the\ url[%s]\ is\ not\ an\ absolute\ path\ starting\ with\ '/' = url[{0}]不是一个以'/'开头的绝对路径

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:259
# args: msg.getPrimaryStorageUuid()
The\ primary\ storage[uuid\:%s]\ is\ disabled\ cold\ migrate\ is\ not\ allowed = 主存储[uuid:{0}]Disabled时不允许冷迁移

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:561
# args: msg.getVolumeUuid()
volume[uuid\:%s]\ is\ not\ on\ the\ local\ storage\ anymore,it\ may\ have\ been\ deleted = 云盘[uuid:{0}]已经不在本地存储上，可能已经被删除

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:1361
# args: resUuid,uuid
Resource[uuid\:%s]\ can\ only\ be\ operated\ on\ host[uuid\:%s],\ but\ the\ host\ has\ been\ deleted = 资源[uuid:{0}]只能在物理机[uuid:{0}]上对其操作，但是该物理机已经被删除了

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:1357
# args: resUuid
cannot\ find\ any\ host\ which\ has\ resource[uuid\:%s] = 找不到任何拥有资源[uuid:{0}]的物理机

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:1354
# args: resUuid,vo.getResourceName(),vo.getResourceType()
cannot\ find\ any\ host\ which\ has\ resource[uuid\:%s],\ name\ \:[%s],\ type\ \:[%s] = 未找到拥有资源[uuid:{0}], name :[{1}], type :[{2}]的物理机

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:2077
# args: msg.getVolumeUuid(),self.getUuid()
unable\ to\ create\ the\ data\ volume[uuid\:\ %s]\ on\ a\ local\ primary\ storage[uuid\:%s],\ because\ the\ hostUuid\ is\ not\ specified. = 不能在本地主存储[uuid:{1}]上创建云盘[uuid:{0}]，因为物理机uuid没有指定

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:2588
# args: 
No\ Host\ state\ is\ Enabled,\ Please\ check\ the\ availability\ of\ the\ host = 

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:2695
# args: hostUuid,self.getUuid()
host[uuid\:%s]\ cannot\ access\ local\ storage[uuid\:%s],\ maybe\ it\ is\ detached = 

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:2719
# args: resUuid,resourceType,self.getUuid()
resource[uuid\:%s,\ type\:\ %s]\ is\ not\ on\ the\ local\ primary\ storage[uuid\:%s] = 

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageBase.java:2724
# args: resUuid,resourceType,self.getUuid(),ret
resource[uuid\:%s,\ type\:\ %s]\ on\ the\ local\ primary\ storage[uuid\:%s]\ maps\ to\ multiple\ hypervisor%s = 

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageDefaultAllocateCapacityFlow.java:100
# args: PrimaryStorageState.Enabled,PrimaryStorageStatus.Connected,clusterUuid
There\ is\ no\ LocalStorage\ primary\ storage[state\=%s,status\=%s]\ on\ the\ cluster[%s],\ when\ the\ cluster\ mounts\ multiple\ primary\ storage,\ the\ system\ uses\ the\ local\ primary\ storage\ by\ default.\ Check\ the\ state/status\ of\ primary\ storage\ and\ make\ sure\ they\ have\ been\ attached\ to\ clusters = 在集群[{2}]里没有LocalStorage主存储[state={0},status={1}]，当集群挂载了多个主存储的时候，系统默认的是local主存储。检查主存储的状态并确定是否连接了集群

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageDefaultAllocateCapacityFlow.java:119
# args: psUuid
the\ type\ of\ primary\ storage[uuid\:%s]\ chosen\ is\ not\ local\ storage,\ check\ if\ the\ resource\ can\ be\ created\ on\ other\ storage\ when\ cluster\ has\ attached\ local\ primary\ storage = 被选择的主存储[uuid:{0}]的类型不是本地存储，检查该资源能否在其他存储上被创建当集群已经挂载了本地存储

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageDefaultAllocateCapacityFlow.java:184
# args: requiredPrimaryStorageUuidForDataVolume.getUuid(),requiredPrimaryStorageUuidForDataVolume.getType(),LocalStorageConstants.LOCAL_STORAGE_TYPE
The\ cluster\ mounts\ multiple\ primary\ storage[%s(%s),\ other\ non-LocalStorage\ primary\ storage],\ primaryStorageUuidForDataVolume\ cannot\ be\ specified\ %s = 集群绑定了多个主存储[{0}({1}), 其他的非LocalStorage主存储]，主存储根云盘未进行指定{2}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageDesignatedAllocateCapacityFlow.java:119
# args: spec.getDestHost().getClusterUuid()
The\ cluster[uuid\=%s]\ mounts\ multiple\ primary\ storage[LocalStorage,\ other\ non-LocalStorage\ primary\ storage],\ You\ must\ specify\ the\ primary\ storage\ where\ the\ root\ disk\ is\ located = 集群[uuid={0}]绑定了多个主存储[LocalStorage, 其他非LocalStorage主存储]，需要检验下根云盘所在的主存储

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageDesignatedAllocateCapacityFlow.java:125
# args: spec.getDestHost().getClusterUuid()
The\ cluster[uuid\=%s]\ mounts\ multiple\ primary\ storage[LocalStorage,\ other\ non-LocalStorage\ primary\ storage],\ You\ must\ specify\ the\ primary\ storage\ where\ the\ data\ disk\ is\ located = 集群[uuid={0}]绑定了多个主存储[LocalStorage, 其他非LocalStorage主存储]，需要检验下根云盘所在的主存储。

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:358
# args: spec.getVmInventory().getHypervisorType()
local\ storage\ doesn't\ support\ live\ migration\ for\ hypervisor[%s] = 本地存储不支持对虚拟化类型[{0}]进行热迁移

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:574
# args: volume.getUuid(),vm.getUuid(),vm.getRootVolumeUuid(),rootHost,volume.getUuid(),dataHost
cannot\ attach\ the\ data\ volume[uuid\:%s]\ to\ the\ vm[uuid\:%s].\ Both\ vm's\ root\ volume\ and\ the\ data\ volume\ are\ on\ local\ primary\ storage,\ but\ they\ are\ on\ different\ hosts.\ The\ root\ volume[uuid\:%s]\ is\ on\ the\ host[uuid\:%s]\ but\ the\ data\ volume[uuid\:\ %s]\ is\ on\ the\ host[uuid\:\ %s] = 不能加载数据云盘[uuid:{0}]到云主机[uuid:{1}]。根云盘和数据云盘都在本地主存储上，但他们属于不同的物理机。根云盘[uuid:{2}]在物理机[uuid:{3}]上，但数据云盘[uuid:{4}]在物理机[uuid:{5}]上

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:802
# args: vol.getName(),vol.getUuid(),vol.getPrimaryStorageUuid()
the\ data\ volume[name\:%s,\ uuid\:%s]\ is\ on\ the\ local\ storage[uuid\:%s];\ however,the\ host\ on\ which\ the\ data\ volume\ is\ has\ been\ deleted.\ Unable\ to\ recover\ this\ volume = 数据云盘[name:{0}, uuid:{1}]在本地存储[uuid:{2}]上；然而物理机内的数据云盘已经被删除了

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:844
# args: vm.getUuid(),vm.getName(),psuuid
unable\ to\ recover\ the\ vm[uuid\:%s,\ name\:%s].\ The\ vm's\ root\ volume\ is\ on\ the\ local\ storage[uuid\:%s];\ however,\ the\ host\ on\ which\ the\ root\ volume\ is\ has\ been\ deleted = 不能恢复云主机[uuid:{0}, name:{1}]。云主机的根云盘在本地存储[uuid:{2}]上；然而物理机内的根云盘已经被删除了

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:881
# args: vm.getUuid()
unable\ to\ live\ migrate\ vm[uuid\:%s]\ with\ data\ volumes\ on\ local\ storage.\ Need\ detach\ all\ data\ volumes\ first. = 无法在本地存储上热迁移挂载了数据云盘的云主机[uuid:{0}]。需要先手动卸载所有数据云盘

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:886
# args: vm.getUuid(),vm.getPlatform()
unable\ to\ live\ migrate\ vm[uuid\:%s]\ with\ local\ storage.\ Only\ linux\ guest\ is\ supported.\ Current\ platform\ is\ [%s] = 无法在本地存储上热迁移云主机[uuid:{0}]。只有Linux类型的云主机支持该操作。当前类型为: [{1}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:891
# args: vm.getUuid()
unable\ to\ live\ migrate\ vm[uuid\:%s]\ with\ ISO\ on\ local\ storage.\ Need\ detach\ all\ ISO\ first. = 

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:922
# args: vm.getUuid()
unable\ to\ live\ migrate\ with\ local\ storage.\ The\ vm[uuid\:%s]\ has\ volumes\ on\ local\ storage,to\ protect\ your\ data,\ please\ stop\ the\ vm\ and\ do\ the\ volume\ migration = 本地存储不能热迁移。云主机[uuid:{0}]在本地存储上有云盘，为了保护你的数据，请停止云主机做云盘迁移

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:972
# args: LocalStorageSystemTags.DEST_HOST_FOR_CREATING_DATA_VOLUME.getTagFormat()
To\ create\ data\ volume\ on\ the\ local\ primary\ storage,\ you\ must\ specify\ the\ host\ that\ the\ data\ volume\ is\ going\ to\ be\ created\ using\ the\ system\ tag\ [%s] = 要在本地主存储上创建数据云盘，必须用系统标签[{0}]指定创建数据云盘的物理机

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageFactory.java:982
# args: hostUuid,msg.getPrimaryStorageUuid()
the\ host[uuid\:%s]\ doesn't\ belong\ to\ the\ local\ primary\ storage[uuid\:%s] = 物理机[uuid:{0}] 不属于本地主存储[uuid:{1}]

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmBackend.java:1674
# args: 
root\ image\ has\ been\ deleted,\ cannot\ reimage\ now = 系统镜像已经被删除，无法重制云主机

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmBackend.java:2941
# args: makeInitializedFilePath(),hostUuid
cannot\ find\ flag\ file\ [%s]\ on\ host\ [%s],\ it\ might\ not\ mount\ correct\ path = 

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmFactory.java:102
# args: context.getInventory().getUuid(),priUuid,reply.getError()
KVM\ host[uuid\:\ %s]\ fails\ to\ be\ added\ into\ local\ primary\ storage[uuid\:\ %s],\ %s = 本地存储[uuid:{1}]添加物理机[uuid:{0}]失败，{2}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmSftpBackupStorageMediatorImpl.java:204
# args: greply.getHostname(),backupStorageInstallPath,pinv.getUuid(),primaryStorageInstallPath,rsp.getError()
failed\ to\ download\ bits\ from\ the\ SFTP\ backup\ storage[hostname\:%s,\ path\:\ %s]\ to\ the\ local\ primary\ storage[uuid\:%s,\ path\:\ %s],\ %s = 从SFTP镜像服务器[hostname:{0}, path: {1}] 下载到本地存储[uuid:{2}, path: {3}]失败，{4}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageKvmSftpBackupStorageMediatorImpl.java:254
# args: pinv.getUuid(),primaryStorageInstallPath,r.getHostname(),backupStorageInstallPath,rsp.getError()
failed\ to\ upload\ bits\ from\ the\ local\ storage[uuid\:%s,\ path\:%s]\ to\ the\ SFTP\ backup\ storage[hostname\:%s,\ path\:%s],\ %s = 从本地存储[uuid:{0}, path: {1}]上传到SFTP镜像服务器[hostname:{2}, path:{3}]失败, {4}

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageMainAllocatorFlow.java:157
# args: PrimaryStorageState.Enabled,PrimaryStorageStatus.Connected,HostState.Enabled,HostStatus.Connected,spec.getSize()
no\ local\ primary\ storage\ can\ satisfy\ conditions[state\:\ %s,\ status\:\ %s]\ or\ contain\ hosts\ satisfying\ conditions[state\:\ %s,\ status\:\ %s,\ size\ >\ %s\ bytes] = 

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageMainAllocatorFlow.java:132
# args: spec.getRequiredZoneUuid(),PrimaryStorageState.Enabled,PrimaryStorageStatus.Connected,HostState.Enabled,HostStatus.Connected,spec.getSize()
no\ local\ primary\ storage\ in\ zone[uuid\:%s]\ can\ satisfy\ conditions[state\:\ %s,\ status\:\ %s]\ or\ contain\ hosts\ satisfying\ conditions[state\:\ %s,\ status\:\ %s,\ size\ >\ %s\ bytes] = 

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageMainAllocatorFlow.java:105
# args: spec.getRequiredHostUuid(),HostState.Enabled,HostStatus.Connected,spec.getSize(),PrimaryStorageState.Enabled,PrimaryStorageStatus.Connected
the\ required\ host[uuid\:%s]\ cannot\ satisfy\ conditions[state\:\ %s,\ status\:\ %s,\ size\ >\ %s\ bytes],\ or\ doesn't\ belong\ to\ a\ local\ primary\ storage\ satisfying\ conditions[state\:\ %s,\ status\:\ %s],\ or\ its\ cluster\ doesn't\ attach\ to\ any\ local\ primary\ storage = 

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageMainAllocatorFlow.java:77
# args: spec.getRequiredPrimaryStorageUuid(),PrimaryStorageState.Enabled,PrimaryStorageStatus.Connected,HostState.Enabled,HostStatus.Connected,spec.getSize()
required\ local\ primary\ storage[uuid\:%s]\ cannot\ satisfy\ conditions[state\:\ %s,\ status\:\ %s],\ or\ hosts\ providing\ the\ primary\ storage\ don't\ satisfy\ conditions[state\:\ %s,\ status\:\ %s,\ size\ >\ %s\ bytes] = 

# at: src/main/java/org/zstack/storage/primary/local/LocalStorageMainAllocatorFlow.java:198
# args: ref.getHostUuid(),physicalCapacityMgr.getRatio(ref.getPrimaryStorageUuid())
{the\ physical\ capacity\ usage\ of\ the\ host[uuid\:%s]\ has\ exceeded\ the\ threshold[%s]} = 

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageBase.java:152
# args: psUuid,imageFormat
cannot\ find\ proper\ hypervisorType\ for\ primary\ storage[uuid\:%s]\ to\ handle\ image\ format\ or\ volume\ format[%s] = 对主存储[uuid:{0}]来说不能发现合适的管理程序类型来处理镜像格式或云盘格式[{1}]

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageBase.java:216
# args: self.getUuid(),self.getName()
the\ mini\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ any\ available\ host\ in\ attached\ clusters\ for\ instantiating\ the\ volume = 

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageBase.java:431
# args: 
can\ not\ determine\ which\ host = 

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageBase.java:1091
# args: hostUuid,self.getUuid(),ref.getAvailableCapacity(),size
host[uuid\:\ %s]\ of\ mini\ primary\ storage[uuid\:\ %s]\ doesn't\ have\ enough\ capacity[current\:\ %s\ bytes,\ needed\:\ %s] = 

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageFactory.java:167
# args: hvType,bsType
no\ LocalStorageBackupStorageMediator\ supporting\ hypervisor[%s]\ and\ backup\ storage\ type[%s]\  = 没有LocalStorageBackupStorageMediator支持hypervisor[{0}]和镜像服务器类型[{1}]

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageImageStoreBackend.java:61
# args: volumeUuid
can\ not\ get\ cluster\ uuid\ of\ volume\ %s = 

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageKvmBackend.java:177
# args: clusterUuid
no\ connected\ host\ found\ in\ the\ cluster[uuid\:%s] = cluster[uuid:{0}]不存在已连接的物理机

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageKvmBackend.java:1206
# args: backupStorageUuid
cannot\ find\ backup\ storage[uuid\:%s] = 找不到镜像服务器[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageKvmBackend.java:1023
# args: msg.getVolumeUuid()
can\ not\ find\ volume[uuid\:\ %s] = 找不到云盘[uuid: {0}]

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageKvmCommandSender.java:246
# args: rsp.error
operation\ error,\ because\:%s = 操作错误，因为{0}

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStorageKvmFactory.java:723
# args: volume.getUuid(),volume.getPrimaryStorageUuid()
can\ not\ find\ any\ available\ host\ to\ resize\ volume[uuid\:\ %s]\ on\ mini\ storage[uuid\:\ %s] = 

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStoragePlacementManagerImpl.java:184
# args: primaryStorageUuid
cannot\ find\ an\ available\ host\ to\ execute\ command\ for\ primary\ storage[uuid\:\ %s] = 

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStoragePlacementManagerImpl.java:215
# args: hostUuid
can\ not\ allocate\ storage\ sync\ port\ on\ host\ %s\:\ %s = 

# at: src/main/java/org/zstack/storage/primary/ministorage/MiniStoragePlacementManagerImpl.java:322
# args: hostUuids,connectedEnabledHosts
expect\ operate\ on\ hosts[%s]\ but\ only\ host\ %s\ are\ connected\ and\ enabled = 

# at: src/main/java/org/zstack/storage/primary/nfs/NfsApiParamChecker.java:46
# args: url,zoneUuid
there\ has\ been\ a\ nfs\ primary\ storage\ having\ url\ as\ %s\ in\ zone[uuid\:%s] = 区域[uuid:{1}]内已经存在 url 为 {0} 的 NFS 主存储

# at: src/main/java/org/zstack/storage/primary/nfs/NfsApiParamChecker.java:65
# args: 
found\ multiple\ CIDR = 返现多个CIDR

# at: src/main/java/org/zstack/storage/primary/nfs/NfsApiParamChecker.java:78
# args: cidr
invalid\ CIDR\:\ %s = 无效CIDR: {0}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsApiParamChecker.java:82
# args: ipAddr,cidr
IP\ address[%s]\ is\ not\ in\ CIDR[%s] = IP地址[{0}]没有在CIDR[{1}]内

# at: src/main/java/org/zstack/storage/primary/nfs/NfsApiParamChecker.java:96
# args: vms.size(),StringUtils.join(vms, "\n")
there\ are\ %s\ running\ VMs\ on\ the\ NFS\ primary\ storage,\ please\ stop\ them\ and\ try\ again\:\n%s\n = 在NFS主存储上有{0}个运行中的VM，请先手动关闭再尝试: \n{1}\n

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:227
# args: 
cannot\ find\ usable\ backend = 无法找到可用的NFS主存储后端

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:285
# args: 
no\ usable\ backend\ found = 无法找到可用的NFS主存储后端

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:425
# args: self.getUuid(),self.getName(),msg.getVolume().getUuid(),msg.getSnapshot().getUuid(),msg.getSnapshot().getName()
no\ host\ in\ Connected\ status\ to\ which\ nfs\ primary\ storage[uuid\:%s,\ name\:%s]\ attached\ found\ to\ revert\ volume[uuid\:%s]\ to\ snapshot[uuid\:%s,\ name\:%s] = 没有找到挂载到NFS主存储[uuid:{0}, name:{1}]且处于Connected状态的物理机，无法回退云盘[uuid:{2}]到快照[uuid:{3}, name:{4}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:456
# args: self.getUuid(),self.getName(),msg.getVolume().getUuid(),msg.getVolume().getRootImageUuid()
no\ host\ in\ Connected\ status\ to\ which\ nfs\ primary\ storage[uuid\:%s,\ name\:%s]\ attached\ found\ to\ revert\ volume[uuid\:%s]\ to\ image[uuid\:%s] = 没有找到挂载到NFS主存储[uuid:{0}, name:{1}]且处于Connected状态的物理机，无法回退云盘[uuid:{2}]到镜像[uuid:{3}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:535
# args: vol.getVmInstanceUuid(),state
vm[uuid\:%s]\ is\ not\ Running,\ Paused\ or\ Stopped,\ current\ state\ is\ %s = 云主机[uuid:{0}]不是运行中、已暂停或者已停止状态，现在的状态是{1}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:578
# args: self.getUuid()
primary\ storage[uuid\:%s]\ doesn't\ attach\ to\ any\ cluster = 主存储[uuid:{0}]没有挂载到任何集群

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:771
# args: self.getUuid(),self.getName(),msg.getVolume().getUuid(),msg.getVolume().getName()
the\ NFS\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ any\ usable\ host\ to\ create\ the\ data\ volume[uuid\:%s,\ name\:%s] = NFS主存储[uuid:{0}, name:{1}]无法找到任何可用的物理机以创建数据云盘[uuid:{2}, name:{3}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:1317
# args: self.getUuid(),self.getName()
the\ NFS\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ hosts\ in\ attached\ clusters\ to\ perform\ the\ operation = NFS主存储[uuid:{0}, name:{1}]不能找到物理机挂载到集群，执行此操作

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorage.java:1284
# args: self.getUuid(),self.getName()
the\ NFS\ primary\ storage[uuid\:%s,\ name\:%s]\ has\ not\ attached\ to\ any\ clusters,\ or\ no\ hosts\ in\ the\ attached\ clusters\ are\ connected = NFS主存储[uuid:{0}, name:{1}] 没有挂载到任何一个集群，或者挂载到集群的物理机均无法连接

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageFactory.java:112
# args: psUuid,vmUuid,volumeUuid
the\ NFS\ primary\ storage[uuid\:%s]\ is\ not\ attached\ to\ any\ clusters,\ and\ cannot\ expunge\ the\ root\ volume[uuid\:%s]\ of\ the\ VM[uuid\:%s] = NFS主存储[uuid:{0}]没有挂载到任何集群，无法彻底删除VM[uuid:{2}]的根云盘[uuid:{1}]

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageFactory.java:278
# args: pri.getUuid()
cannot\ find\ a\ Connected\ host\ to\ execute\ command\ for\ nfs\ primary\ storage[uuid\:%s] = 对nfs主存储[uuid:{0}]来说不能发现一个可连接的物理机执行命令

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageFactory.java:269
# args: pri.getUuid()
cannot\ find\ a\ connected\ host\ in\ cluster\ which\ ps\ [uuid\:\ %s]\ attached = 

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageFactory.java:297
# args: pri.getUuid()
cannot\ find\ a\ host\ which\ has\ Connected\ host-NFS\ connection\ to\ execute\ command\ for\ nfs\ primary\ storage[uuid\:%s] = 找不到一个和NFS主存储[uuid:{0}]处于已连接状态的物理机为其执行命令

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:550
# args: msg.getVolume().getUuid()
cannot\ get\ root\ image\ of\ volume[uuid\:%s],\ may\ be\ it\ create\ from\ iso = 

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:228
# args: inv.getUuid(),inv.getName(),clusterUuid,versionInCluster,otherVersion,QCOW3_QEMU_IMG_VERSION,QCOW3_QEMU_IMG_VERSION
unable\ to\ attach\ a\ primary\ storage[uuid\:%s,\ name\:%s]\ to\ cluster[uuid\:%s].\ Kvm\ host\ in\ the\ cluster\ has\ qemu-img\ with\ version[%s];\ but\ the\ primary\ storage\ has\ attached\ to\ another\ cluster\ that\ has\ kvm\ host\ which\ has\ qemu-img\ with\ version[%s].\ qemu-img\ version\ greater\ than\ %s\ is\ incompatible\ with\ versions\ less\ than\ %s,\ this\ will\ causes\ volume\ snapshot\ operation\ to\ fail.\ Please\ avoid\ attaching\ a\ primary\ storage\ to\ clusters\ that\ have\ different\ Linux\ distributions,\ in\ order\ to\ prevent\ qemu-img\ version\ mismatch = 不能挂载主存储[uuid:{0}, name:{1}]到集群[uuid:{2}].集群中的物理机存在[{3}]版本qemu-img；但是主存储已经挂载到另一个物理机拥有[{4}]版本qemu-img的集群。版本大于{5}的qemu-img不兼容版本小于{6}，这将会造成云盘快照操作失败。为了防止qemu-img版本不兼容，请避免挂载主存储到物理机装有不同linux版本的集群

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:345
# args: inv.getUuid()
no\ host\ in\ is\ Connected\ or\ primary\ storage[uuid\:%s]\ attach\ no\ cluster = 没有物理机处于Connected状态，或主存储[uuid:{0}]没有挂载到任何集群

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:384
# args: psInv.getUuid(),huuid,reply.isSuccess() ? rsp.getError() : reply.getError()
failed\ to\ ping\ nfs\ primary\ storage[uuid\:%s]\ from\ host[uuid\:%s],because\ %s.\ disconnect\ this\ host-ps\ connection = 从物理机[uuid:{1}]Ping NFS主存储[uuid:{0}]失败，原因: {2}。断开该 物理机-主存储 连接

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:576
# args: msg.getHostUuid()
The\ chosen\ host[uuid\:%s]\ to\ perform\ storage\ migration\ is\ lost = 准备存储迁移的物理机[uuid:{0}]失联了

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:817
# args: volume.getUuid(),volume.getName(),host.getUuid(),host.getManagementIp(),rsp.getError()
unable\ to\ create\ empty\ volume[uuid\:%s,\ \ name\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ because\ %s = 不能在物理机[uuid:{2}, ip:{3}]上创建空云盘[uuid:{0},  name:{1}]，因为{4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:921
# args: installPath,pinv.getUuid(),rsp.getError()
failed\ to\ delete\ bits[%s]\ on\ nfs\ primary\ storage[uuid\:%s],\ %s,\ will\ clean\ up\ installPath,\ pinv.getUuid(),\ rsp.getError() = 

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:965
# args: vol.getUuid(),sinv.getUuid(),host.getUuid(),host.getManagementIp(),rsp.getError()
failed\ to\ revert\ volume[uuid\:%s]\ to\ snapshot[uuid\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ %s = 回滚在物理机[uuid:{2}, ip:{3}]上的云盘[uuid:{0}]到快照[uuid:{1}]的状态失败，{4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryStorageKVMBackend.java:1002
# args: vol.getUuid(),vol.getRootImageUuid(),host.getUuid(),host.getManagementIp(),rsp.getError()
failed\ to\ revert\ volume[uuid\:%s]\ to\ image[uuid\:%s]\ on\ kvm\ host[uuid\:%s,\ ip\:%s],\ %s = 回滚在物理机[uuid:{2}, ip:{3}]上的云盘[uuid:{0}]到镜像[uuid:{1}]，{4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryToSftpBackupKVMBackend.java:158
# args: backupStorageInstallPath,greply.getHostname(),pinv.getUuid(),primaryStorageInstallPath,rsp.getError()
failed\ to\ download[%s]\ from\ SftpBackupStorage[hostname\:%s]\ to\ nfs\ primary\ storage[uuid\:%s,\ path\:%s],\ %s = 从Sftp镜像服务器[hostname:{1}] 下载[{0}]到nfs主存储[uuid:{2}, path:{3}]失败，{4}

# at: src/main/java/org/zstack/storage/primary/nfs/NfsPrimaryToSftpBackupKVMBackend.java:214
# args: pinv.getUuid(),primaryStorageInstallPath,hostname,backupStorageInstallPath,rsp.getError()
failed\ to\ upload\ bits\ from\ nfs\ primary\ storage[uuid\:%s,\ path\:%s]\ to\ SFTP\ backup\ storage[hostname\:%s,\ path\:\ %s],\ %s = 从nfs主存储[uuid:{0}, path:{1}]上传数据到STFP镜像服务器[hostname:{2}, path: {3}]失败，{4}

# at: src/main/java/org/zstack/storage/primary/sharedblock/KvmAgentCommandDispatcher.java:75
# args: this.primaryStorageUuid
cannot\ find\ any\ connected\ host\ to\ perform\ the\ operation,\ it\ seems\ all\ KVM\ hosts\ in\ the\ clusters\ attached\ with\ the\ shared\ mount\ point\ storage[uuid\:%s]\ are\ disconnected = 找不到任何Connected的物理机去执行操作，看起来加载到shared mount point存储的集群上所有物理机都处于Disconnected状态

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockAgentDeployer.java:104
# args: 
chrony\ server\ not\ configured! = 

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockApiInterceptor.java:77
# args: sharedBlockVO.getSharedBlockGroupUuid(),scsiLunVO.getWwid()
primary\ storage[uuid\:\ %s]\ has\ attached\ the\ scsi\ lun[wwid\:\ %s] = 

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockApiInterceptor.java:100
# args: msg.getVmInstanceUuid()
the\ vm[uuid\:\ %s]\ does\ not\ has\ additional\ qmp\ socket,\ it\ may\ because\ of\ the\ vm\ start\ without\ the\ global\ config[vm.additionalQmp]\ enabled,\ please\ make\ sure\ it\ enabled\ and\ reboot\ vm\ in\ zstack = 

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockApiInterceptor.java:125
# args: 
must\ specify\ at\ least\ one\ disk\ when\ add\ shared\ block\ group\ primary\ storage = 添加共享块存储时必须指定至少一个硬盘

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockApiInterceptor.java:137
# args: vo.getUuid(),vo.getDiskUuid(),vo.getDescription(),vo.getSharedBlockGroupUuid()
shared\ block[uuid\:%s,\ diskUuid\:%s,\ description\:%s]\ already\ added\ to\ shared\ block\ group[uuid\:%s]in\ new\ shared\ block\ group = 共享块[uuid:{0}, diskUuid:{1}, 描述:{2}]，已经添加到共享块组[uuid:{3}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockApiInterceptor.java:160
# args: msg.getUuid()
shared\ volume[uuid\:\ %s]\ on\ shared\ block\ group\ primary\ storage\ can\ not\ resize = SharedBlock主存储上的共享云盘[uuid: {1}]暂时不支持扩容

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockApiInterceptor.java:229
# args: volumeUuid,notStoppedVmUuids
shared\ volume[uuid\:\ %s]\ on\ shared\ block\ group\ primary\ storage\ has\ attached\ to\ not\ stopped\ vm\ instances[uuids\:\ %s] = SharedBlock存储上的共享云盘[uuid: {0}]加载到了不是停止状态的虚拟机[uuid: {1}]，请先从虚拟机卸载或将虚拟机停止

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockGroupPrimaryStorageBase.java:296
# args: self.getUuid(),self.getName()
the\ shared\ mount\ point\ primary\ storage[uuid\:%s,\ name\:%s]\ cannot\ find\ any\ available\ host\ in\ attached\ clusters\ for\ instantiating\ the\ volume = 共享挂载点主存储[uuid:{0}, name:{1}]在挂载的集群中找不到任何可用的物理机来实例化云盘

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockGroupPrimaryStorageBase.java:515
# args: getSelfInventory().getUuid()
can\ not\ found\ any\ cluster\ attached\ on\ shared\ block\ group\ primary\ storage[uuid\:\ %S] = 找不到任何挂载了共享块主存储[uuid: %S]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockGroupPrimaryStorageBase.java:868
# args: self.getUuid(),self.getName()
the\ shared\ block\ group\ primary\ storage[uuid\:%s,\ name\:%s]\ has\ not\ attached\ to\ any\ clusters,\ or\ no\ hosts\ in\ the\ attached\ clusters\ are\ connected = SharedBlock主存储[uuid:{0}, name:{1}] 没有挂载到任何一个集群，或者挂载到集群的物理机均无法连接

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockGroupPrimaryStorageBase.java:1038
# args: 
empty\ migrateVolumeStructs\ in\ migrateVolumesBetweenSharedBlockGroupPrimaryStorageMsg! = 

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockGroupPrimaryStorageBase.java:1044
# args: 
no\ volume\ in\ migrateVolumeStructs\ in\ migrateVolumesBetweenSharedBlockGroupPrimaryStorageMsg! = 

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockGroupPrimaryStorageFactory.java:104
# args: newValue
the\ value[%s]\ is\ not\ power\ of\ 2 = 输入值[{0}]不是2的幂次

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockGroupPrimaryStorageFactory.java:383
# args: pri.getUuid()
cannot\ find\ an\ available\ host\ to\ execute\ command\ for\ shared\ block\ group\ primary\ storage[uuid\:%s] = 找不到加载了共享块存储的[uuid:{0}]可用的物理机

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockGroupPrimaryStorageFactory.java:405
# args: pri.getUuid()
cannot\ find\ a\ host\ which\ has\ connected\ shared\ block\ to\ execute\ command\ for\ shared\ block\ group\ primary\ storage[uuid\:%s] = 找不到处于连接状态的加载了共享块存储[uuid:{0}]物理机执行命令

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:1059
# args: img.getUuid(),img.getName(),self.getZoneUuid()
the\ image[uuid\:%s,\ name\:\ %s]\ is\ not\ available\ to\ download\ on\ any\ backup\ storage\:\n1.\ check\ if\ image\ is\ in\ status\ of\ Deleted\n2.\ check\ if\ the\ backup\ storage\ on\ which\ the\ image\ is\ shown\ as\ Ready\ is\ attached\ to\ the\ zone[uuid\:%s] = 不能从镜像服务器中下载镜像[uuid:%s, name: %s]\n1.检查镜像是否处于被删除状态\n2.检查镜像处于就绪状态的镜像服务器是否挂载到区域[uuid:{2}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:794
# args: vol.getVmInstanceUuid(),state
vm[uuid\:%s]\ is\ not\ Running,\ Paused\ or\ Stopped,\ current\ state[%s] = 云主机[uuid:{0}]不是运行中、已暂停或者已停止状态，现在的状态是[{1}]

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:942
# args: volume.getUuid(),volume.getVmInstanceUuid(),state
the\ volume[uuid;%s]\ is\ attached\ to\ a\ VM[uuid\:%s]\ which\ is\ in\ state\ of\ %s,\ cannot\ do\ the\ snapshot\ merge = 云盘[uuid;{0}] 挂载到处于{2}状态的虚拟机，不能合并快照

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:1030
# args: volume.getUuid()
not\ support\ online\ merge\ snapshot\ for\ shareable\ volume[uuid\:\ %s]\ on\ sharedblock = 不支持对共享块存储上的共享云盘[uuid: {1}]做在线合并快照，请关机或卸载后操作

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:1075
# args: img.getUuid(),img.getName()
the\ image[uuid\:\ %s,\ name\:%s]\ is\ not\ found\ on\ any\ backup\ storage = 

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:1540
# args: ret.firstAccessHosts.stream().map( h -> h.hostUuid).collect(Collectors.toList())
hosts[uuid\:%s]\ have\ the\ disk\ uuid\ of\ shared\ block,\ but\ actually\ different\ storage. = 物理机[uuid:{0}]已经加载了相同uuid的共享块，但实际上是不同的存储

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:1848
# args: 
not\ support\ convert\ thin\ volume\ to\ thick\ volume\ yet = 

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:2341
# args: self.getUuid()
cannot\ find\ any\ connected\ host\ to\ perform\ the\ operation,\ it\ seems\ all\ KVM\ hosts\ in\ the\ clusters\ attached\ with\ the\ shared\ block\ group\ storage[uuid\:%s]\ are\ disconnected = 找不到任何可以执行操作的已连接状态的物理机，所有的共享存储[uuid:{0}]挂载的集群下的物理机都处于已失联状态

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:2313
# args: 
can\ not\ find\ volume\ need\ to\ operate\ shared\ block\ group\ primary\ storage = 找不到能进行共享块存储操作的云盘

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:2321
# args: volumeInventory.getUuid(),self.getUuid()
KVM\ host\ which\ volume[uuid%s]\ attached\ disconnected\ with\ the\ shared\ block\ group\ storage[uuid\:%s] = 云盘[uuid:{0}]所处的挂载了共享块存储[uuid:{1}]物理机均处于已失联状态

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:2330
# args: psUuid
can\ not\ find\ qualified\ kvm\ host\ for\ shared\ block\ group\ primary\ storage[uuid\:\ %s] = 无法找到满足条件的物理机来对共享块存储[uuid: {0}]进行操作

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:2747
# args: spec.getVmInventory().getUuid(),String.join(",", psUuids)
VM[uuid\:%s]\ has\ multiple\ ISOs\ from\ different\ primary\ storage\:\ %s = VM[uuid:{0}]挂载了来自不同主存储:{1}的ISO

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:2922
# args: volume.getUuid()
QCow2\ shared\ volume[uuid\:%s]\ is\ not\ supported = 

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:3580
# args: volumeVO.getUuid(),volumeVO.getPrimaryStorageUuid()
can\ not\ find\ any\ available\ host\ to\ resize\ volume[uuid\:\ %s]\ on\ shared\ block\ group\ primary\ storage[uuid\:\ %s] = 无法找到合适的物理机来对共享块存储[uuid: {1}]上的云盘[uuid: {0}]执行扩容

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:3586
# args: struct.getVmHostUuid(),volumeVO.getUuid(),volumeVO.getPrimaryStorageUuid()
the\ host[uuid\:\ %s]\ running\ on\ is\ not\ available\ to\ resize\ volume[uuid\:\ %s]\ on\ shared\ block\ group\ primary\ storage[uuid\:\ %s] = 共享块存储[uuid: {2}]上的云盘[uuid : {1}]运行在物理机[uuid : {0}]上，但状态无法执行扩容操作

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:3704
# args: msg.getVolumeUuid(),msg.getTargetPrimaryStorageUuid()
can\ not\ find\ any\ available\ host\ to\ take\ snapshot\ for\ volume[uuid\:\ %s]\ on\ shared\ block\ group\ primary\ storage[uuid\:\ %s] = 无法找到合适的物理机来对共享块存储[uuid : {1}]上的云盘[uuid: {0}]执行快照操作

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:3762
# args: msg.getPrimaryStorageUuid(),msg.getTargetPrimaryStorageUuid()
can\ not\ find\ hosts\ both\ connect\ to\ primary\ storage[uuid\:\ %s]\ and\ primary\ storage[uuid\:\ %s] = 无法找到同时连接主存储[uuid: {0}]和主存储[uuid: {1}]的物理机

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:3717
# args: 
only\ support\ full = 共享块存储目前只支持全量快照

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:3745
# args: msg.getMigrateVolumeStructs().get(0).volumeUuid,msg.getPrimaryStorageUuid(),msg.getTargetPrimaryStorageUuid()
can\ not\ find\ any\ available\ host\ to\ migrate\ volume[uuid\:\ %s]\ between\ shared\ block\ group\ primary\ storage[uuid\:\ %s]\ and\ [uuid\:\ %s] = 无法找到合适的物理机来将云盘[uuid: {0}]在共享块存储[uuid : {1}]和共享块存储[uuid: {2}]之间迁移

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:3754
# args: msg.getMigrateVolumeStructs().get(0).volumeUuid,msg.getTargetPrimaryStorageUuid(),msg.getTargetPrimaryStorageUuid()
can\ not\ find\ any\ available\ host\ to\ migrate\ for\ volume[uuid\:\ %s]\ on\ shared\ block\ group\ primary\ storage[uuid\:\ %s]\ and\ [uuid\:\ %s] = 无法找到合适的物理机来将云盘[uuid: {0}]在共享块存储[uuid : {1}]和共享块存储[uuid: {2}]之间迁移

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:3806
# args: msg.getPrimaryStorageUuid()
cannot\ find\ any\ connected\ host\ to\ perform\ the\ operation,\ it\ seems\ all\ KVM\ hosts\ attached\ with\ the\ shared\ block\ group\ storage[uuid\:%s]\ are\ disconnected = 无法找到任何已连接的物理机来执行操作，所有连接共享块存储[uuid: {1}]的物理机均处于失联状态

# at: src/main/java/org/zstack/storage/primary/sharedblock/SharedBlockKvmBackend.java:4058
# args: vmVolumesStruct.vmInstanceVO.getUuid()
get\ null\ install\ path\ in\ snapshot\ for\ vm\ %s = 

# at: src/main/java/org/zstack/storage/primary/sharedblock/migration/SblkToSblkMigrateVolumeFlow.java:113
# args: reply1.getTrashId(),dstPsUuid,dstVolumeFolderPath,reply1.getResourceUuid()
found\ trashId(%s)\ in\ PrimaryStorage\ [%s]\ for\ the\ migrate\ installPath[%s].\ Please\ clean\ it\ first\ by\ 'APICleanUpTrashOnPrimaryStorageMsg'\ if\ you\ insist\ to\ migrate\ the\ volume[%s] = 在主存储[{1}]的回收数据({0})中己存在要迁移的目标路径[{2}]，如果要继续迁移云盘[{3}]，请先调用'APICleanUpTrashOnPrimaryStorageMsg'来手动清理该回收数据

# at: src/main/java/org/zstack/storage/primary/sharedblock/migration/SblkToSblkMigrateVolumeFlow.java:307
# args: volumeUuid,volumeVO.getActualSize(),dstPsInv.getAvailablePhysicalCapacity()
there\ are\ not\ enough\ capacity\ for\ volume[uuid\:\ %s]\ storage\ migration,\ required\ capacity\:\ %s,\ current\ available\ physical\ capacity\:\ %s = 对云盘[uuid: {0}]存储迁移需要目标主存储具有至少{1}的空余容量，但现在只有{2}的空余容量

# at: src/main/java/org/zstack/storage/primary/sharedblock/migration/SblkToSblkMigrateVolumeFlow.java:221
# args: imageUuid,zoneUuid,zoneUuid
cannot\ find\ the\ image[uuid\:%s]\ in\ any\ connected\ backup\ storage\ attached\ to\ the\ zone[uuid\:%s].\ check\ below\:\n1.\ whether\ the\ backup\ storage\ is\ attached\ to\ the\ zone[uuid\:%s]\n2.\ whether\ the\ backup\ storage\ is\ in\ connected\ status;\ try\ to\ reconnect\ it\ if\ not = 在所有的已连接区域[uuid:{1}]的镜像服务器未找到镜像[uuid:{0}]。建议进行如下检查: \n1.镜像服务器是否连接到区域[uuid:{2}]\n2.镜像服务器是否是已连接状态，如果不是尝试重新连接

# at: src/main/java/org/zstack/storage/primary/sharedblock/migration/SblkToSblkMigrateVolumeFlow.java:244
# args: image.getUuid(),volumeUuid,image.getActualSize(),dstPsInv.getAvailablePhysicalCapacity()
there\ are\ not\ enough\ capacity\ for\ image[uuid\:\ %s]\ download\ while\ volume[uuid\:\ %s]\ storage\ migration,\ required\ capacity\:\ %s,\ current\ available\ physical\ capacity\:\ %s = 对云盘[uuid: {0}]存储迁移需要目标主存储具有至少{1}的空余容量来下载镜像cache，但现在只有{2}的空余容量

# at: src/main/java/org/zstack/storage/primary/sharedblock/migration/SblkToSblkRollbackMigrateVolumeFlow.java:70
# args: srcPsUuid
data\ on\ source\ ps[uuid\:\ %s]\ has\ been\ discarded,\ not\ support\ rollback = 源主存储[uuid:{0}]上的数据已经被清理，无法回滚

# at: src/main/java/org/zstack/storage/primary/smp/KvmBackend.java:1525
# args: ret.firstAccessHostUuids
hosts[uuid\:%s]\ have\ the\ same\ mount\ path,\ but\ actually\ mount\ different\ storage. = 物理机[uuid:{0}]有相同挂载路径，但是实际上挂载在不同的存储上

# at: src/main/java/org/zstack/storage/primary/smp/KvmBackend.java:1689
# args: msg.getHostUuid(),msg.getPrimaryStorageUuid()
host[uuid\:%s]\ might\ mount\ storage\ which\ is\ different\ from\ SMP[uuid\:%s],\ please\ check\ it = 

# at: src/main/java/org/zstack/storage/primary/smp/SMPPrimaryStorageBase.java:486
# args: 
not\ supported\ operation = 不支持的操作

# at: src/main/java/org/zstack/storage/primary/smp/SMPPrimaryStorageFactory.java:106
# args: psUuid,vmUuid,volumeUuid
the\ SMP\ primary\ storage[uuid\:%s]\ is\ not\ attached\ to\ any\ clusters,\ and\ cannot\ expunge\ the\ root\ volume[uuid\:%s]\ of\ the\ VM[uuid\:%s] = SMP主存储[uuid:{0}]没有挂载到任何集群，无法彻底删除云主机[uuid:{2}]的根云盘[uuid:{1}]

# at: src/main/java/org/zstack/storage/primary/smp/SMPPrimaryStorageFactory.java:300
# args: pri.getUuid()
cannot\ find\ a\ Connected\ host\ to\ execute\ command\ for\ smp\ primary\ storage[uuid\:%s] = 找不到一个已连接状态的物理机为SMP主存储[uuid:{0}]执行命令

# at: src/main/java/org/zstack/storage/primary/smp/SMPPrimaryStorageFactory.java:320
# args: pri.getUuid()
cannot\ find\ a\ host\ which\ has\ Connected\ host-SMP\ connection\ to\ execute\ command\ for\ smp\ primary\ storage[uuid\:%s] = 找不到一个和SMP主存储[uuid:{0}]处于已连接状态的物理机为其执行命令

# at: src/main/java/org/zstack/storage/primary/smp/SharedMountPointApiInterceptor.java:25
# args: 
\ the\ url\ contains\ an\ invalid\ folder[/dev\ or\ /proc\ or\ /sys] = URL包含了一个无效的目录[/dev or /proc or /sys]

# at: src/main/java/org/zstack/storage/primary/zses/ZsesKvmBackend.java:530
# args: volume.getUuid(),volume.getName(),hostUuid
unable\ to\ create\ an\ empty\ volume[uuid\:%s,\ name\:%s]\ on\ the\ kvm\ host[uuid\:%s] = 不能在物理机[uuid:{2}]上创建空云盘[uuid:{0}, name:{1}]

# at: src/main/java/org/zstack/storage/primary/zses/ZsesKvmFactory.java:94
# args: context.getInventory().getUuid(),priUuid,reply.getError()
KVM\ host[uuid\:\ %s]\ fails\ to\ be\ added\ to\ zses\ primary\ storage[uuid\:\ %s],\ %s = KVM物理机[uuid: {0}]添加到zses主存储失败[uuid: {1}]，{2}

# at: src/main/java/org/zstack/storage/primary/zses/ZsesPrimaryStorageBase.java:245
# args: msg.getImage().getUuid(),self.getUuid(),JSONObjectUtil.toJsonString(ret.errorCodes)
failed\ to\ download\ image[uuid\:%s]\ to\ all\ hosts\ in\ the\ local\ storage[uuid\:%s].\ %s = 在所有属于本地存储[uuid:{1}]的物理机上，均无法下载镜像[uuid:{0}]。{2}

# at: src/main/java/org/zstack/storage/primary/zses/ZsesPrimaryStorageBase.java:1185
# args: hostUuid,self.getUuid(),ref.getAvailableCapacity(),size
host[uuid\:\ %s]\ of\ local\ primary\ storage[uuid\:\ %s]\ doesn't\ have\ enough\ capacity[current\:\ %s\ bytes,\ needed\:\ %s] = 主存储[uuid:{1}]上的物理机[uuid:{0}]没有足够的容量[现在: {2} bytes, 需要: {3}]

# at: src/main/java/org/zstack/storage/primary/zses/ZsesPrimaryStorageBase.java:87
# args: volumeUuid
cannot\ find\ an\ available\ host\ for\ volume[uuid\:%s] = 找不到一个可用的物理机操作云盘[uuid:{0}]

# at: src/main/java/org/zstack/storage/primary/zses/ZsesPrimaryStorageBase.java:502
# args: 
destination\ host\ is\ null = 目标物理机为空

# at: src/main/java/org/zstack/storage/primary/zses/ZsesPrimaryStorageBase.java:624
# args: msg.getVolumeUuid(),self.getUuid()
unable\ to\ create\ the\ data\ volume[uuid\:\ %s]\ on\ a\ zses\ primary\ storage[uuid\:%s],\ because\ the\ hostUuid\ is\ not\ specified. = 在zses主存储[uuid:{1}]不能创建数据云盘，因为物理机uuid未指定

# at: src/main/java/org/zstack/storage/primary/zses/ZsesPrimaryStorageFactory.java:159
# args: LocalStorageSystemTags.DEST_HOST_FOR_CREATING_DATA_VOLUME.getTagFormat()
To\ create\ data\ volume\ on\ the\ zses\ primary\ storage,\ you\ must\ specify\ the\ host\ that\ the\ data\ volume\ is\ going\ to\ be\ created\ using\ the\ system\ tag\ [%s] = 为了在zses主存储上创建数据云盘，你必须指定使用系统标签创建数据云盘的物理机

# at: src/main/java/org/zstack/storage/primary/zses/ZsesPrimaryStorageFactory.java:169
# args: hostUuid,msg.getPrimaryStorageUuid()
the\ host[uuid\:%s]\ doesn't\ belong\ to\ the\ zses\ primary\ storage[uuid\:%s] = 物理机[uuid:{0}]不属于zses主存储[uuid:{1}]

# at: src/main/java/org/zstack/storage/primary/zses/ZsesPrimarytoImageStoreKVMBackend.java:516
# args: installPath,inv.getUuid(),rsp.getError()
failed\ to\ check\ existence\ of\ %s\ on\ nfs\ primary\ storage[uuid\:%s],\ %s = 检查nfs主存储中是否存在{0}失败

# at: src/main/java/org/zstack/storage/primary/zses/ZsesPrimarytoImageStoreKVMBackend.java:483
# args: volume.getUuid(),image.getImageUuid(),rsp.getError()
fails\ to\ create\ root\ volume[uuid\:%s]\ from\ cached\ image[path\:%s]\ because\ %s = 从镜像[path:{1}]创建根云盘失败，因为{2}

# at: src/main/java/org/zstack/storage/primary/zses/ZsesPrimarytoImageStoreKVMBackend.java:394
# args: 
System\ can't\ find\ imagestore\ backup\ Storage.\ Please\ do\ not\ set\ imagestore\ backup\ Storage\ server\ IP\ to\ localhost(127.*.*.*), = 系统找不到镜像仓库镜像服务器。请不要设置镜像服务器IP为localhost(127.*.*.*)

# at: src/main/java/org/zstack/storage/primary/zses/ZsesPrimarytoImageStoreKVMBackend.java:397
# args: operationSuggestion,greply.getHostname(),backupStorageInstallPath,pinv.getUuid(),primaryStorageInstallPath,rsp.getError()
%s\ failed\ to\ download\ bits\ from\ the\ imagestore\ backup\ storage[hostname\:%s,\ path\:\ %s]\ to\ the\ local\ primary\ storage[uuid\:%s,\ path\:\ %s],\ %s = {0}从镜像仓库镜像服务器[hostname:{1}, path: {2}]到本地主存储[uuid:{3}, path: {4}]下载失败，{5}

# at: src/main/java/org/zstack/storage/primary/zses/ZsesPrimarytoImageStoreKVMBackend.java:449
# args: pinv.getUuid(),primaryStorageInstallPath,r.getHostname(),rsp.getError()
failed\ to\ upload\ bits\ from\ the\ Zses\ storage[uuid\:%s,\ path\:%s]\ to\ image\ store\ [hostname\:%s],\ %s = 无法从Zses主存储[uuid:{0}, path:{1}]上传数据到镜像仓库[主机名:{2}]，因为{3}

# at: src/main/java/org/zstack/storage/snapshot/RevertVolumeSnapshotLongJob.java:60
# args: 
not\ supported = 不支持

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotApiInterceptor.java:124
# args: msg.getVolumeUuid(),status
volume[uuid\:%s]\ is\ not\ in\ status\ Ready,\ current\ is\ %s,\ can't\ create\ snapshot = 云盘[uuid:{0}]未出于就绪状态，当前是{1}，不能创建快照

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotApiInterceptor.java:151
# args: msg.getUuid(),state
volume\ snapshot[uuid\:%s]\ is\ in\ state\ %s,\ cannot\ revert\ volume\ to\ it = 云盘快照[uuid:{0}]出于状态{1}，不能恢复云盘到该快照状态

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotApiInterceptor.java:156
# args: msg.getUuid()
original\ volume\ for\ snapshot[uuid\:%s]\ has\ been\ deleted,\ cannot\ revert\ volume\ to\ it = 快照[uuid:{0}]的原版云盘已经被删除，不能恢复云盘到该快照

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotApiInterceptor.java:174
# args: msg.getVolumeUuid(),snapshotVO.getVolumeUuid()
not\ support\ delete\ snapshots\ on\ different\ volumes[uuid\:\ %s,\ %s] = 

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotApiInterceptor.java:178
# args: msg.getUuids()
can\ not\ find\ volume\ uuid\ for\ snapshosts[uuid\:\ %s] = 

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotManagerImpl.java:424
# args: maxIncrementalSnapshotNum,vo.getVolumeUuid()
Unsupported\ maximum\ snapshot\ number\ (%d)\ for\ volume\ [uuid\:%s] = 

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotManagerImpl.java:521
# args: vol.getUuid(),reply.getError()
cannot\ ask\ primary\ storage[uuid\:%s]\ for\ volume\ snapshot\ capability,\ see\ detail\ [%s] = 

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotManagerImpl.java:717
# args: primaryStorageUuid,vol.getUuid()
primary\ storage[uuid\:%s]\ doesn't\ support\ volume\ snapshot;\ cannot\ create\ snapshot\ for\ volume[uuid\:%s] = 主存储[uuid:{0}]不能支持云盘快照，不能为云盘[uuid:{1}]创建快照

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotManagerImpl.java:683
# args: vol.getPrimaryStorageUuid()
cannot\ find\ type\ for\ primaryStorage\ [%s] = 

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotManagerImpl.java:777
# args: uuid
cannot\ find\ snapshot\:\ %s = 

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotTreeBase.java:152
# args: currentRoot.getUuid(),currentRoot.getName()
cannot\ find\ volume\ snapshot[uuid\:%s,\ name\:%s],\ it\ may\ have\ been\ deleted\ by\ previous\ operation = 不能创建云盘快照[uuid:{0}, name:{1}]，该快照可能已经被以前的操作删除

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotTreeBase.java:756
# args: failSnapshot.getUuid(),failSnapshot.getName(),evt
failed\ to\ change\ status\ of\ volume\ snapshot[uuid\:%s,\ name\:%s]\ by\ status\ event[%s] = 通过状态事件[{2}]改变云盘快照[uuid:{0}, name:{1}]失败

# at: src/main/java/org/zstack/storage/snapshot/VolumeSnapshotTreeBase.java:1434
# args: rmsg.getVolume().getUuid(),rmsg.getSnapshot().getUuid(),rmsg.getVolume().getVmInstanceUuid(),state
unable\ to\ reset\ volume[uuid\:%s]\ to\ snapshot[uuid\:%s],\ the\ vm[uuid\:%s]\ volume\ attached\ to\ is\ not\ in\ Stopped\ state,\ current\ state\ is\ %s = 不能重置云盘[uuid:{0}]到快照[uuid:{1}]状态，云盘的虚拟机[uuid:{2}]未处于停止状态，当前状态是{3}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:216
# args: 
Can't\ attach\ volume\ to\ VM,\ no\ qualified\ cluster = 不能加载云盘到虚拟机上，没有可用集群

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:97
# args: msg.getVolumeUuid()
the\ volume[uuid\:%s]\ is\ not\ in\ status\ of\ deleted.\ This\ is\ operation\ is\ to\ recover\ a\ deleted\ data\ volume = 云盘[uuid:{0}]未处于删除状态。此操作将覆盖一个被删除的数据云盘

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:243
# args: vol.getUuid()
the\ volume[uuid\:%s]\ is\ in\ status\ of\ deleted,\ cannot\ do\ the\ operation = 云盘[uuid:{0}]已经被删除，不能执行此操作

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:115
# args: msg.getImageUuid(),ImageMediaType.DataVolumeTemplate,type
image[uuid\:%s]\ is\ not\ %s,\ it's\ %s = 镜像[uuid:{0}]不是{1}，而是{2}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:119
# args: img.getUuid(),img.getState()
image[uuid\:%s]\ is\ not\ Enabled,\ it's\ %s = 镜像不能启用，此镜像是{1}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:123
# args: img.getUuid(),img.getStatus()
image[uuid\:%s]\ is\ not\ Ready,\ it's\ %s = 镜像未准备就绪，此镜像是{1}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:129
# args: 
DataVolumeFromVolumeTemplate\ not\ support\ Shareable = 

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:144
# args: msg.getVolumeUuid()
volume[uuid\:%s]\ is\ Root\ volume,\ can\ not\ be\ attach\ to\ vm = 云盘[uuid:{0}]是一个根云盘，不能被手动挂载到其他云主机

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:151
# args: msg.getVolumeUuid(),state,VolumeState.Enabled
volume[uuid\:%s]\ is\ in\ state[%s],\ data\ volume\ can\ only\ be\ attached\ when\ state\ is\ %s = 云盘[uuid:{0}]处于[{1}]状态，数据云盘只能在处于{2}状态的时候挂载

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:156
# args: msg.getVolumeUuid(),status,VolumeStatus.Ready,VolumeStatus.NotInstantiated
volume[uuid\:%s]\ is\ in\ status[%s],\ data\ volume\ can\ only\ be\ attached\ when\ status\ is\ %s\ or\ %S = 云盘[uuid:{0}]处于[{1}]，数据云盘只能在处于{2}或%S状态的时候挂载

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:163
# args: msg.getVolumeUuid()
data\ volume[uuid\:%s]\ is\ not\ attached\ to\ any\ vm,\ can't\ detach = 数据云盘没有被挂载到任何云主机上，不能卸载

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:167
# args: msg.getVolumeUuid()
to\ detach\ shareable\ data\ volume[uuid\:%s],\ vm\ uuid\ is\ needed. = 卸载共享数据云盘[uuid:{0}]需要虚拟机的uuid

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:172
# args: vol.getUuid(),vol.getName()
the\ volume[uuid\:%s,\ name\:%s]\ is\ Root\ Volume,\ can't\ detach\ it = 不能卸载根云盘[uuid:{0}, name:{1}]

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:229
# args: msg.getVmInstanceUuid(),msg.getVolumeUuid()
the\ vm[uuid\:%s]\ doesn't\ support\ to\ online\ attach\ volume[%s]\ on\ the\ basis\ of\ that\ the\ image\ platform\ type\ of\ the\ vm\ is\ other\  = 云主机[uuid:{0}]不支持在线挂载云盘[{1}]。因为镜像平台类型和云主机平台类型不一致

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:234
# args: vol.getUuid(),vol.getName()
the\ volume[uuid\:%s,\ name\:%s]\ is\ Root\ Volume,\ can't\ attach\ it = 不能挂载根云盘[uuid:{0}, name:{1}]

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:239
# args: vol.getUuid()
data\ volume[uuid\:%s]\ is\ Disabled,\ can't\ attach = 数据云盘已被禁用，不能挂载

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:247
# args: vol.getUuid()
data\ volume[uuid\:%s]\ has\ been\ attached\ to\ some\ vm,\ can't\ attach\ again = 数据云盘[uuid:{0}]已经被加载上云主机了，不能再次加载

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:252
# args: VolumeStatus.Ready,VolumeStatus.NotInstantiated,vol.getStatus()
data\ volume\ can\ only\ be\ attached\ when\ status\ is\ [%s,\ %s],\ current\ is\ %s = 数据云盘仅能当处于[{0}, {1}]状态挂载，当前状态是{2}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:260
# args: vol.getUuid(),vol.getFormat(),volHvType,msg.getVmInstanceUuid(),hvType
data\ volume[uuid\:%s]\ has\ format[%s]\ that\ can\ only\ be\ attached\ to\ hypervisor[%s],\ but\ vm[uuid\:%s]\ has\ hypervisor\ type[%s].\ Can't\ attach = 只有[{1}]格式的数据云盘[uuid:{0}]才能被挂载到管理程序[{2}]，但是虚拟机是[{4}]类型的管理程序，数据云盘不能挂载到该虚拟机

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:273
# args: hvType,maxDataVolumeNum,count,msg.getVmInstanceUuid()
hypervisor[%s]\ only\ allows\ max\ %s\ data\ volumes\ to\ be\ attached\ to\ a\ single\ vm;\ there\ have\ been\ %s\ data\ volumes\ attached\ to\ vm[uuid\:%s] = [{0}]管理程序仅允许最大不超过{1}数据云盘挂载到单个虚拟机。{2} data volumes已经挂载到虚拟机[uuid:{3}]

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:285
# args: msg.getUuid()
it's\ not\ allowed\ to\ backup\ root\ volume,\ uuid\:%s = 备份根云盘不被允许，uuid:{0}

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:294
# args: 
unexpected\ disk\ size\ settings = 

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:312
# args: msg.getVolumeUuid()
volume[uuid\:%s]\ is\ Root\ volume,\ can't\ be\ deleted = 不能删除根云盘[uuid:{0}]

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:317
# args: msg.getVolumeUuid()
volume[uuid\:%s]\ is\ already\ in\ status\ of\ deleted = 云盘[uuid:{0}]早已处于被删除状态

# at: src/main/java/org/zstack/storage/volume/VolumeApiInterceptor.java:331
# args: msg.getUuid()
it's\ not\ allowed\ to\ change\ state\ of\ root\ volume,\ uuid\:%s = 不能改变根云盘状态，uuid:{0}

# at: src/main/java/org/zstack/storage/volume/VolumeBase.java:676
# args: self.getUuid(),self.getName()
the\ volume[uuid\:%s,\ name\:%s]\ is\ not\ deleted\ yet,\ can't\ expunge\ it = 云盘[uuid:{0}, name:{1}]仍未被删除，不能清除该云盘

# at: src/main/java/org/zstack/storage/volume/VolumeManagerImpl.java:192
# args: template.getUuid(),template.getName()
the\ image[uuid\:%s,\ name\:%s]\ has\ been\ deleted\ on\ all\ backup\ storage = 镜像[uuid:{0}, name:{1}]已经从所有的镜像服务器中删除

# at: src/main/java/org/zstack/storage/volume/VolumeManagerImpl.java:209
# args: template.getUuid(),msg.getPrimaryStorageUuid()
cannot\ find\ a\ backup\ storage\ on\ which\ the\ image[uuid\:%s]\ is\ that\ satisfies\ all\ conditions\ of\:\ 1.\ has\ state\ Enabled\ 2.\ has\ status\ Connected.\ 3\ has\ attached\ to\ zone\ in\ which\ primary\ storage[uuid\:%s]\ is = 无法找到一个镜像[uuid:%s]所在的镜像服务器符合全部的下列条件: 状态启动[state:Enabled]，已连接[status:Connected]，被挂载到主存储[uuid:{1}]所在的区域中

# at: src/main/java/org/zstack/storage/volume/VolumeManagerImpl.java:689
# args: VolumeFactory.class.getSimpleName()
there\ should\ not\ be\ more\ than\ one\ %s\ implementation. = 不允许超过一种实现

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:77
# args: volumeUuid
volume[uuid\:%s]\ can\ not\ found = 

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:84
# args: volumeUuid,volumeVOS.get(0).getUuid(),volumeVO.getVmInstanceUuid(),volumeVOS.get(0).getVmInstanceUuid()
not\ support\ take\ snapshots\ volume[uuid\:%s,\ uuid\:%s]\ on\ different\ vms[uuid\:%s,\ uuid\:%s] = 

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:91
# args: volumeUuid
volume[uuid\:%s]\ is\ not\ ready = 

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:106
# args: vmInstanceVO.getUuid(),vmInstanceVO.getState()
state\ of\ vm[uuid\:\ %s]\ is\ %s,\ not\ allowed\ to\ take\ snapshots = 

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:142
# args: msg.getUuid()
volume[uuid\:%s]\ is\ not\ data\ volume = 云盘[uuid:{0}]不是数据云盘

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:162
# args: msg.getUuid()
volume[uuid\:%s]\ is\ not\ root\ volume = 云盘[uuid:{0}]不是根云盘

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:174
# args: 
SharedVolume\ cannot\ be\ set\ bandwidth. = 共享云盘不允许设置带宽

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:182
# args: vo.getType(),vo.getUuid()
Cannot\ shrink\ [%s]\ volume[uuid\:%s]'s\ size = 不能缩小云盘[uuid:{1}]的大小

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:189
# args: 
Minimum\ increase\ size\ should\ be\ larger\ than\ 4MB = 最小扩容量需要大于4MB

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:213
# args: 
Expansion\ operation\ not\ allowed\ at\ all\ host\ disable = 扩展操作不被允许在所有不可用的物理机上进行

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:200
# args: 
Expansion\ operation\ not\ allowed\ at\ host\ disable = 扩展操作不被允许在不可用的物理机上进行

# at: src/main/java/org/zstack/storage/volume/VolumeMevocoApiInterceptor.java:239
# args: vo.getUuid(),notStoppedVmUuids
shared\ volume[uuid\:\ %s]\ has\ attached\ to\ not\ stopped\ vm\ instances[uuids\:\ %s] = 

# at: src/main/java/org/zstack/tag/TagApiInterceptor.java:56
# args: msg.getResourceType()
no\ resource\ type[%s]\ found\ in\ tag\ system = 标签系统中不存在[{0}]资源类型

# at: src/main/java/org/zstack/tag/TagApiInterceptor.java:74
# args: msg.getUuid()
tag[uuid\:%s]\ is\ an\ inherent\ system\ tag,\ can\ not\ be\ removed = 固有系统标签[uuid:{0}]禁止移除

# at: src/main/java/org/zstack/tag/TagApiInterceptor.java:100
# args: 
The\ argument\ \:'resourceType'\ doesn't\ match\ uuid = 参数: 资源类型（resourceType）与UUID不匹配

# at: src/main/java/org/zstack/tag/TagManagerImpl.java:207
# args: tag,type,resourceType,resourceUuid
Duplicated\ Tag[tag\:%s,\ type\:%s,\ resourceType\:%s,\ resourceUuid\:%s] = 标签[tag:{0}, type:{1}, resourceType:{2}, resourceUuid:{3}]重复

# at: src/main/java/org/zstack/tag/TagManagerImpl.java:645
# args: tag,resourceType
no\ system\ tag\ matches[%s]\ for\ resourceType[%s] = 没有系统标签[{0}]与资源类型[{1}]匹配

# at: src/main/java/org/zstack/tag/TagManagerImpl.java:818
# args: tag
no\ system\ tag\ matches\ %s = 没有找到匹配{0}的系统标签

# at: src/main/java/org/zstack/tag/TagManagerImpl.java:847
# args: tag
tag[%s]\ is\ only\ for\ admin = 

# at: src/main/java/org/zstack/tag2/Tag2ApiInterceptor.java:84
# args: 
cannot\ update\ simple\ tag\ pattern\ format = 

# at: src/main/java/org/zstack/tag2/Tag2ApiInterceptor.java:82
# args: 
you\ can\ only\ update\ token\ name = 

# at: src/main/java/org/zstack/tag2/Tag2ApiInterceptor.java:94
# args: 
simple\ tag\ pattern\ has\ no\ tokens = 

# at: src/main/java/org/zstack/tag2/Tag2ApiInterceptor.java:123
# args: sub
illegal\ tag\ uuids\ %s,\ tag\ type\ must\ be\ simple, = 

# at: src/main/java/org/zstack/tag2/Tag2ApiInterceptor.java:134
# args: color
Invalid\ color\ specification[%s],\ must\ like\ #FF00FF = 

# at: src/main/java/org/zstack/tag2/Tag2ApiInterceptor.java:140
# args: format
Get\ format[%s],\ format\ must\ like\ that\ name\:\:{tokenName1}\:\:{tokenName2}\ ...\ \:\:{tokenNameN}\ or\ {tokenName1}\:\:{tokenName2}\ ...\ \:\:{tokenNameN}\ Name\ cannot\ contain\ '{}\:' = 

# at: src/main/java/org/zstack/tag2/Tag2ApiInterceptor.java:152
# args: formatTokens
all\ tokens\ %s\ must\ be\ specify = 

# at: src/main/java/org/zstack/tag2/Tag2ApiInterceptor.java:164
# args: invalidUuids,expectAccountUuid
resource[uuids\:%s]\ is\ not\ owned\ by\ account[uuid\:%s] = 

# at: src/main/java/org/zstack/tag2/TagPatternBase.java:183
# args: resourceUuid,attachedCount
resource[uuid\:%s]\ has\ been\ attached\ %d\ tags,\ cannot\ attach\ any\ more = 

# at: src/main/java/org/zstack/ticket/TicketBase.java:256
# args: self.getUuid(),self.getName(),self.getStatus()
ticket[uuid\:%s,\ name\:%s]\ can\ only\ be\ updated\ after\ being\ cancelled,\ current\ status\ is\ %s = 工单[uuid:{0}, name:{1}]当前状态为{2}，不支持更新操作

# at: src/main/java/org/zstack/ticket/TicketBase.java:310
# args: operator.operatorUuid
operation\ denied.\ the\ operator\ needs\ to\ be\ done\ by\ account/virtual\ ID[uuid\:%s] = 操作无效，需要account/virtual ID[uuid:{0}]才能完成操作

# at: src/main/java/org/zstack/ticket/api/TicketApiInterceptor.java:62
# args: msg.getFlowCollectionUuid()
Ticket\ flow\ collection[uuid\:%s]\ is\ invalid,\ contact\ admin\ to\ correct\ it = 当前工单流程[uuid:{0}]失效，请联系admin修复

# at: src/main/java/org/zstack/ticket/api/TicketApiInterceptor.java:67
# args: msg.getFlowCollectionUuid()
Ticket\ flow\ collection[uuid\:%s]\ is\ disable,\ can\ not\ be\ used = 工单流程[uuid:{0}]处于禁用状态，无法被使用

# at: src/main/java/org/zstack/ticket/api/TicketApiInterceptor.java:45
# args: msg.getAccountSystemType()
no\ accountSystemType[%s]\ defined\ in\ system = 未定义的accountSystemType[{0}]类型

# at: src/main/java/org/zstack/ticket/api/TicketApiInterceptor.java:53
# args: 
no\ default\ ticket\ flow\ collection\ found,\ you\ must\ specify\ the\ flowCollectionUuid\ or\ create\ a\ default\ ticket\ flow\ collection\ in\ system = 找不到默认的

# at: src/main/java/org/zstack/ticket/api/TicketApiInterceptor.java:75
# args: req.apiName
invalid\ request.\ no\ API[%s]\ found = 无效的请求。找不到API[{0}]

# at: src/main/java/org/zstack/ticket/api/TicketApiInterceptor.java:83
# args: clz,e.getMessage()
invalid\ request,\ cannot\ create\ API[%s]\ from\ apiBody,\ %s = 无效的请求，无法通过apiBody创建API[{0}]，{1}

# at: src/main/java/org/zstack/ticket/api/TicketApiInterceptor.java:89
# args: e.getMessage()
one\ of\ argument\ of\ apiBody\ is\ invalid,\ %s = apiBody中的某个参数无效, {0}

# at: src/main/java/org/zstack/ticket/entity/TicketStatus.java:48
# args: this,event
operation\ denied.\ the\ ticket\ is\ in\ status\ of\ %s,\ cannot\ do\ the\ operation[%s] = 操作无效。当前工单状态为{0}，无法进行操作[{0}]

# at: src/main/java/org/zstack/ticket/iam2/IAM2Ticket.java:42
# args: ctx.getVirtualIDUuid(),self.getUuid(),self.getName()
operation\ denied\ because\ the\ ticket\ submitter[uuid\:%s]\ has\ been\ deleted,\ the\ ticket[uuid\:%s,\ name\:%s]\ can\ only\ be\ deleted\ now = 操作无效。因为工单的提交者[uuid:{0}]已经被删除，工单[uuid:{1}, name:{2}]仅支持删除操作

# at: src/main/java/org/zstack/ticket/iam2/IAM2Ticket.java:47
# args: ctx.getProjectUuid(),self.getUuid(),self.getName()
operation\ denied\ because\ the\ project[uuid\:%s]\ of\ the\ ticket\ has\ been\ deleted,\ the\ ticket[uuid\:%s,\ name\:%s]\ can\ only\ be\ deleted\ now = 操作无效。因为工单所属的项目[uuid:{0}]已经被删除，工单[uuid:{1}, name:{2}]仅支持删除操作

# at: src/main/java/org/zstack/ticket/iam2/IAM2Ticket.java:59
# args: 
operation\ denied\ because\ flow\ collection[uuid\:%s]\ it\ not\ belong\ the\ project[uuid\:%s] = 操作无效，因为流程[uuid:{0}]不属于项目[uuid:{1}]

# at: src/main/java/org/zstack/ticket/iam2/IAM2Ticket.java:71
# args: msg.getSession().getUserUuid(),self.getUuid(),self.getName()
the\ virtual\ ID[uuid\:%s]\ is\ not\ the\ owner\ of\ the\ ticket[uuid\:%s,\ name\:%s] = virtual ID[uuid:{0}]不是工单[uuid:{1}, name:{2}]的所有者

# at: src/main/java/org/zstack/ticket/iam2/IAM2TicketManager.java:197
# args: 
approver\ is\ removed\ from\ project\ or\ deleted,\ flow\ collection\ changed\ to\ invalid,\ reject\ this\ ticket = 审批人已经离开项目或者被删除，流程失效，因此驳回当前工单

# at: src/main/java/org/zstack/ticket/iam2/api/IAM2TicketApiInterceptor.java:74
# args: 
at\ least\ one\ flow\ is\ needed\ for\ create\ flow\ collection = 创建流程时需要至少一个步骤

# at: src/main/java/org/zstack/ticket/iam2/api/IAM2TicketApiInterceptor.java:81
# args: flow.approverTitle,approveTitles
wrong\ approver\ title\ %s,\ valid\ value\ is\ %s = 错误的审批人职位{0}, 有效输入为{1}

# at: src/main/java/org/zstack/ticket/iam2/api/IAM2TicketApiInterceptor.java:97
# args: flow.approverUuid
can\ not\ find\ IAM2VirtualIDVO[uuid\:%s] = 找不到对应的IAM2VirtualIDVO[uuid:{0}]

# at: src/main/java/org/zstack/ticket/iam2/api/IAM2TicketApiInterceptor.java:58
# args: 
name\ is\ needed\ when\ create\ a\ flow = 创建步骤时需要填写名称

# at: src/main/java/org/zstack/ticket/iam2/api/IAM2TicketApiInterceptor.java:63
# args: msg.getProjectUuid()
you\ have\ already\ created\ a\ collection\ for\ project[uuid\:%s] = 你已经给项目[uuid:{0}]创建过流程了

# at: src/main/java/org/zstack/ticket/iam2/api/IAM2TicketApiInterceptor.java:85
# args: 
name\ cannot\ be\ null = 名称不能为空

# at: src/main/java/org/zstack/ticket/iam2/api/IAM2TicketApiInterceptor.java:89
# args: 
approverUuid\ cannot\ be\ null = 

# at: src/main/java/org/zstack/ticket/iam2/api/IAM2TicketApiInterceptor.java:104
# args: flow.approverUuid,projectUuid
virtual\ id[uuid\:%s]\ not\ belong\ to\ project[uuid\:%s] = virtual id[uuid:{0}]不属于项目[uuid:{1}]

# at: src/main/java/org/zstack/twoFactorAuthentication/TwoFactorAuthenticationManagerImpl.java:90
# args: 
two\ factor\ authenticator\ is\ not\ enabled = 双因子认证未启用

# at: src/main/java/org/zstack/usbDevice/KvmUsbDeviceBackend/UsbDeviceKvmBackend.java:269
# args: usbInv.getHostUuid()
host[%s]\ has\ started\ more\ than\ 64\ usb\ redirect\ port = 

# at: src/main/java/org/zstack/usbDevice/KvmUsbDeviceBackend/UsbDeviceKvmBackend.java:274
# args: host.getUuid()
unable\ to\ start\ usb\ server\ on\ host[%s],\ because\ host\ is\ not\ connected = 

# at: src/main/java/org/zstack/usbDevice/KvmUsbDeviceBackend/UsbDeviceKvmBackend.java:296
# args: usbInv.getHostUuid()
failed\ to\ start\ usbredirect\ server\ from\ host[uuid\:%s] = 

# at: src/main/java/org/zstack/usbDevice/UsbDeviceAllocatorFactory.java:83
# args: 
no\ candidate\ host\ with\ the\ usb\ device\ have\ enough\ cpu\ /\ memory\ or\ Enabled/Connected\ status = usb设备所在的物理机都不满足cpu / memory或状态的条件

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:38
# args: msg.getClass().getSimpleName()
%s\ can\ only\ be\ called\ by\ admin\ account = {0}只能被admin账户调用

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:59
# args: msg.getUsbDeviceUuid(),usb.getVmInstanceUuid()
the\ usb\ device[uuid\:%s]\ has\ already\ been\ attached\ to\ another\ vm[uuid\:%s] = USB设备[uuid:{0}]已经被绑定在其他的虚拟机[uuid:{1}]

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:66
# args: msg.getUsbDeviceUuid(),UsbDeviceState.Enabled
the\ usb\ device[uuid\:%s]\ is\ not\ in\ attachable\ state\ of\ %s = USB设备[uuid:{0}]不处于可绑定的状态[{1}]

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:74
# args: msg.getVmInstanceUuid(),allowedVmInstanceAttachableState
the\ vm\ instance[uuid\:%s]\ is\ not\ in\ attachable\ state\ of\ %s\ for\ usb\ device = 虚拟机[uuid:{0}]不能绑定{1}状态的USB设备

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:84
# args: usb.getHostUuid(),msg.getUsbDeviceUuid(),HostState.Enabled,HostStatus.Connected
the\ host\ that\ the\ usb\ device[uuid\:%s]\ pluged\ in\ is\ not\ in\ valid\ state[%s]\ or\ status[%s] = 插上USB设备的物理机没有处于一种有效的状态[{1}、{2}]

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:97
# args: usb.getUuid(),vm.getUuid()
the\ usb\ device[uuid\:%s]\ has\ different\ hostUuid\ than\ devices\ that\ already\ attached\ to\ the\ vm\ instance[uuid\:%s] = 与已经绑定虚拟机实例相比，USB设备[uuid:{0}]有不同的物理机uuid

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:109
# args: usb.getUuid()
the\ usb\ device[uuid\:%s]\ is\ not\ attached\ to\ any\ vm\ instance. = USB设备[uuid:{0}]不能绑定任何虚拟机实例

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:117
# args: usb.getUuid(),allowedVmInstanceDetachableState
the\ vm\ instance\ that\ the\ usb\ device[uuid\:%s]\ is\ attached\ to\ is\ not\ in\ detachable\ state\ of\ %s = 绑定了USB设备[uuid:{0}]的虚拟机实例处于一种不能解绑的状态{1}

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:127
# args: vm.getUuid(),allowedVmInstanceAttachableState
vm\ instance[uuid\:%s]\ not\ in\ attachable\ state\ of\ %s\ for\ usb\ device = 虚拟机实例[uuid:{0}]对于USB设备没有处于一种可绑定的状态{1}

# at: src/main/java/org/zstack/usbDevice/UsbDeviceApiInterceptor.java:138
# args: msg.getUuid()
cannot\ disable\ usb\ device[uuid\:%s]\ when\ it's\ attached\ to\ a\ vm\ instance = 当USB设备绑定到虚拟机上时不能禁用该USB设备

# at: src/main/java/org/zstack/usbDevice/UsbDeviceManager.java:681
# args: msg.getVmInstanceUuid()
cannot\ migrate\ vm[uuid\:%s]\ because\ there\ are\ pci\ devices\ attached = 虚拟机[uuid:{0}]加载了pci设备无法迁移

# at: src/main/java/org/zstack/usbDevice/UsbDeviceManager.java:202
# args: UsbDeviceConstants.MAX_USB_1_DEVICE_PER_VM
You\ can\ attach\ at\ most\ %s\ USB\ 1.0\ devices\ to\ one\ vm\ instance. = 可以绑定超过{0}个USB 1.0设备到一个虚拟机上

# at: src/main/java/org/zstack/usbDevice/UsbDeviceManager.java:217
# args: UsbDeviceConstants.MAX_USB_2_DEVICE_PER_VM
You\ can\ attach\ at\ most\ %s\ USB\ 2.0\ devices\ to\ one\ vm\ instance. = 可以绑定超过{0}个USB 2.0设备到一个虚拟机上

# at: src/main/java/org/zstack/usbDevice/UsbDeviceManager.java:232
# args: UsbDeviceConstants.MAX_USB_3_DEVICE_PER_VM
You\ can\ attach\ at\ most\ %s\ USB\ 3.0\ devices\ to\ one\ vm\ instance. = 可以绑定超过{0}个USB 3.0设备到一个虚拟机上

# at: src/main/java/org/zstack/usbDevice/UsbDeviceManager.java:160
# args: 
PassThrough\ only\ support\ use\ on\ vm\ running\ host = 

# at: src/main/java/org/zstack/usbDevice/UsbDeviceManager.java:177
# args: msg.getUsbDeviceUuid(),msg.getVmInstanceUuid()
cannot\ attach\ the\ usb\ device[uuid\:%s]\ to\ vm[uuid\:%s]\ due\ to\ host\ allocation = 不能绑定USB设备[uuid:{0}]到虚拟机[uuid:{1}]，因为物理机的配置

# at: src/main/java/org/zstack/usbDevice/UsbDeviceManager.java:630
# args: msg.getVmInstanceUuid()
cannot\ migrate\ vm[uuid\:%s]\ because\ there\ are\ usb\ devices\ attached\ by\ passthrough = 不能迁移虚拟机[uuid:{0}]，因为虚拟机通过直连的方式绑定了USB设备

# at: src/main/java/org/zstack/usbDevice/UsbDeviceManager.java:663
# args: msg.getVolumeUuid()
cannot\ migrate\ root\ volume[uuid\:%s]\ because\ there\ are\ usb\ devices\ attached = 不能迁移根云盘[uuid:{0}]，因为USB设备已经被绑定

# at: src/main/java/org/zstack/v2v/CleanConversionVolumeCacheGC.java:44
# args: 
not\ the\ time\ to\ clean = 

# at: src/main/java/org/zstack/v2v/CleanConversionVolumeCacheGC.java:49
# args: conversionHost.getUuid(),conversionHost.getHostUuid()
conversionHost[uuid\:%s,\ hostUuid\:%s]\ is\ not\ Connected = 

# at: src/main/java/org/zstack/v2v/ResumeConvertVmJobGC.java:126
# args: hostUuid
host[uuid\:%s]\ is\ not\ Connected = 

# at: src/main/java/org/zstack/v2v/ResumeConvertVmJobGC.java:130
# args: primaryStorageUuid
primaryStorage[uuid%s]\ is\ not\ Connected = 

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:183
# args: duplicateMac.get()
Not\ allowed\ same\ mac\ [%s] = 不允许存在相同的MAC地址[{0}]

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:202
# args: duplicateElements.get(0)
Can't\ add\ same\ uuid\ in\ the\ l3Network,uuid\:\ %s = 不能添加相同的uuid{0}在L3网络中

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:214
# args: l3Uuid
l3Network[uuid\:%s]\ is\ Disabled,\ can\ not\ create\ vm\ on\ it = L3网络[uuid:{0}]没有被启用，不能从这个L3网络创建云主机

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:217
# args: l3Uuid
l3Network[uuid\:%s]\ is\ system\ network,\ can\ not\ create\ user\ vm\ on\ it = L3网络[uuid:{0}]是系统网络，不能在这上面创建云主机

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:249
# args: msg.getZoneUuid()
zone[uuid\:%s]\ is\ specified\ but\ it's\ Disabled,\ can\ not\ create\ vm\ from\ it = 区域[uuid:{0}]虽然被指定了但是处于未启用状态，不能从这上面创建云主机

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:259
# args: msg.getClusterUuid()
cluster[uuid\:%s]\ is\ specified\ but\ it's\ Disabled,\ can\ not\ create\ vm\ from\ it = 集群[uuid:{0}]虽然被指定了但是处于未启用状态，不能从这上面创建云主机

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:270
# args: msg.getHostUuid()
host[uuid\:%s]\ is\ specified\ but\ it's\ Disabled,\ can\ not\ create\ vm\ from\ it = 物理机[uuid:{0}]虽然被指定了但是处于未启用状态，不能从这上面创建云主机

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:275
# args: msg.getHostUuid(),connectionState
host[uuid\:%s]\ is\ specified\ but\ it's\ connection\ status\ is\ %s,\ can\ not\ create\ vm\ from\ it = 物理机[uuid:{0}]虽然被指定了但是它的连接状态是{1}，不能从这上面创建云主机

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:231
# args: msg.getDefaultL3NetworkUuid(),msg.getL3NetworkUuids()
defaultL3NetworkUuid[uuid\:%s]\ is\ not\ in\ l3NetworkUuids%s = 默认L3网络的uuid是[uuid:{0}]，不在L3网络uuid们中{1}

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:227
# args: 
there\ are\ more\ than\ one\ L3\ network\ specified\ in\ l3NetworkUuids,\ but\ defaultL3NetworkUuid\ is\ null = 在L3网络uuid们中有很多L3网络被指定了，但是默认L3网络的uuid是空的

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:71
# args: msg.getHostUuid()
host[uuid\:%s]\ must\ be\ Enabled\ and\ Connected\ to\ be\ a\ conversion\ host = 

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:84
# args: 
v2v\ conversion\ host\ storage\ path\ must\ be\ absolute\ path = 

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:106
# args: msg.getUrl()
invalid\ v2v\ url\:\ %s = 

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:117
# args: srcVmUuid
vm\ instance[uuid\:%s]\ does\ not\ exist\ or\ is\ not\ a\ vmware\ vm = 

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:126
# args: 
conversionHostUuid\ should\ not\ be\ null = 

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:132
# args: msg.getConversionHostUuid()
conversion\ host[uuid\:%s]\ should\ be\ Enabled = 

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:144
# args: msg.getConversionHostUuid()
underlying\ host\ of\ conversion\ host[uuid\:%s]\ should\ be\ Enabled\ and\ Connected = 

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:160
# args: msg.getConversionHostUuid(),msg.getPrimaryStorageUuid()
conversion\ host[uuid\:%s]\ cannot\ connect\ to\ primary\ storage[uuid\:%s] = 

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:194
# args: duplicateMacs
Duplicate\ mac\ address\ %s = 

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:283
# args: msg.getPrimaryStorageUuid()
primary\ storage[uuid\:%s]\ is\ not\ supported\ for\ v2v = 

# at: src/main/java/org/zstack/v2v/V2VApiInterceptor.java:286
# args: msg.getPrimaryStorageUuid()
primary\ storage[uuid\:%s]\ is\ neither\ Enabled\ nor\ Connected = 

# at: src/main/java/org/zstack/v2v/V2VManagerImpl.java:530
# args: l3Uuid
Unable\ to\ find\ L3Network[uuid\:%s]\ to\ start\ the\ current\ vm,\ it\ may\ have\ been\ deleted,\ Operation\ suggestion\:\ delete\ this\ vm,\ recreate\ a\ new\ vm = 

# at: src/main/java/org/zstack/v2v/V2VManagerImpl.java:1100
# args: bandwidth
invalid\ network\ bandwidth[%s],\ it\ is\ not\ a\ number = 错误的网络带宽[{0}]，这不是数字

# at: src/main/java/org/zstack/v2v/V2VManagerImpl.java:1095
# args: bandwidth
invalid\ network\ bandwidth[%s],\ it\ must\ be\ greater\ than\ or\ equal\ to\ 8192 = 错误的网络带宽[{0}],这个数字必须大于等于8K

# at: src/main/java/org/zstack/v2v/V2VManagerImpl.java:1097
# args: 
networkInboundBandwidth\ execeds\ the\ max\ value\ 32G\ bps = 超过下行网络带宽超过最大值32G bps

# at: src/main/java/org/zstack/v2v/V2VManagerImpl.java:577
# args: msg.getUrl()
can\ not\ find\ type\ for\ src\ vm[url\:%s] = 

# at: src/main/java/org/zstack/v2v/V2VManagerImpl.java:591
# args: msg.getUrl(),msg.getType()
can\ not\ find\ factory\ for\ src\ vm[url\:%s,\ v2vType\:%s] = 

# at: src/main/java/org/zstack/v2v/V2VManagerImpl.java:851
# args: msg.getHostUuid()
there\ has\ been\ a\ v2v\ conversion\ host\ with\ hostUuid\ %s = 

# at: src/main/java/org/zstack/v2v/V2VManagerImpl.java:1089
# args: 
invalid\ v2v\ qos\ systemtag = 

# at: src/main/java/org/zstack/v2v/vmware/VMwareV2VBase.java:175
# args: job.getUuid()
v2v\ job[uuid\:%s]\ is\ running = V2V迁移任务[uuid:{0}]正在运行

# at: src/main/java/org/zstack/v2v/vmware/VMwareV2VBase.java:690
# args: srcVmUrl
failed\ to\ get\ virt-v2v\ uri\ for\ %s = 

# at: src/main/java/org/zstack/v2v/vmware/VMwareV2VBase.java:1020
# args: NOT_SUPPORTED_SPECIAL_CHARACTER
Target\ vm\ name\ can\ not\ contain\ those\ characters\ %s = 

# at: src/main/java/org/zstack/v2v/vmware/VMwareV2VFactory.java:120
# args: jobUuid,msg.getUrl()
There\ is\ already\ a\ long\ job[uuid\:%s]\ convert\ vm\ from\ %s = 

# at: src/main/java/org/zstack/v2v/vmware/VMwareV2VFactory.java:144
# args: 
Failed\ to\ update\ conversion\ host\ dependency = 

# at: src/main/java/org/zstack/vmware/ESXHost.java:151
# args: 
host\ is\ not\ connected = 

# at: src/main/java/org/zstack/vmware/ESXHost.java:327
# args: vmUuid,self.getUuid()
vmUuid\ [%s]\ not\ found\ in\ ESX\ host\ [%s] = 

# at: src/main/java/org/zstack/vmware/ESXHost.java:671
# args: vmUuid
VM\ not\ found\:\ %s = 

# at: src/main/java/org/zstack/vmware/ESXHost.java:600
# args: vmUuid,VMwareHelper.exStr(ex)
failed\ to\ suspend\ VM\ [%s]\:\ %s = 

# at: src/main/java/org/zstack/vmware/ESXHost.java:596
# args: t.getTaskInfo().getError().getLocalizedMessage()
failed\ to\ suspend\ VM,\ task\ status\:\ %s = 

# at: src/main/java/org/zstack/vmware/ESXHost.java:634
# args: vmUuid,VMwareHelper.exStr(ex)
failed\ to\ resume\ VM\ [%s]\:\ %s = 

# at: src/main/java/org/zstack/vmware/ESXHost.java:630
# args: t.getTaskInfo().getError().getLocalizedMessage()
failed\ to\ resume\ VM,\ task\ status\:\ %s = 

# at: src/main/java/org/zstack/vmware/ESXHost.java:702
# args: vmUuid,VMwareHelper.exStr(ex)
failed\ to\ shutdown\ guest\:\ %s,\ %s = 

# at: src/main/java/org/zstack/vmware/ESXHost.java:1312
# args: vmInv.getInstanceOfferingUuid()
instance\ uuid\ [%s]\ not\ found = 

# at: src/main/java/org/zstack/vmware/ESXHost.java:1322
# args: vmInv.getImageUuid()
Image\ [%s]\ not\ found = 

# at: src/main/java/org/zstack/vmware/ESXHost.java:1421
# args: vmUuid
VM\ [%s]\ not\ found\ in\ vCenter = 

# at: src/main/java/org/zstack/vmware/ESXHost.java:1590
# args: t.getTaskInfo().getError().getLocalizedMessage()
failed\ to\ power\ on\ VM,\ task\ status\:\ %s = 

# at: src/main/java/org/zstack/vmware/ESXHostFactory.java:72
# args: msg.getClusterUuid(),ESXConstant.VMWARE_HYPERVISOR_TYPE
cluster[uuid\:%s]\ hypervisorType\ is\ not\ %s = 

# at: src/main/java/org/zstack/vmware/VCenterApiInterceptor.java:47
# args: 
vCenter\ login\ name\ expected. = vCenter登录名称为空

# at: src/main/java/org/zstack/vmware/VCenterApiInterceptor.java:51
# args: msg.getDomainName()
domainName[%s]\ is\ neither\ an\ IPv4\ address\ nor\ a\ valid\ hostname = 域名[{0}]不是一个IPv4地址或有效的主机名

# at: src/main/java/org/zstack/vmware/VCenterApiInterceptor.java:57
# args: msg.getDomainName()
vCenter\ [domainName\:%s]\ has\ been\ added = vCenter[domainName:{0}]已经被添加

# at: src/main/java/org/zstack/vmware/VCenterApiInterceptor.java:94
# args: clusterUuid,l2uuid
Cluster[uuid\:%s]\ and\ L2[uuid\:%s]\ belongs\ to\ different\ DCs = 集群[uuid:{0}]和二层网络[uuid:{1}]属于不同的DC

# at: src/main/java/org/zstack/vmware/VCenterApiInterceptor.java:106
# args: clusterUuid
No\ hosts\ found\ within\ cluster\:\ %s = 在集群{0}中未发现物理机

# at: src/main/java/org/zstack/vmware/VCenterApiInterceptor.java:139
# args: phyinf
vSwitch/dvSwitch\ not\ found\:\ %s = vSwitch/dvSwitch未找到: {0}

# at: src/main/java/org/zstack/vmware/VCenterApiInterceptor.java:153
# args: l2uuid,vcvo.getUuid(),clusterUuid
L2[uuid\:%s]\ doesn't\ belong\ to\ vCenter[uuid\:%s]\ cluster[uuid\:%s] = 二层网络[uuid:{0}]不属于vCenter[uuid:{1}]集群[uuid:{2}]

# at: src/main/java/org/zstack/vmware/VCenterBackupStorage.java:62
# args: bsUuid
No\ data-store\ attached\ to\ %s = 

# at: src/main/java/org/zstack/vmware/VCenterBackupStorage.java:67
# args: bsUuid
Data-store\ not\ found\ for\ %s = 

# at: src/main/java/org/zstack/vmware/VCenterBackupStorage.java:95
# args: url.getProtocol()
unexpected\ protocol\:\ %s = 

# at: src/main/java/org/zstack/vmware/VCenterBackupStorage.java:101
# args: iinv.getName()
%s\ already\ exists = 

# at: src/main/java/org/zstack/vmware/VCenterBackupStorage.java:183
# args: 
image\ not\ found\ in\ BS = 

# at: src/main/java/org/zstack/vmware/VCenterBackupStorage.java:195
# args: 
not\ supported\ yet = 

# at: src/main/java/org/zstack/vmware/VCenterHostAllocatorFilterExtensionPoint.java:361
# args: 
no\ candidate\ host\ for\ vcenter\ vm = 找不到VCenter的物理机去启动vm

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:923
# args: nicvo.getMac(),vm1.getUuid(),vm1.getName(),vm2.getUuid(),vm2.getName()
Duplicated\ mac\ address[%s]\ on\ VM[uuid\:\ %s,\ name\:\ %s]\ and\ VM[uuid\:\ %s,\ name\:\ %s] = 

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:1777
# args: 
can't\ sync\ before\ datastores\ are\ separated = 

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:2789
# args: msg.getVCenterUuid()
VCenter[uuid\:%s]\ not\ found\:\  = VCenter[uuid:{0}]不存在

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:2905
# args: 
Login\ failed,\ please\ check\ your\ login\ parameters. = 

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:2909
# args: msg.getDomainName(),ex.getMessage()
connect\ %s\ failed\:\ %s = 

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:2915
# args: msg.getDomainName(),msg.getUsername()
Login\ to\ vCenter\ [%s]\ failed\ with\ user\ [%s],please\ check\ your\ network\ connection\ and\ credential. = 

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:2922
# args: msg.getDomainName(),msg.getPort() == null ? 443 : msg.getPort()
Parse\ response\ failed\ from\ vCenter\ [%s],please\ check\ the\ port\ number[%d]. = 

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:3000
# args: 
No\ clustered\ compute\ resource\ found = 

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:3004
# args: 
No\ dvSwitch\ or\ qualified\ vSwitch\ found = 

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:3183
# args: dsMorVal,vcUuid
Datastore\ %s\ not\ found\ for\ vCenter\ %s = 

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:3544
# args: 
Missing\ host\ UUID\ in\ message = 

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:3608
# args: 
Missing\ destination\ host\ uuid. = 缺少目标物理机的Uuid

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:3613
# args: 
Destination\ host\ is\ not\ ESX\ host. = 目标物理机不是Esx类型物理机

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:3654
# args: vm.getConfig().getName(),hvo.getManagementIp()
Checking\ compatibility\ with\ vm\ %s\ failed\ on\ host\ %s = 

# at: src/main/java/org/zstack/vmware/VCenterManagerImpl.java:3648
# args: 
HOST\ CPU/software\ NOT\ compatible = 物理机的CPU/software不兼容

# at: src/main/java/org/zstack/vmware/VCenterPrimaryStorageBase.java:204
# args: 
No\ virtual\ disk\ manager = 

# at: src/main/java/org/zstack/vmware/VCenterPrimaryStorageBase.java:211
# args: 
No\ file\ manager = 

# at: src/main/java/org/zstack/vmware/VCenterPrimaryStorageBase.java:220
# args: 
No\ file\ Datacenter = 

# at: src/main/java/org/zstack/vmware/VCenterPrimaryStorageBase.java:324
# args: vm.getName()
failed\ to\ get\ VM[%s]\ root\ disk\ usage = 

# at: src/main/java/org/zstack/vmware/VCenterPrimaryStorageBase.java:320
# args: msg.getInstallPath()
failed\ to\ get\ VM\ from\ installPath\:\ %s = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:171
# args: vCenterUrl,ex.getMessage()
failed\ to\ connect\ to\ vCenter\:\ %s\:\ %s = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:303
# args: installPath
vdisk\ not\ found\:\ %s = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:378
# args: getVcDomainName(si)
list\ storage\ failed\ for\ %s = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:398
# args: vm.getName()
No\ datastore\ found\ for\ VM\:\ %s = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:452
# args: info.getName(),info.getInstanceUuid()
failed\ to\ set\ ESX\ VM\ uuid\ [%s\:%s] = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:533
# args: zsImageUuid
template\ [%s]\ not\ found = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:610
# args: host.getName()
failed\ to\ search\ resource\ pool\ for\ host\ %s = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:606
# args: host.getName()
No\ resource\ pool\ found\ for\ host\ %s = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:2035
# args: installPath
No\ unit\ number\ available\ for\ data\ disk\ %s = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1186
# args: vm.getName()
guest\ tools\ not\ installed\ or\ running\ for\ VM\:\ %s = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1221
# args: vm.getName()
upload\ file\ failed\ for\ VM\:\ %s = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1309
# args: vcvo.getName()
list\ dvSwitch\ failed\ for\ %s = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1669
# args: dvSwitch
dvSwitch\ name\ [%s]\ not\ unique = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1727
# args: hvo.getName()
create\ portgroup\ failed\ for\ host\ %s = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1724
# args: hvo.getName(),((OperationFailureException) ex).getErrorCode().getDetails()
create\ portgroup\ failed\ for\ host\ %s\:\ because\ %s = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1691
# args: hvo.getName(),hvo.getUuid()
Host[%s\:%s]\ not\ found\ on\ vCenter = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1703
# args: pgLabel,hvo.getName(),vlanId
portgroup[%s]\ already\ exists\ on\ host[%s]\ but\ with\ different\ vlanId(%d) = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1766
# args: vcvo.getName()
create\ dvPortGroup\ failed\ for\ %s = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1761
# args: dvSwitchName,vcvo.getName()
dvSwitch\ [%s]\ not\ found\ on\ vCenter\ [%s] = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1956
# args: ds.getName()
no\ dataCenter\ found\ for\ datastore = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1961
# args: 
virtual\ disk\ manager\ unavailable = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:1972
# args: installPath,mf.getLocalizedMessage()
delete\ vdisk[%s]\ failed\:\ %s = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:2101
# args: dvSwitch.getName(),task.getTaskInfo().getError().getLocalizedMessage()
create\ dvPortGroup\ failed\ for\ dvSwitch\ [%s],\ %s = 

# at: src/main/java/org/zstack/vmware/VMwareHelper.java:2205
# args: me.getName(),mor.val,ex.getMessage()
failed\ to\ set\ ZStack\ uuid\ to\ VCenter\ ManagedEntity\ [name\:%s,\ mor\:%s]\ because\ %s = 

# at: src/main/java/org/zstack/vmware/VncPortAllocatorImpl.java:164
# args: 
No\ VNC\ ports\ available = 

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:185
# args: l3NetworkVO.getUuid()
no\ ip\ ranges\ attached\ with\ l3\ network[uuid\:%s] = 在三层网络[uuid:{0}]上没有IP范围被绑定

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:143
# args: l3NetworkVO.getUuid(),vmInstanceVO.getUuid(),vmNicVOS.stream().map( n -> n.getUuid()).collect(Collectors.toList())
vpc\ l3\ network[uuid\:%s]\ can\ not\ detach\ from\ vpc\ vrouter[uuid\:%s]\ sine\ vm\ nics[%s]\ still\ used\ in\ l3 = VPC三层网络[uuid:{0}]不能从云路由[uuid:{1}]解绑，因为虚拟机网卡[{2}]一直使用这个三层网络

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:153
# args: msg.getVirtualRouterOfferingUuid()
virtual\ router\ offering[uuid\:\ %s]\ is\ not\ enabled = 云路由规格[uuid: {0}]是不可用的

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:178
# args: 
only\ vpc\ l3\ network\ can\ attach\ to\ vpc\ vrouter = 只有VPC三层网络可以绑定到VPC云路由

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:209
# args: vip.getL3NetworkUuid(),vip.getUuid(),vip.getIp(),msg.getL3NetworkUuid(),vmInstanceVO.getUuid()
public\ network[uuid\:\ %s]\ vip[uuid\:\ %s,\ ip\:\ %s]\ peer\ with\ l3network[uuid\:\ %s]\ not\ on\ vpc\ vr[uuid\:\ %s] = 在VPC云路由[uuid: {4}]上，三层网络[uuid: {3}]没有和公有网络[uuid: {0}]虚拟IP[uuid: {1}, ip: {2}]同阶

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:222
# args: gateway,msg.getL3NetworkUuid()
the\ gateway[ip\:%s]\ of\ l3[uuid\:%s]\ has\ been\ occupied = 三层网络[uuid:{1}]的网关[uuid:{0}]已经被占用

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:233
# args: msg.getStaticIp(),gateway,l3NetworkVO.getUuid()
the\ static\ ip[%s]\ specified\ in\ message\ not\ equals\ to\ gateway\ ip[%s]\ of\ l3\ network[uuid\:%s] = 在消息中指定的静态IP地址[{0}]和三层网络[uuid:{2}]的网关IP地址[{1}]不一样

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:240
# args: msg.getDns(),msg.getUuid()
dns\ address\ [%s]\ is\ already\ added\ to\ vpc\ router\ [uuid\:%s] = dns地址[{0}]已经添加到vpc路由[uuid:{1}]

# at: src/main/java/org/zstack/vpc/VpcApiInterceptor.java:246
# args: msg.getDns(),msg.getUuid()
dns\ address\ [%s]\ is\ not\ added\ to\ vpc\ router\ [uuid\:%s] = dns地址[{0}]未添加到vpc路由[uuid:{1}]

# at: src/main/java/org/zstack/vpc/VpcManagerImpl.java:252
# args: vrinv.getUuid()
can\ not\ get\ connections\ of\ distributed\ routing\ to\ virtual\ router\ %s = 不能获取分布式路由到云路由的连接

# at: src/main/java/org/zstack/vpc/VpcManagerImpl.java:294
# args: vrinv.getUuid()
can\ not\ set\ state\ of\ distributed\ routing\ to\ virtual\ router\ %s = 不能设置分布式路由到云路由的状态

# at: src/main/java/org/zstack/vpc/VpcManagerImpl.java:359
# args: 
can\ not\ get\ status\ from\ zsn\ agent = 不能从zsn代理获取状态

# at: src/main/java/org/zstack/vpc/VpcManagerImpl.java:383
# args: msg.getNetworkService(),msg.getUuid()
not\ support\ to\ get\ the\ service\ %s\ state\ to\ virtual\ router\ %s = 

# at: src/main/java/org/zstack/vpc/VpcManagerImpl.java:407
# args: msg.getNetworkService(),msg.getUuid()
not\ support\ to\ update\ the\ service\ %s\ state\ to\ virtual\ router\ %s = 

# at: src/main/java/org/zstack/vpc/VpcManagerImpl.java:470
# args: msg.getNetworkService(),vrinv.getUuid()
can\ not\ set\ the\ %s\ service\ state\ to\ virtual\ router\ %s = 

# at: src/main/java/org/zstack/vpc/VpcManagerImpl.java:741
# args: 
vpc\ l3\ network\ must\ attach\ a\ vpc\ vrouter\ first\ before\ do\ anything\ related\ to\ vrouter(like\ start/stop\ vm,\ create\ lb,\ etc.) = 在做设置云路由的任何操作（如启动/停止虚拟机、创建负载均衡等），VPC三层网络必须首先绑定三层路由

# at: src/main/java/org/zstack/vpc/VpcVRouterFactory.java:266
# args: vpcVrVO.getUuid()
can\ not\ detach\ nic\ from\ vpc\ vr[uuid\:%s] = 不能从VPC云路由[uuid:{0}]解绑网卡

# at: src/main/java/org/zstack/vpc/VpcVRouterFactory.java:305
# args: gateway,l3.getUuid(),vm.getUuid()
the\ gateway[ip\:%s]\ of\ l3[uuid\:%s]\ has\ been\ occupied\ on\ vpc\ vr[uuid\:\ %s] = 在VPC的云路由[uuid: {2}]上，三层网络[uuid:{1}]的网关[uuid:{0}]已经被占用

# at: src/main/java/org/zstack/vpc/VpcVyosDeployZsnAgentFlow.java:129
# args: mgmtNicIp
unable\ to\ ssh\ in\ to\ the\ vyos[%s],\ the\ ssh\ port\ seems\ not\ open = 未能通过ssh进入vyos[{0}]，ssh端口看起来没有打开

# at: src/main/java/org/zstack/vrouterRoute/VRouterRouteManagerImpl.java:189
# args: vrouterVmUuid
virtual\ router[uuid\:%s]\ can\ not\ find = 云路由[uuid:{0}]未找到

# at: src/main/java/org/zstack/vrouterRoute/VRouterRouteManagerImpl.java:194
# args: vo.getApplianceVmType()
can\ not\ find\ service\ factory\ for\ virtual\ router\ type[%s] = 未找到云路由类型为[{0}]的服务工厂

# at: src/main/java/org/zstack/vrouterRoute/VRouterRouteManagerImpl.java:473
# args: msg.getUuid()
cannot\ find\ the\ route\ table\ [uuid\:%s] = 找不到路由表[uuid:{0}]

# at: src/main/java/org/zstack/yunshan/util/YunshanClient.java:46
# args: 
the\ url\ is\ null,\ please\ config\ the\ YunShan\ NSP. = 

# at: src/main/java/org/zstack/zql/ast/visitors/OrderByVisitor.java:13
# args: node.getDirection()
invalid\ order\ by\ clause,\ expect\ direction[asc,desc]\ but\ got\ %s = 

# at: src/main/java/org/zstack/zql/ast/visitors/OrderByVisitor.java:19
# args: m.simpleInventoryName(),node.getField()
invalid\ order\ by\ clause,\ inventory[%s]\ doesn't\ have\ field[%s] = 

# at: src/main/java/org/zstack/zql/ast/visitors/plugin/SumPlugin.java:31
# args: 
the\ field\ to\ sum\ must\ be\ specified = 

# at: src/main/java/org/zstack/zwatch/ZQLReturnWithExtension.java:125
# args: clz.getName()
resource[%s]\ doesn't\ support\ zwatch\ return\ with\ clause = 

# at: src/main/java/org/zstack/zwatch/ZQLReturnWithExtension.java:270
# args: paramName,normalizedExpr
unknown\ parameter[%s]\ in\ zwatch\ return\ with\ clause,\ %s = 

# at: src/main/java/org/zstack/zwatch/ZQLReturnWithExtension.java:279
# args: expr,e.getMessage()
invalid\ zwatch\ return\ with\ clause\:\ %s,\ %s = 

# at: src/main/java/org/zstack/zwatch/ZWatchManagerImpl.java:556
# args: eventData.getDataUuid(),t.getMessage()
update\ eventData[dataUuid\=%s]\ failed,\ %s = 

# at: src/main/java/org/zstack/zwatch/ZWatchManagerImpl.java:674
# args: alarmData.getDataUuid(),t.getMessage()
update\ alarmData[dataUuid\=%s]\ failed,\ %s = 

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:62
# args: msg.getActionUuid(),msg.getSubscriptionUuid()
the\ action[uuid\:%s]\ already\ attached\ to\ the\ event\ subscription[uuid\:%s] = 报警动作[uuid:{0}]已经被加载到报警时间订阅[uuid:{1}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:86
# args: msg.getKey()
event\ doesn't\ have\ label[%s] = 报警事件没有标签[{0}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:91
# args: msg.getKey()
the\ event\ subscription\ already\ has\ the\ label[%s] = 事件订阅已经有标签[{0}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:134
# args: msg.getNamespace()
namespace[%s]\ not\ found = 找不到命名空间[{0}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:108
# args: ns.getName(),msg.getEventName()
namespace[%s]\ doesn't\ have\ the\ event[%s] = 命名空间[{0}]中没有事件[{1}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:116
# args: msg.getEventName(),l.getKey()
event[%s]\ doesn't\ have\ the\ label[%s] = 事件[{0}]不存在标签[{1}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:160
# args: k,l
duplicate\ key[%s]\ with\ values%s = 重复的键[{0}]和键值{1}

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:140
# args: msg.getNamespace(),msg.getMetricName()
namespace[%s]\ doesn't\ have\ the\ metric[%s] = 命名空间[{0}]不包含时序数据[{1}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:149
# args: msg.getMetricName(),l.getKey()
the\ metric[%s]\ doesn't\ have\ the\ label[%s] = 时序数据[{0}]没有标签[{0}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:172
# args: actionType
invalid\ action\ type[%s] = 无效的报警动作类型[{0}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:177
# args: actionUuid,actionType
action[uuid\:%s,\ type\:%s]\ not\ found = 找不到报警动作[uuid:{0}, 类型:{1}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:185
# args: msg.getActionUuid(),msg.getActionType(),msg.getAlarmUuid()
duplicated\ action[uuid\:%s,\ type\:%s]\ for\ the\ alarm[uuid\:%s] = 报警器[uuid:{2}]已经存在报警动作[uuid:{0}, 类型:{1}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmApiInterceptor.java:195
# args: msg.getKey(),msg.getOperator(),msg.getValue(),msg.getAlarmUuid()
duplicate\ label[key\:%s,\ operator\:%s,\ value\:%s]\ for\ the\ alarm[uuid\:%s] = 报警器[uuid:{2}]已经存在标签[key:{0}, operator:{1}, value:{2}]

# at: src/main/java/org/zstack/zwatch/alarm/AlarmManagerImpl.java:101
# args: msg.getSubscriptionUuid()
cannot\ find\ the\ event\ subscription[uuid\:%s],\ it\ may\ have\ been\ deleted = 找不到事件订阅[uuid:{0}]，它可能已经被删除

# at: src/main/java/org/zstack/zwatch/alarm/AlarmManagerImpl.java:110
# args: msg.getAlarmUuid()
cannot\ find\ the\ alarm[uuid\:%s],\ it\ may\ have\ been\ deleted = 找不到报警器[uuid:{0}]，它可能已经被删除

# at: src/main/java/org/zstack/zwatch/alarm/AlarmStatus.java:16
# args: 
InsufficientData = 数据不足

# at: src/main/java/org/zstack/zwatch/alarm/AlarmStatus.java:14
# args: 
Alarm = 已触发

# at: src/main/java/org/zstack/zwatch/alarm/AlarmStatus.java:12
# args: 
OK = 监控中

# at: src/main/java/org/zstack/zwatch/alarm/sns/SNSActionFactory.java:54
# args: actionUuid
cannot\ find\ the\ topic[uuid\:%s] = 找不到主题[uuid:{0}]

# at: src/main/java/org/zstack/zwatch/alarm/sns/SNSActionFactory.java:95
# args: msg.getAlarmTextTemplateUuid()
cannot\ find\ SNSTextTemplate[uuid\:%s],\ it\ may\ have\ been\ deleted = 找不到报警文本模板[uuid:{0}], 它可能已经被删除

# at: src/main/java/org/zstack/zwatch/alarm/sns/SNSTextTemplateApiInterceptor.java:38
# args: msg.getApplicationPlatformType()
invalid\ application\ platform\ type[%s] = 无效的平台类型[{0}]

# at: src/main/java/org/zstack/zwatch/alarm/sns/SNSTextTemplateApiInterceptor.java:43
# args: msg.getApplicationPlatformType()
application\ platform/endpoint\ [%s]\ doesn't\ support\ user-defined\ template = 应用平台/终端[{0}]不支持用户定义模板

# at: src/main/java/org/zstack/zwatch/alarm/sns/SNSTextTemplateApiInterceptor.java:100
# args: String.join(",\n", errorParams),String.join(",\n", AbstractTextTemplate.defaultSupportedParams)
parameters\:\n\ %s\ are\ not\ supported\ by\ ZStack,\ available\ values\ are\:\n\ %s = 

# at: src/main/java/org/zstack/zwatch/alarm/system/SystemAlarmManagerImpl.java:512
# args: DATA_DIR_CAPACITY_ALARM_UUID
alarm[uuid\:%s]\ is\ a\ system\ alarm\ which\ cannot\ be\ deleted = 报警器[uuid:{0}]是一个系统报警器，不能被删除

# at: src/main/java/org/zstack/zwatch/alarm/system/SystemAlarmManagerImpl.java:523
# args: SNSSystemAlarmTopicManager.SYSTEM_ALARM_TOPIC_UUID,DATA_DIR_CAPACITY_ALARM_UUID
removing\ system\ topic[uuid\:%s]\ from\ system\ alarm[uuid\:%s]\ is\ forbidden = 禁止从系统报警器[uuid:{1}]移除系统主题[uuid:{0}]

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:201
# args: l.getKey(),AuditData.queryableLoginLabels
invalid\ label[%s],\ valid\ queryable\ labels\ are\ %s = 无效的标签[{0}]，有效的可查询标签是{1}

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:248
# args: msg.getStartTime(),msg.getEndTime()
startTime[%s]\ is\ greater\ than\ endTime[%s] = 开始时间[{0}]大于结束时间[{1}]

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:112
# args: 
dataUuid\ cannot\ be\ missed = 

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:118
# args: 
dataStartTime\ and\ dataEndTime\ cannot\ be\ missed = 

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:122
# args: msg.getDataStartTime(),msg.getDataEndTime()
dataStartTime[%s]\ is\ greater\ than\ dataEndTime[%s] = 

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:140
# args: Namespace.ZSTACK_NAMESPACE_PREFIX
namespace\ name\ cannot\ start\ with\ %s\ that\ is\ reserved = 名字空间(namespace)不能以{0}开头

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:151
# args: msg.getNamespace()
cannot\ find\ namespace[%s] = 名字空间(namespace[{0}]不存在

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:159
# args: msg.getMetricName(),msg.getNamespace()
cannot\ find\ metric[%s]\ in\ namespace[%s] = 名字空间(namespace[{1}]中找不到时序数据[{0}]

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:172
# args: msg.getMetricName(),metric.getLabelNames(),l.getKey()
metric[%s]'s\ labels[%s]\ does\ not\ include\ [%s] = 时序数据[{0}]的标签列表[{1}]没有指定的标签[{2}]

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:184
# args: msg.getMetricName(),l.getValue()
metric[%s]\ does\ not\ has\ filter[%s] = 时序数据[{0}]不包含过滤条件[{1}]

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:227
# args: AuditData.TAG_RESOURCE_UUID
label[%s]\ must\ be\ specified = 必须指定标签[{0}]

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:269
# args: end,msg.getEndTime(),start,msg.getStartTime()
endTime[%s,\ %sms]\ must\ not\ be\ before\ startTime[%s,\ %sms] = 停止时间(endTime)[{0}, {1}ms]不能在开始时间(startTime)[{2}, {3}ms]

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:287
# args: msg.getNamespace()
no\ namespace[%s]\ defined\ in\ the\ system = 系统中未定义名字空间(namespace[{0}])

# at: src/main/java/org/zstack/zwatch/api/ZWatchApiInterceptor.java:291
# args: msg.getNamespace(),msg.getMetricName()
the\ namespace[%s]\ has\ no\ metric[%s] = 名字空间(namespace[{0}])不包含时序数据[{1}]

# at: src/main/java/org/zstack/zwatch/datatype/Function.java:106
# args: expr,e.getMessage()
invalid\ function\:\ %s,\ %s = 无效的方法: {0}, {1}

# at: src/main/java/org/zstack/zwatch/datatype/Function.java:110
# args: expr
invalid\ expression\:\ %s,\ no\ function\ found = 无效的表达式: {0}，找不到对应的方法

# at: src/main/java/org/zstack/zwatch/datatype/Label.java:57
# args: str
the\ label\ string[%s]\ contains\ no\ valid\ operator = 标签中[{0}]未包含有效的比较符号(operator)

# at: src/main/java/org/zstack/zwatch/datatype/Label.java:72
# args: JSONObjectUtil.toJsonString(this)
invalid\ label,\ 'key'\ field\ cannot\ be\ null.\ %s = 无效的标签"key"不能为空。{0}

# at: src/main/java/org/zstack/zwatch/datatype/Label.java:75
# args: JSONObjectUtil.toJsonString(this)
invalid\ label,\ 'op'\ field\ is\ null\ or\ something\ another\ than\ Regex\ and\ Equal.\ %s = 无效的标签，'op'为空或者是其它的非正则或者等于符号。{0}

# at: src/main/java/org/zstack/zwatch/datatype/Label.java:78
# args: JSONObjectUtil.toJsonString(this)
invalid\ label,\ 'value'\ field\ cannot\ be\ null.\ %s = 无效的标签"value"不能为空。{0}

# at: src/main/java/org/zstack/zwatch/function/ArgumentChecker.java:30
# args: value,name
invalid\ value[%s]\ of\ the\ argument[%s] = 参数[{1}]值(value)[{0}]无效

# at: src/main/java/org/zstack/zwatch/function/LimitFunction.java:21
# args: v
value[%s]\ is\ not\ a\ Integer\ number = 值(value)[{0}]不是一个整数

# at: src/main/java/org/zstack/zwatch/function/LimitFunction.java:18
# args: v
invalid\ argument[limit\:%s],\ it\ can't\ be\ a\ negative\ number = 无效的参数[limit:{0}]，不能是负数

# at: src/main/java/org/zstack/zwatch/function/MetricFunction.java:46
# args: name
missing\ required\ argument[%s] = 缺少参数[{0}]

# at: src/main/java/org/zstack/zwatch/function/MetricFunction.java:59
# args: k
duplicate\ argument[%s] = 重复的参数[{0}]

# at: src/main/java/org/zstack/zwatch/function/MetricFunction.java:68
# args: func.getName()
unknown\ function[%s] = 未知方法[{0}]

# at: src/main/java/org/zstack/zwatch/function/SortFunction.java:41
# args: arg.name
unknown\ argument[%s] = 未知参数[{0}]

# at: src/main/java/org/zstack/zwatch/influxdb/InfluxDBEventDatabaseDriver.java:140
# args: name
cannot\ find\ EventFamily[name\:%s] = 找不到事件族[name:{0}]

# at: src/main/java/org/zstack/zwatch/influxdb/InfluxDBEventDatabaseDriver.java:162
# args: name,namespace
cannot\ find\ EventFamily[name\:%s,\ namespace\:%s] = 找不到事件族[name:{0}, namespace:{1}]

# at: src/main/java/org/zstack/zwatch/influxdb/InfluxDBEventDatabaseDriver.java:510
# args: label.getKey(),names
invalid\ query\ label[%s].\ Allowed\ label\ names\ are\ %s = 无效的查询标签[{0}]。允许标签名是 {1}

# at: src/main/java/org/zstack/zwatch/influxdb/InfluxDBEventDatabaseDriver.java:539
# args: name.getValue(),InfluxEventData.TAG_NAMESPACE
there\ are\ multiple\ EventFamily\ with\ the\ name[%s],\ you\ must\ specify\ the\ label[%s] = 存在多个名为[{0}]的事件族，你必须指定标签[{1}]

# at: src/main/java/org/zstack/zwatch/influxdb/InfluxDatabaseCreator.java:58
# args: ret.getError()
unable\ to\ query\ influxdb,\ %s = 

# at: src/main/java/org/zstack/zwatch/influxdb/InfluxDatabaseCreator.java:69
# args: JSONObjectUtil.toJsonString(ret)
invalid\ influxdb\ response\:\ %s,\ no\ name\ found\ in\ columns = 

# at: src/main/java/org/zstack/zwatch/influxdb/InfluxDatabaseCreator.java:88
# args: retention,res.getError()
failed\ to\ create\ influxdb\ retention\ '%s',\ %s = 

# at: src/main/java/org/zstack/zwatch/influxdb/InfluxDatabaseCreator.java:81
# args: retention,res.getError()
failed\ to\ alter\ influxdb\ retention\ '%s',\ %s = 

# at: src/main/java/org/zstack/zwatch/namespace/AbstractNamespace.java:44
# args: getName(),queryObject.getMetricName()
namespace[%s]\ has\ no\ metric[%s] = 名字空间(namespace)[{0}]没有任何时序数据(metric)[{1}]

# at: src/main/java/org/zstack/zwatch/namespace/AbstractNamespace.java:50
# args: m.getName(),getName(),l.getKey()
metric[%s]\ of\ the\ namespace[%s]\ has\ no\ label\ named\ %s = 名字空间(namespace)[{1}]的时序数据(metric)[{1}]没有名为{2}的标签

# at: src/main/java/org/zstack/zwatch/namespace/NamespaceEventManagerImpl.java:400
# args: 
error\ happened\ but\ reason\ not\ specified = 发生了意想不到的错误

# at: src/main/java/org/zstack/zwatch/namespace/SystemNamespace.java:31
# args: d,Platform.getManagementServerIp()
folder[%s]\ not\ found\ on\ the\ management\ server[%s] = 在管理服务器[{1}]上找不到对应的文件夹[{0}]

# at: src/main/java/org/zstack/zwatch/ruleengine/ComparisonOperator.java:35
# args: 
LessThanOrEqualTo = 小于等于

# at: src/main/java/org/zstack/zwatch/ruleengine/ComparisonOperator.java:33
# args: 
LessThan = 小于

# at: src/main/java/org/zstack/zwatch/ruleengine/ComparisonOperator.java:31
# args: 
GreaterThan = 大于

# at: src/main/java/org/zstack/zwatch/ruleengine/ComparisonOperator.java:29
# args: 
GreaterThanOrEqualTo = 大于等于

# at: src/test/java/org/zstack/test/aop/ManInTheMiddleService.java:40
# args: 
unit\ test\ asks\ it\ to\ fail = 

# at: src/test/java/org/zstack/test/kvm/KVMPingAgentExtensionForTest.java:27
# args: 
on\ purpose = 